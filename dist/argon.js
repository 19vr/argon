!function(e){function t(e){Object.defineProperty(this,e,{enumerable:!0,get:function(){return this[v][e]}})}function r(e){var t;if(e&&e.__esModule){t={};for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);t.__useDefault=!1,t.__esModule=!0}else{if("[object Module]"===Object.prototype.toString.call(e)||"undefined"!=typeof System&&System.isModule&&System.isModule(e))return e;t={default:e,__useDefault:!0}}return new o(t)}function o(e){Object.defineProperty(this,v,{value:e}),Object.keys(e).forEach(t,this)}function n(e){return"@node/"===e.substr(0,6)?c(e,r(m(e.substr(6))),{}):p[e]}function u(e){var t=n(e);if(!t)throw new Error('Module "'+e+'" expected, but not contained in build.');if(t.module)return t.module;var r=t.linkRecord;return d(t,r),a(t,r,[]),t.module}function d(e,t){if(!t.depLoads){t.declare&&i(e,t),t.depLoads=[];for(var r=0;r<t.deps.length;r++){var o=n(t.deps[r]);t.depLoads.push(o),o.linkRecord&&d(o,o.linkRecord);var u=t.setters&&t.setters[r];u&&(u(o.module||o.linkRecord.moduleObj),o.importerSetters.push(u))}return e}}function i(t,r){var o=r.moduleObj,n=t.importerSetters,u=!1,d=r.declare.call(e,function(e,t){if(!u){if("object"==typeof e)for(var r in e)"__useDefault"!==r&&(o[r]=e[r]);else o[e]=t;u=!0;for(var d=0;d<n.length;d++)n[d](o);return u=!1,t}},{id:t.key});"function"!=typeof d?(r.setters=d.setters,r.execute=d.execute):(r.setters=[],r.execute=d)}function l(e,t,r){return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:r,setters:void 0,execute:void 0,moduleObj:{}}}}function f(e,t,r,o){return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:void 0,execute:o,executingRequire:r,moduleObj:{default:{},__useDefault:!0},setters:void 0}}}function s(e,t,r){return function(o){for(var n=0;n<e.length;n++)if(e[n]===o){var u,d=t[n];return u=-1===r.indexOf(d)?a(d,d.linkRecord,r):d.linkRecord.moduleObj,u.__useDefault?u.default:u}}}function a(t,r,n){if(n.push(t),t.module)return t.module;var u;if(r.setters){for(var d=0;d<r.deps.length;d++){var i=r.depLoads[d],l=i.linkRecord;l&&-1===n.indexOf(i)&&(u=a(i,l,l.setters?n:[]))}r.execute.call(y)}else{var f={id:t.key},c=r.moduleObj;Object.defineProperty(f,"exports",{configurable:!0,set:function(e){c.default=e},get:function(){return c.default}});var p=s(r.deps,r.depLoads,n);if(!r.executingRequire)for(var d=0;d<r.deps.length;d++)p(r.deps[d]);var v=r.execute.call(e,p,c.default,f);if(void 0!==v?c.default=v:f.exports!==c.default&&(c.default=f.exports),c.default&&c.default.__esModule)for(var m in c.default)Object.hasOwnProperty.call(c.default,m)&&"default"!==m&&(c[m]=c.default[m])}var f=t.module=new o(r.moduleObj);if(!r.setters)for(var d=0;d<t.importerSetters.length;d++)t.importerSetters[d](f);return f}function c(e,t){return p[e]={key:e,module:t,importerSetters:[],linkRecord:void 0}}var p={},v="undefined"!=typeof Symbol?Symbol():"@@baseObject";o.prototype=Object.create(null),"undefined"!=typeof Symbol&&Symbol.toStringTag&&(o.prototype[Symbol.toStringTag]="Module");var m="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,y={};return Object.freeze&&Object.freeze(y),function(e,t,n,d){return function(i){i(function(i){var s={_nodeRequire:m,register:l,registerDynamic:f,registry:{get:function(e){return p[e].module},set:c},newModule:function(e){return new o(e)}};c("@empty",new o({}));for(var a=0;a<t.length;a++)c(t[a],r(arguments[a],{}));d(s);var v=u(e[0]);if(e.length>1)for(var a=1;a<e.length;a++)u(e[a]);return n?v.default:(v instanceof o&&Object.defineProperty(v,"__esModule",{value:!0}),v)})}}}("undefined"!=typeof self?self:global)

(["a"], [], true, function($__System) {
var _dereq_ = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic('b', ['c'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaPal) {
    'use strict';

    Number.isNaN = Number.isNaN || function (value) {
      return value !== value;
    };

    Number.isFinite = Number.isFinite || function (value) {
      return typeof value === "number" && isFinite(value);
    };
    if (!String.prototype.endsWith) {
      String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
          position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
    }

    if (!String.prototype.startsWith) {
      String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.substr(position, searchString.length) === searchString;
      };
    }
    if (!Array.from) {
      Array.from = function () {
        var toStr = Object.prototype.toString;
        var isCallable = function isCallable(fn) {
          return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
        };
        var toInteger = function toInteger(value) {
          var number = Number(value);
          if (isNaN(number)) {
            return 0;
          }
          if (number === 0 || !isFinite(number)) {
            return number;
          }
          return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
        };
        var maxSafeInteger = Math.pow(2, 53) - 1;
        var toLength = function toLength(value) {
          var len = toInteger(value);
          return Math.min(Math.max(len, 0), maxSafeInteger);
        };

        return function from(arrayLike) {
          var C = this;

          var items = Object(arrayLike);

          if (arrayLike == null) {
            throw new TypeError("Array.from requires an array-like object - not null or undefined");
          }

          var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
          var T;
          if (typeof mapFn !== 'undefined') {
            if (!isCallable(mapFn)) {
              throw new TypeError('Array.from: when provided, the second argument must be a function');
            }

            if (arguments.length > 2) {
              T = arguments[2];
            }
          }

          var len = toLength(items.length);

          var A = isCallable(C) ? Object(new C(len)) : new Array(len);

          var k = 0;

          var kValue;
          while (k < len) {
            kValue = items[k];
            if (mapFn) {
              A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
            } else {
              A[k] = kValue;
            }
            k += 1;
          }

          A.length = len;

          return A;
        };
      }();
    }

    if (!Array.prototype.find) {
      Array.prototype.find = function (predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return value;
          }
        }
        return undefined;
      };
    }

    if (!Array.prototype.findIndex) {
      Array.prototype.findIndex = function (predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.findIndex called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
        return -1;
      };
    }

    if (!Array.prototype.includes) {
      Array.prototype.includes = function (searchElement) {
        var O = Object(this);
        var len = parseInt(O.length) || 0;
        if (len === 0) {
          return false;
        }
        var n = parseInt(arguments[1]) || 0;
        var k;
        if (n >= 0) {
          k = n;
        } else {
          k = len + n;
          if (k < 0) {
            k = 0;
          }
        }
        var currentElement;
        while (k < len) {
          currentElement = O[k];
          if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
            return true;
          }
          k++;
        }
        return false;
      };
    }
    if (typeof Object.assign !== 'function') {
      Object.assign = function (target) {
        if (target === undefined || target === null) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);

        for (var index = 1; index < arguments.length; index++) {
          var source = arguments[index];

          if (source !== undefined && source !== null) {
            for (var nextKey in source) {
              if (source.hasOwnProperty(nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }

        return output;
      };
    }
    (function (global) {
      var i = undefined;

      var defineProperty = Object.defineProperty;
      var is = function is(a, b) {
        return a === b || a !== a && b !== b;
      };

      if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
        global.Map = createCollection({
          'delete': sharedDelete,

          has: mapHas,

          get: sharedGet,

          set: sharedSet,

          keys: sharedKeys,

          values: sharedValues,

          entries: mapEntries,

          forEach: sharedForEach,

          clear: sharedClear
        });
      }

      if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
        global.Set = createCollection({
          has: setHas,

          add: sharedAdd,

          'delete': sharedDelete,

          clear: sharedClear,

          keys: sharedValues,
          values: sharedValues,

          entries: setEntries,

          forEach: sharedForEach
        });
      }

      function createCollection(proto, objectOnly) {
        function Collection(a) {
          if (!this || this.constructor !== Collection) return new Collection(a);
          this._keys = [];
          this._values = [];
          this._itp = [];
          this.objectOnly = objectOnly;

          if (a) init.call(this, a);
        }

        if (!objectOnly) {
          defineProperty(proto, 'size', {
            get: sharedSize
          });
        }

        proto.constructor = Collection;
        Collection.prototype = proto;

        return Collection;
      }

      function init(a) {
        var i;

        if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {
          this.set(a[0], a[1]);
        }, this);
      }

      function sharedDelete(key) {
        if (this.has(key)) {
          this._keys.splice(i, 1);
          this._values.splice(i, 1);

          this._itp.forEach(function (p) {
            if (i < p[0]) p[0]--;
          });
        }

        return -1 < i;
      };

      function sharedGet(key) {
        return this.has(key) ? this._values[i] : undefined;
      }

      function has(list, key) {
        if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");

        if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
        return -1 < i;
      }

      function setHas(value) {
        return has.call(this, this._values, value);
      }

      function mapHas(value) {
        return has.call(this, this._keys, value);
      }

      function sharedSet(key, value) {
        this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
        return this;
      }

      function sharedAdd(value) {
        if (!this.has(value)) this._values.push(value);
        return this;
      }

      function sharedClear() {
        (this._keys || 0).length = this._values.length = 0;
      }

      function sharedKeys() {
        return sharedIterator(this._itp, this._keys);
      }

      function sharedValues() {
        return sharedIterator(this._itp, this._values);
      }

      function mapEntries() {
        return sharedIterator(this._itp, this._keys, this._values);
      }

      function setEntries() {
        return sharedIterator(this._itp, this._values, this._values);
      }

      function sharedIterator(itp, array, array2) {
        var p = [0],
            done = false;
        itp.push(p);
        return {
          next: function next() {
            var v,
                k = p[0];
            if (!done && k < array.length) {
              v = array2 ? [array[k], array2[k]] : array[k];
              p[0]++;
            } else {
              done = true;
              itp.splice(itp.indexOf(p), 1);
            }
            return { done: done, value: v };
          }
        };
      }

      function sharedSize() {
        return this._values.length;
      }

      function sharedForEach(callback, context) {
        var it = this.entries();
        for (;;) {
          var r = it.next();
          if (r.done) break;
          callback.call(context, r.value[1], r.value[0], this);
        }
      }
    })(_aureliaPal.PLATFORM.global);
    var emptyMetadata = Object.freeze({});
    var metadataContainerKey = '__metadata__';
    var bind = Function.prototype.bind;

    if (typeof _aureliaPal.PLATFORM.global.Reflect === 'undefined') {
      _aureliaPal.PLATFORM.global.Reflect = {};
    }

    if (typeof Reflect.getOwnMetadata !== 'function') {
      Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {
        return ((target[metadataContainerKey] || emptyMetadata)[targetKey] || emptyMetadata)[metadataKey];
      };
    }

    if (typeof Reflect.defineMetadata !== 'function') {
      Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {
        var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
        var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
        targetContainer[metadataKey] = metadataValue;
      };
    }

    if (typeof Reflect.metadata !== 'function') {
      Reflect.metadata = function (metadataKey, metadataValue) {
        return function (target, targetKey) {
          Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
        };
      };
    }

    if (typeof Reflect.construct !== 'function') {
      Reflect.construct = function (Target, args) {
        if (args) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        }

        var a = [null];
        a.push.apply(a, args);
        return new (bind.apply(Target, a))();
      };
    }
  }).call($__exports, $__exports, $__require('c'));
});
/*! https://mths.be/punycode v1.4.0 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module && !module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.3.2',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ('function' == 'function' && 'object' == 'object' && true) {
		$__System.registerDynamic('d', [], false, function ($__require, $__exports, $__module) {
			return (function () {
				return punycode;
			}).call(this);
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(this);
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.18.1
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js

  if (typeof exports === 'object') {
    // Node
    module.exports = factory();
  } else if ('function' === 'function' && true) {
    // AMD. Register as an anonymous module.
    $__System.registerDynamic('e', [], false, function ($__require, $__exports, $__module) {
      if (typeof factory === 'function') {
        return factory.call(this);
      } else {
        return factory;
      }
    });
  } else {
    // Browser globals (root is window)
    root.IPv6 = factory(root);
  }
})(this, function (root) {
  'use strict';

  /*
  var _in = "fe80:0000:0000:0000:0204:61ff:fe9d:f156";
  var _out = IPv6.best(_in);
  var _expected = "fe80::204:61ff:fe9d:f156";
   console.log(_in, _out, _expected, _out === _expected);
  */

  // save current IPv6 variable, if any

  var _IPv6 = root && root.IPv6;

  function bestPresentation(address) {
    // based on:
    // Javascript to test an IPv6 address for proper format, and to
    // present the "best text representation" according to IETF Draft RFC at
    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04
    // 8 Feb 2010 Rich Brown, Dartware, LLC
    // Please feel free to use this code as long as you provide a link to
    // http://www.intermapper.com
    // http://intermapper.com/support/tools/IPV6-Validator.aspx
    // http://download.dartware.com/thirdparty/ipv6validator.js

    var _address = address.toLowerCase();
    var segments = _address.split(':');
    var length = segments.length;
    var total = 8;

    // trim colons (:: or ::a:b:c… or …a:b:c::)
    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
      // must have been ::
      // remove first two items
      segments.shift();
      segments.shift();
    } else if (segments[0] === '' && segments[1] === '') {
      // must have been ::xxxx
      // remove the first item
      segments.shift();
    } else if (segments[length - 1] === '' && segments[length - 2] === '') {
      // must have been xxxx::
      segments.pop();
    }

    length = segments.length;

    // adjust total segments for IPv4 trailer
    if (segments[length - 1].indexOf('.') !== -1) {
      // found a "." which means IPv4
      total = 7;
    }

    // fill empty segments them with "0000"
    var pos;
    for (pos = 0; pos < length; pos++) {
      if (segments[pos] === '') {
        break;
      }
    }

    if (pos < total) {
      segments.splice(pos, 1, '0000');
      while (segments.length < total) {
        segments.splice(pos, 0, '0000');
      }
    }

    // strip leading zeros
    var _segments;
    for (var i = 0; i < total; i++) {
      _segments = segments[i].split('');
      for (var j = 0; j < 3; j++) {
        if (_segments[0] === '0' && _segments.length > 1) {
          _segments.splice(0, 1);
        } else {
          break;
        }
      }

      segments[i] = _segments.join('');
    }

    // find longest sequence of zeroes and coalesce them into one segment
    var best = -1;
    var _best = 0;
    var _current = 0;
    var current = -1;
    var inzeroes = false;
    // i; already declared

    for (i = 0; i < total; i++) {
      if (inzeroes) {
        if (segments[i] === '0') {
          _current += 1;
        } else {
          inzeroes = false;
          if (_current > _best) {
            best = current;
            _best = _current;
          }
        }
      } else {
        if (segments[i] === '0') {
          inzeroes = true;
          current = i;
          _current = 1;
        }
      }
    }

    if (_current > _best) {
      best = current;
      _best = _current;
    }

    if (_best > 1) {
      segments.splice(best, _best, '');
    }

    length = segments.length;

    // assemble remaining segments
    var result = '';
    if (segments[0] === '') {
      result = ':';
    }

    for (i = 0; i < length; i++) {
      result += segments[i];
      if (i === length - 1) {
        break;
      }

      result += ':';
    }

    if (segments[length - 1] === '') {
      result += ':';
    }

    return result;
  }

  function noConflict() {
    /*jshint validthis: true */
    if (root.IPv6 === this) {
      root.IPv6 = _IPv6;
    }

    return this;
  }

  return {
    best: bestPresentation,
    noConflict: noConflict
  };
});
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.18.1
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js

  if (typeof exports === 'object') {
    // Node
    module.exports = factory();
  } else if ('function' === 'function' && true) {
    // AMD. Register as an anonymous module.
    $__System.registerDynamic('f', [], false, function ($__require, $__exports, $__module) {
      if (typeof factory === 'function') {
        return factory.call(this);
      } else {
        return factory;
      }
    });
  } else {
    // Browser globals (root is window)
    root.SecondLevelDomains = factory(root);
  }
})(this, function (root) {
  'use strict';

  // save current SecondLevelDomains variable, if any

  var _SecondLevelDomains = root && root.SecondLevelDomains;

  var SLD = {
    // list of known Second Level Domains
    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
    // ----
    // publicsuffix.org is more current and actually used by a couple of browsers internally.
    // downside is it also contains domains like "dyndns.org" - which is fine for the security
    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
    // ----
    list: {
      'ac': ' com gov mil net org ',
      'ae': ' ac co gov mil name net org pro sch ',
      'af': ' com edu gov net org ',
      'al': ' com edu gov mil net org ',
      'ao': ' co ed gv it og pb ',
      'ar': ' com edu gob gov int mil net org tur ',
      'at': ' ac co gv or ',
      'au': ' asn com csiro edu gov id net org ',
      'ba': ' co com edu gov mil net org rs unbi unmo unsa untz unze ',
      'bb': ' biz co com edu gov info net org store tv ',
      'bh': ' biz cc com edu gov info net org ',
      'bn': ' com edu gov net org ',
      'bo': ' com edu gob gov int mil net org tv ',
      'br': ' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
      'bs': ' com edu gov net org ',
      'bz': ' du et om ov rg ',
      'ca': ' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
      'ck': ' biz co edu gen gov info net org ',
      'cn': ' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
      'co': ' com edu gov mil net nom org ',
      'cr': ' ac c co ed fi go or sa ',
      'cy': ' ac biz com ekloges gov ltd name net org parliament press pro tm ',
      'do': ' art com edu gob gov mil net org sld web ',
      'dz': ' art asso com edu gov net org pol ',
      'ec': ' com edu fin gov info med mil net org pro ',
      'eg': ' com edu eun gov mil name net org sci ',
      'er': ' com edu gov ind mil net org rochest w ',
      'es': ' com edu gob nom org ',
      'et': ' biz com edu gov info name net org ',
      'fj': ' ac biz com info mil name net org pro ',
      'fk': ' ac co gov net nom org ',
      'fr': ' asso com f gouv nom prd presse tm ',
      'gg': ' co net org ',
      'gh': ' com edu gov mil org ',
      'gn': ' ac com gov net org ',
      'gr': ' com edu gov mil net org ',
      'gt': ' com edu gob ind mil net org ',
      'gu': ' com edu gov net org ',
      'hk': ' com edu gov idv net org ',
      'hu': ' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
      'id': ' ac co go mil net or sch web ',
      'il': ' ac co gov idf k12 muni net org ',
      'in': ' ac co edu ernet firm gen gov i ind mil net nic org res ',
      'iq': ' com edu gov i mil net org ',
      'ir': ' ac co dnssec gov i id net org sch ',
      'it': ' edu gov ',
      'je': ' co net org ',
      'jo': ' com edu gov mil name net org sch ',
      'jp': ' ac ad co ed go gr lg ne or ',
      'ke': ' ac co go info me mobi ne or sc ',
      'kh': ' com edu gov mil net org per ',
      'ki': ' biz com de edu gov info mob net org tel ',
      'km': ' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
      'kn': ' edu gov net org ',
      'kr': ' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
      'kw': ' com edu gov net org ',
      'ky': ' com edu gov net org ',
      'kz': ' com edu gov mil net org ',
      'lb': ' com edu gov net org ',
      'lk': ' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
      'lr': ' com edu gov net org ',
      'lv': ' asn com conf edu gov id mil net org ',
      'ly': ' com edu gov id med net org plc sch ',
      'ma': ' ac co gov m net org press ',
      'mc': ' asso tm ',
      'me': ' ac co edu gov its net org priv ',
      'mg': ' com edu gov mil nom org prd tm ',
      'mk': ' com edu gov inf name net org pro ',
      'ml': ' com edu gov net org presse ',
      'mn': ' edu gov org ',
      'mo': ' com edu gov net org ',
      'mt': ' com edu gov net org ',
      'mv': ' aero biz com coop edu gov info int mil museum name net org pro ',
      'mw': ' ac co com coop edu gov int museum net org ',
      'mx': ' com edu gob net org ',
      'my': ' com edu gov mil name net org sch ',
      'nf': ' arts com firm info net other per rec store web ',
      'ng': ' biz com edu gov mil mobi name net org sch ',
      'ni': ' ac co com edu gob mil net nom org ',
      'np': ' com edu gov mil net org ',
      'nr': ' biz com edu gov info net org ',
      'om': ' ac biz co com edu gov med mil museum net org pro sch ',
      'pe': ' com edu gob mil net nom org sld ',
      'ph': ' com edu gov i mil net ngo org ',
      'pk': ' biz com edu fam gob gok gon gop gos gov net org web ',
      'pl': ' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
      'pr': ' ac biz com edu est gov info isla name net org pro prof ',
      'ps': ' com edu gov net org plo sec ',
      'pw': ' belau co ed go ne or ',
      'ro': ' arts com firm info nom nt org rec store tm www ',
      'rs': ' ac co edu gov in org ',
      'sb': ' com edu gov net org ',
      'sc': ' com edu gov net org ',
      'sh': ' co com edu gov net nom org ',
      'sl': ' com edu gov net org ',
      'st': ' co com consulado edu embaixada gov mil net org principe saotome store ',
      'sv': ' com edu gob org red ',
      'sz': ' ac co org ',
      'tr': ' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
      'tt': ' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
      'tw': ' club com ebiz edu game gov idv mil net org ',
      'mu': ' ac co com gov net or org ',
      'mz': ' ac co edu gov org ',
      'na': ' co com ',
      'nz': ' ac co cri geek gen govt health iwi maori mil net org parliament school ',
      'pa': ' abo ac com edu gob ing med net nom org sld ',
      'pt': ' com edu gov int net nome org publ ',
      'py': ' com edu gov mil net org ',
      'qa': ' com edu gov mil net org ',
      're': ' asso com nom ',
      'ru': ' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
      'rw': ' ac co com edu gouv gov int mil net ',
      'sa': ' com edu gov med net org pub sch ',
      'sd': ' com edu gov info med net org tv ',
      'se': ' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
      'sg': ' com edu gov idn net org per ',
      'sn': ' art com edu gouv org perso univ ',
      'sy': ' com edu gov mil net news org ',
      'th': ' ac co go in mi net or ',
      'tj': ' ac biz co com edu go gov info int mil name net nic org test web ',
      'tn': ' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
      'tz': ' ac co go ne or ',
      'ua': ' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
      'ug': ' ac co go ne or org sc ',
      'uk': ' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
      'us': ' dni fed isa kids nsn ',
      'uy': ' com edu gub mil net org ',
      've': ' co com edu gob info mil net org web ',
      'vi': ' co com k12 net org ',
      'vn': ' ac biz com edu gov health info int name net org pro ',
      'ye': ' co com gov ltd me net org plc ',
      'yu': ' ac co edu gov org ',
      'za': ' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
      'zm': ' ac co com edu gov net org sch '
    },
    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
    // in both performance and memory footprint. No initialization required.
    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
    // Following methods use lastIndexOf() rather than array.split() in order
    // to avoid any memory allocations.
    has: function (domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
        return false;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
      if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
        return false;
      }
      var sldList = SLD.list[domain.slice(tldOffset + 1)];
      if (!sldList) {
        return false;
      }
      return sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') >= 0;
    },
    is: function (domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
        return false;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
      if (sldOffset >= 0) {
        return false;
      }
      var sldList = SLD.list[domain.slice(tldOffset + 1)];
      if (!sldList) {
        return false;
      }
      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
    },
    get: function (domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
        return null;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
      if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
        return null;
      }
      var sldList = SLD.list[domain.slice(tldOffset + 1)];
      if (!sldList) {
        return null;
      }
      if (sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') < 0) {
        return null;
      }
      return domain.slice(sldOffset + 1);
    },
    noConflict: function () {
      if (root.SecondLevelDomains === this) {
        root.SecondLevelDomains = _SecondLevelDomains;
      }
      return this;
    }
  };

  return SLD;
});
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.18.1
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js

  if (typeof exports === 'object') {
    // Node
    module.exports = factory(_dereq_('./punycode'), _dereq_('./IPv6'), _dereq_('./SecondLevelDomains'));
  } else if ('function' === 'function' && true) {
    // AMD. Register as an anonymous module.
    $__System.registerDynamic('10', ['d', 'e', 'f'], false, function ($__require, $__exports, $__module) {
      if (typeof factory === 'function') {
        return factory.call(this, $__require('d'), $__require('e'), $__require('f'));
      } else {
        return factory;
      }
    });
  } else {
    // Browser globals (root is window)
    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
  }
})(this, function (punycode, IPv6, SLD, root) {
  'use strict';
  /*global location, escape, unescape */
  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
  /*jshint camelcase: false */

  // save current URI variable, if any

  var _URI = root && root.URI;

  function URI(url, base) {
    var _urlSupplied = arguments.length >= 1;
    var _baseSupplied = arguments.length >= 2;

    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URI)) {
      if (_urlSupplied) {
        if (_baseSupplied) {
          return new URI(url, base);
        }

        return new URI(url);
      }

      return new URI();
    }

    if (url === undefined) {
      if (_urlSupplied) {
        throw new TypeError('undefined is not a valid argument for URI');
      }

      if (typeof location !== 'undefined') {
        url = location.href + '';
      } else {
        url = '';
      }
    }

    this.href(url);

    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
    if (base !== undefined) {
      return this.absoluteTo(base);
    }

    return this;
  }

  URI.version = '1.18.1';

  var p = URI.prototype;
  var hasOwn = Object.prototype.hasOwnProperty;

  function escapeRegEx(string) {
    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  function getType(value) {
    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
    if (value === undefined) {
      return 'Undefined';
    }

    return String(Object.prototype.toString.call(value)).slice(8, -1);
  }

  function isArray(obj) {
    return getType(obj) === 'Array';
  }

  function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;

    if (getType(value) === 'RegExp') {
      lookup = null;
    } else if (isArray(value)) {
      for (i = 0, length = value.length; i < length; i++) {
        lookup[value[i]] = true;
      }
    } else {
      lookup[value] = true;
    }

    for (i = 0, length = data.length; i < length; i++) {
      /*jshint laxbreak: true */
      var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);
      /*jshint laxbreak: false */
      if (_match) {
        data.splice(i, 1);
        length--;
        i--;
      }
    }

    return data;
  }

  function arrayContains(list, value) {
    var i, length;

    // value may be string, number, array, regexp
    if (isArray(value)) {
      // Note: this can be optimized to O(n) (instead of current O(m * n))
      for (i = 0, length = value.length; i < length; i++) {
        if (!arrayContains(list, value[i])) {
          return false;
        }
      }

      return true;
    }

    var _type = getType(value);
    for (i = 0, length = list.length; i < length; i++) {
      if (_type === 'RegExp') {
        if (typeof list[i] === 'string' && list[i].match(value)) {
          return true;
        }
      } else if (list[i] === value) {
        return true;
      }
    }

    return false;
  }

  function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
      return false;
    }

    // arrays can't be equal if they have different amount of content
    if (one.length !== two.length) {
      return false;
    }

    one.sort();
    two.sort();

    for (var i = 0, l = one.length; i < l; i++) {
      if (one[i] !== two[i]) {
        return false;
      }
    }

    return true;
  }

  function trimSlashes(text) {
    var trim_expression = /^\/+|\/+$/g;
    return text.replace(trim_expression, '');
  }

  URI._parts = function () {
    return {
      protocol: null,
      username: null,
      password: null,
      hostname: null,
      urn: null,
      port: null,
      path: null,
      query: null,
      fragment: null,
      // state
      duplicateQueryParameters: URI.duplicateQueryParameters,
      escapeQuerySpace: URI.escapeQuerySpace
    };
  };
  // state: allow duplicate query parameters (a=1&a=1)
  URI.duplicateQueryParameters = false;
  // state: replaces + with %20 (space in query strings)
  URI.escapeQuerySpace = true;
  // static properties
  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
  URI.idn_expression = /[^a-z0-9\.-]/i;
  URI.punycode_expression = /(xn--)/i;
  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  // credits to Rich Brown
  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
  // specification: http://www.ietf.org/rfc/rfc4291.txt
  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  // expression used is "gruber revised" (@gruber v2) determined to be the
  // best solution in a regex-golf we did a couple of ages ago at
  // * http://mathiasbynens.be/demo/url-regex
  // * http://rodneyrehm.de/t/url-regex.html
  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
  URI.findUri = {
    // valid "scheme://" or "www."
    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
    // everything up to the next whitespace
    end: /[\s\r\n]|$/,
    // trim trailing punctuation captured by end RegExp
    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
  };
  // http://www.iana.org/assignments/uri-schemes.html
  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
  URI.defaultPorts = {
    http: '80',
    https: '443',
    ftp: '21',
    gopher: '70',
    ws: '80',
    wss: '443'
  };
  // allowed hostname characters according to RFC 3986
  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
  // map DOM Elements to their URI attribute
  URI.domAttributes = {
    'a': 'href',
    'blockquote': 'cite',
    'link': 'href',
    'base': 'href',
    'script': 'src',
    'form': 'action',
    'img': 'src',
    'area': 'href',
    'iframe': 'src',
    'embed': 'src',
    'source': 'src',
    'track': 'src',
    'input': 'src', // but only if type="image"
    'audio': 'src',
    'video': 'src'
  };
  URI.getDomAttribute = function (node) {
    if (!node || !node.nodeName) {
      return undefined;
    }

    var nodeName = node.nodeName.toLowerCase();
    // <input> should only expose src for type="image"
    if (nodeName === 'input' && node.type !== 'image') {
      return undefined;
    }

    return URI.domAttributes[nodeName];
  };

  function escapeForDumbFirefox36(value) {
    // https://github.com/medialize/URI.js/issues/91
    return escape(value);
  }

  // encoding / decoding according to RFC3986
  function strictEncodeURIComponent(string) {
    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
    return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, '%2A');
  }
  URI.encode = strictEncodeURIComponent;
  URI.decode = decodeURIComponent;
  URI.iso8859 = function () {
    URI.encode = escape;
    URI.decode = unescape;
  };
  URI.unicode = function () {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
  };
  URI.characters = {
    pathname: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
        map: {
          // -._~!'()*
          '%24': '$',
          '%26': '&',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%3A': ':',
          '%40': '@'
        }
      },
      decode: {
        expression: /[\/\?#]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23'
        }
      }
    },
    reserved: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
        map: {
          // gen-delims
          '%3A': ':',
          '%2F': '/',
          '%3F': '?',
          '%23': '#',
          '%5B': '[',
          '%5D': ']',
          '%40': '@',
          // sub-delims
          '%21': '!',
          '%24': '$',
          '%26': '&',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '='
        }
      }
    },
    urnpath: {
      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
      // note that the colon character is not featured in the encoding map; this is because URI.js
      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
      // should not appear unencoded in a segment itself.
      // See also the note above about RFC3986 and capitalalized hex digits.
      encode: {
        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
        map: {
          '%21': '!',
          '%24': '$',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%40': '@'
        }
      },
      // These characters are the characters called out by RFC2141 as "reserved" characters that
      // should never appear in a URN, plus the colon character (see note above).
      decode: {
        expression: /[\/\?#:]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23',
          ':': '%3A'
        }
      }
    }
  };
  URI.encodeQuery = function (string, escapeQuerySpace) {
    var escaped = URI.encode(string + '');
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
  };
  URI.decodeQuery = function (string, escapeQuerySpace) {
    string += '';
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    try {
      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
    } catch (e) {
      // we're not going to mess with weird encodings,
      // give up and return the undecoded original string
      // see https://github.com/medialize/URI.js/issues/87
      // see https://github.com/medialize/URI.js/issues/92
      return string;
    }
  };
  // generate encode/decode path functions
  var _parts = { 'encode': 'encode', 'decode': 'decode' };
  var _part;
  var generateAccessor = function (_group, _part) {
    return function (string) {
      try {
        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function (c) {
          return URI.characters[_group][_part].map[c];
        });
      } catch (e) {
        // we're not going to mess with weird encodings,
        // give up and return the undecoded original string
        // see https://github.com/medialize/URI.js/issues/87
        // see https://github.com/medialize/URI.js/issues/92
        return string;
      }
    };
  };

  for (_part in _parts) {
    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
  }

  var generateSegmentedPathFunction = function (_sep, _codingFuncName, _innerCodingFuncName) {
    return function (string) {
      // Why pass in names of functions, rather than the function objects themselves? The
      // definitions of some functions (but in particular, URI.decode) will occasionally change due
      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
      // that the functions we use here are "fresh".
      var actualCodingFunc;
      if (!_innerCodingFuncName) {
        actualCodingFunc = URI[_codingFuncName];
      } else {
        actualCodingFunc = function (string) {
          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
        };
      }

      var segments = (string + '').split(_sep);

      for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = actualCodingFunc(segments[i]);
      }

      return segments.join(_sep);
    };
  };

  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');

  URI.encodeReserved = generateAccessor('reserved', 'encode');

  URI.parse = function (string, parts) {
    var pos;
    if (!parts) {
      parts = {};
    }
    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

    // extract fragment
    pos = string.indexOf('#');
    if (pos > -1) {
      // escaping?
      parts.fragment = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract query
    pos = string.indexOf('?');
    if (pos > -1) {
      // escaping?
      parts.query = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract protocol
    if (string.substring(0, 2) === '//') {
      // relative-scheme
      parts.protocol = null;
      string = string.substring(2);
      // extract "user:pass@host:port"
      string = URI.parseAuthority(string, parts);
    } else {
      pos = string.indexOf(':');
      if (pos > -1) {
        parts.protocol = string.substring(0, pos) || null;
        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
          // : may be within the path
          parts.protocol = undefined;
        } else if (string.substring(pos + 1, pos + 3) === '//') {
          string = string.substring(pos + 3);

          // extract "user:pass@host:port"
          string = URI.parseAuthority(string, parts);
        } else {
          string = string.substring(pos + 1);
          parts.urn = true;
        }
      }
    }

    // what's left must be the path
    parts.path = string;

    // and we're done
    return parts;
  };
  URI.parseHost = function (string, parts) {
    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    // https://github.com/medialize/URI.js/pull/233
    string = string.replace(/\\/g, '/');

    // extract host:port
    var pos = string.indexOf('/');
    var bracketPos;
    var t;

    if (pos === -1) {
      pos = string.length;
    }

    if (string.charAt(0) === '[') {
      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
      bracketPos = string.indexOf(']');
      parts.hostname = string.substring(1, bracketPos) || null;
      parts.port = string.substring(bracketPos + 2, pos) || null;
      if (parts.port === '/') {
        parts.port = null;
      }
    } else {
      var firstColon = string.indexOf(':');
      var firstSlash = string.indexOf('/');
      var nextColon = string.indexOf(':', firstColon + 1);
      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
        // IPv6 host contains multiple colons - but no port
        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
      } else {
        t = string.substring(0, pos).split(':');
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
      }
    }

    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
      pos++;
      string = '/' + string;
    }

    return string.substring(pos) || '/';
  };
  URI.parseAuthority = function (string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
  };
  URI.parseUserinfo = function (string, parts) {
    // extract username:password
    var firstSlash = string.indexOf('/');
    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
    var t;

    // authority@ must come before /path
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
      t = string.substring(0, pos).split(':');
      parts.username = t[0] ? URI.decode(t[0]) : null;
      t.shift();
      parts.password = t[0] ? URI.decode(t.join(':')) : null;
      string = string.substring(pos + 1);
    } else {
      parts.username = null;
      parts.password = null;
    }

    return string;
  };
  URI.parseQuery = function (string, escapeQuerySpace) {
    if (!string) {
      return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

    if (!string) {
      return {};
    }

    var items = {};
    var splits = string.split('&');
    var length = splits.length;
    var v, name, value;

    for (var i = 0; i < length; i++) {
      v = splits[i].split('=');
      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

      if (hasOwn.call(items, name)) {
        if (typeof items[name] === 'string' || items[name] === null) {
          items[name] = [items[name]];
        }

        items[name].push(value);
      } else {
        items[name] = value;
      }
    }

    return items;
  };

  URI.build = function (parts) {
    var t = '';

    if (parts.protocol) {
      t += parts.protocol + ':';
    }

    if (!parts.urn && (t || parts.hostname)) {
      t += '//';
    }

    t += URI.buildAuthority(parts) || '';

    if (typeof parts.path === 'string') {
      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
        t += '/';
      }

      t += parts.path;
    }

    if (typeof parts.query === 'string' && parts.query) {
      t += '?' + parts.query;
    }

    if (typeof parts.fragment === 'string' && parts.fragment) {
      t += '#' + parts.fragment;
    }
    return t;
  };
  URI.buildHost = function (parts) {
    var t = '';

    if (!parts.hostname) {
      return '';
    } else if (URI.ip6_expression.test(parts.hostname)) {
      t += '[' + parts.hostname + ']';
    } else {
      t += parts.hostname;
    }

    if (parts.port) {
      t += ':' + parts.port;
    }

    return t;
  };
  URI.buildAuthority = function (parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
  };
  URI.buildUserinfo = function (parts) {
    var t = '';

    if (parts.username) {
      t += URI.encode(parts.username);
    }

    if (parts.password) {
      t += ':' + URI.encode(parts.password);
    }

    if (t) {
      t += '@';
    }

    return t;
  };
  URI.buildQuery = function (data, duplicateQueryParameters, escapeQuerySpace) {
    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
    // URI.js treats the query string as being application/x-www-form-urlencoded
    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

    var t = '';
    var unique, key, i, length;
    for (key in data) {
      if (hasOwn.call(data, key) && key) {
        if (isArray(data[key])) {
          unique = {};
          for (i = 0, length = data[key].length; i < length; i++) {
            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
              if (duplicateQueryParameters !== true) {
                unique[data[key][i] + ''] = true;
              }
            }
          }
        } else if (data[key] !== undefined) {
          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
        }
      }
    }

    return t.substring(1);
  };
  URI.buildQueryParameter = function (name, value, escapeQuerySpace) {
    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
  };

  URI.addQuery = function (data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.addQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (data[name] === undefined) {
        data[name] = value;
        return;
      } else if (typeof data[name] === 'string') {
        data[name] = [data[name]];
      }

      if (!isArray(value)) {
        value = [value];
      }

      data[name] = (data[name] || []).concat(value);
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }
  };
  URI.removeQuery = function (data, name, value) {
    var i, length, key;

    if (isArray(name)) {
      for (i = 0, length = name.length; i < length; i++) {
        data[name[i]] = undefined;
      }
    } else if (getType(name) === 'RegExp') {
      for (key in data) {
        if (name.test(key)) {
          data[key] = undefined;
        }
      }
    } else if (typeof name === 'object') {
      for (key in name) {
        if (hasOwn.call(name, key)) {
          URI.removeQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (value !== undefined) {
        if (getType(value) === 'RegExp') {
          if (!isArray(data[name]) && value.test(data[name])) {
            data[name] = undefined;
          } else {
            data[name] = filterArrayValues(data[name], value);
          }
        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
          data[name] = undefined;
        } else if (isArray(data[name])) {
          data[name] = filterArrayValues(data[name], value);
        }
      } else {
        data[name] = undefined;
      }
    } else {
      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
    }
  };
  URI.hasQuery = function (data, name, value, withinArray) {
    switch (getType(name)) {
      case 'String':
        // Nothing to do here
        break;

      case 'RegExp':
        for (var key in data) {
          if (hasOwn.call(data, key)) {
            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
              return true;
            }
          }
        }

        return false;

      case 'Object':
        for (var _key in name) {
          if (hasOwn.call(name, _key)) {
            if (!URI.hasQuery(data, _key, name[_key])) {
              return false;
            }
          }
        }

        return true;

      default:
        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
    }

    switch (getType(value)) {
      case 'Undefined':
        // true if exists (but may be empty)
        return name in data; // data[name] !== undefined;

      case 'Boolean':
        // true if exists and non-empty
        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
        return value === _booly;

      case 'Function':
        // allow complex comparison
        return !!value(data[name], name, data);

      case 'Array':
        if (!isArray(data[name])) {
          return false;
        }

        var op = withinArray ? arrayContains : arraysEqual;
        return op(data[name], value);

      case 'RegExp':
        if (!isArray(data[name])) {
          return Boolean(data[name] && data[name].match(value));
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      case 'Number':
        value = String(value);
      /* falls through */
      case 'String':
        if (!isArray(data[name])) {
          return data[name] === value;
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      default:
        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
    }
  };

  URI.joinPaths = function () {
    var input = [];
    var segments = [];
    var nonEmptySegments = 0;

    for (var i = 0; i < arguments.length; i++) {
      var url = new URI(arguments[i]);
      input.push(url);
      var _segments = url.segment();
      for (var s = 0; s < _segments.length; s++) {
        if (typeof _segments[s] === 'string') {
          segments.push(_segments[s]);
        }

        if (_segments[s]) {
          nonEmptySegments++;
        }
      }
    }

    if (!segments.length || !nonEmptySegments) {
      return new URI('');
    }

    var uri = new URI('').segment(segments);

    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
      uri.path('/' + uri.path());
    }

    return uri.normalize();
  };

  URI.commonPath = function (one, two) {
    var length = Math.min(one.length, two.length);
    var pos;

    // find first non-matching character
    for (pos = 0; pos < length; pos++) {
      if (one.charAt(pos) !== two.charAt(pos)) {
        pos--;
        break;
      }
    }

    if (pos < 1) {
      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
    }

    // revert to last /
    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
      pos = one.substring(0, pos).lastIndexOf('/');
    }

    return one.substring(0, pos + 1);
  };

  URI.withinString = function (string, callback, options) {
    options || (options = {});
    var _start = options.start || URI.findUri.start;
    var _end = options.end || URI.findUri.end;
    var _trim = options.trim || URI.findUri.trim;
    var _attributeOpen = /[a-z0-9-]=["']?$/i;

    _start.lastIndex = 0;
    while (true) {
      var match = _start.exec(string);
      if (!match) {
        break;
      }

      var start = match.index;
      if (options.ignoreHtml) {
        // attribut(e=["']?$)
        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
          continue;
        }
      }

      var end = start + string.slice(start).search(_end);
      var slice = string.slice(start, end).replace(_trim, '');
      if (options.ignore && options.ignore.test(slice)) {
        continue;
      }

      end = start + slice.length;
      var result = callback(slice, start, end, string);
      string = string.slice(0, start) + result + string.slice(end);
      _start.lastIndex = start + result.length;
    }

    _start.lastIndex = 0;
    return string;
  };

  URI.ensureValidHostname = function (v) {
    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
    // they are not part of DNS and therefore ignored by URI.js

    if (v.match(URI.invalid_hostname_characters)) {
      // test punycode
      if (!punycode) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
      }

      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }
    }
  };

  // noConflict
  URI.noConflict = function (removeAll) {
    if (removeAll) {
      var unconflicted = {
        URI: this.noConflict()
      };

      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
        unconflicted.URITemplate = root.URITemplate.noConflict();
      }

      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
        unconflicted.IPv6 = root.IPv6.noConflict();
      }

      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
      }

      return unconflicted;
    } else if (root.URI === this) {
      root.URI = _URI;
    }

    return this;
  };

  p.build = function (deferBuild) {
    if (deferBuild === true) {
      this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
      this._string = URI.build(this._parts);
      this._deferred_build = false;
    }

    return this;
  };

  p.clone = function () {
    return new URI(this);
  };

  p.valueOf = p.toString = function () {
    return this.build(false)._string;
  };

  function generateSimpleAccessor(_part) {
    return function (v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        this._parts[_part] = v || null;
        this.build(!build);
        return this;
      }
    };
  }

  function generatePrefixAccessor(_part, _key) {
    return function (v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        if (v !== null) {
          v = v + '';
          if (v.charAt(0) === _key) {
            v = v.substring(1);
          }
        }

        this._parts[_part] = v;
        this.build(!build);
        return this;
      }
    };
  }

  p.protocol = generateSimpleAccessor('protocol');
  p.username = generateSimpleAccessor('username');
  p.password = generateSimpleAccessor('password');
  p.hostname = generateSimpleAccessor('hostname');
  p.port = generateSimpleAccessor('port');
  p.query = generatePrefixAccessor('query', '?');
  p.fragment = generatePrefixAccessor('fragment', '#');

  p.search = function (v, build) {
    var t = this.query(v, build);
    return typeof t === 'string' && t.length ? '?' + t : t;
  };
  p.hash = function (v, build) {
    var t = this.fragment(v, build);
    return typeof t === 'string' && t.length ? '#' + t : t;
  };

  p.pathname = function (v, build) {
    if (v === undefined || v === true) {
      var res = this._parts.path || (this._parts.hostname ? '/' : '');
      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
    } else {
      if (this._parts.urn) {
        this._parts.path = v ? URI.recodeUrnPath(v) : '';
      } else {
        this._parts.path = v ? URI.recodePath(v) : '/';
      }
      this.build(!build);
      return this;
    }
  };
  p.path = p.pathname;
  p.href = function (href, build) {
    var key;

    if (href === undefined) {
      return this.toString();
    }

    this._string = '';
    this._parts = URI._parts();

    var _URI = href instanceof URI;
    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
    if (href.nodeName) {
      var attribute = URI.getDomAttribute(href);
      href = href[attribute] || '';
      _object = false;
    }

    // window.location is reported to be an object, but it's not the sort
    // of object we're looking for:
    // * location.protocol ends with a colon
    // * location.query != object.search
    // * location.hash != object.fragment
    // simply serializing the unknown object should do the trick
    // (for location, not for everything...)
    if (!_URI && _object && href.pathname !== undefined) {
      href = href.toString();
    }

    if (typeof href === 'string' || href instanceof String) {
      this._parts = URI.parse(String(href), this._parts);
    } else if (_URI || _object) {
      var src = _URI ? href._parts : href;
      for (key in src) {
        if (hasOwn.call(this._parts, key)) {
          this._parts[key] = src[key];
        }
      }
    } else {
      throw new TypeError('invalid input');
    }

    this.build(!build);
    return this;
  };

  // identification accessors
  p.is = function (what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;

    if (this._parts.hostname) {
      relative = false;
      ip4 = URI.ip4_expression.test(this._parts.hostname);
      ip6 = URI.ip6_expression.test(this._parts.hostname);
      ip = ip4 || ip6;
      name = !ip;
      sld = name && SLD && SLD.has(this._parts.hostname);
      idn = name && URI.idn_expression.test(this._parts.hostname);
      punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }

    switch (what.toLowerCase()) {
      case 'relative':
        return relative;

      case 'absolute':
        return !relative;

      // hostname identification
      case 'domain':
      case 'name':
        return name;

      case 'sld':
        return sld;

      case 'ip':
        return ip;

      case 'ip4':
      case 'ipv4':
      case 'inet4':
        return ip4;

      case 'ip6':
      case 'ipv6':
      case 'inet6':
        return ip6;

      case 'idn':
        return idn;

      case 'url':
        return !this._parts.urn;

      case 'urn':
        return !!this._parts.urn;

      case 'punycode':
        return punycode;
    }

    return null;
  };

  // component specific input validation
  var _protocol = p.protocol;
  var _port = p.port;
  var _hostname = p.hostname;

  p.protocol = function (v, build) {
    if (v !== undefined) {
      if (v) {
        // accept trailing ://
        v = v.replace(/:(\/\/)?$/, '');

        if (!v.match(URI.protocol_expression)) {
          throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
        }
      }
    }
    return _protocol.call(this, v, build);
  };
  p.scheme = p.protocol;
  p.port = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      if (v === 0) {
        v = null;
      }

      if (v) {
        v += '';
        if (v.charAt(0) === ':') {
          v = v.substring(1);
        }

        if (v.match(/[^0-9]/)) {
          throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
        }
      }
    }
    return _port.call(this, v, build);
  };
  p.hostname = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      var x = {};
      var res = URI.parseHost(v, x);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      v = x.hostname;
    }
    return _hostname.call(this, v, build);
  };

  // compound accessors
  p.origin = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var protocol = this.protocol();
      var authority = this.authority();
      if (!authority) {
        return '';
      }

      return (protocol ? protocol + '://' : '') + this.authority();
    } else {
      var origin = URI(v);
      this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
      return this;
    }
  };
  p.host = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildHost(this._parts) : '';
    } else {
      var res = URI.parseHost(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.authority = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
    } else {
      var res = URI.parseAuthority(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.userinfo = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var t = URI.buildUserinfo(this._parts);
      return t ? t.substring(0, t.length - 1) : t;
    } else {
      if (v[v.length - 1] !== '@') {
        v += '@';
      }

      URI.parseUserinfo(v, this._parts);
      this.build(!build);
      return this;
    }
  };
  p.resource = function (v, build) {
    var parts;

    if (v === undefined) {
      return this.path() + this.search() + this.hash();
    }

    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
  };

  // fraction accessors
  p.subdomain = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    // convenience, return "www" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // grab domain and add another segment
      var end = this._parts.hostname.length - this.domain().length - 1;
      return this._parts.hostname.substring(0, end) || '';
    } else {
      var e = this._parts.hostname.length - this.domain().length;
      var sub = this._parts.hostname.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(sub));

      if (v && v.charAt(v.length - 1) !== '.') {
        v += '.';
      }

      if (v) {
        URI.ensureValidHostname(v);
      }

      this._parts.hostname = this._parts.hostname.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.domain = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // convenience, return "example.org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // if hostname consists of 1 or 2 segments, it must be the domain
      var t = this._parts.hostname.match(/\./g);
      if (t && t.length < 2) {
        return this._parts.hostname;
      }

      // grab tld and add another segment
      var end = this._parts.hostname.length - this.tld(build).length - 1;
      end = this._parts.hostname.lastIndexOf('.', end - 1) + 1;
      return this._parts.hostname.substring(end) || '';
    } else {
      if (!v) {
        throw new TypeError('cannot set domain empty');
      }

      URI.ensureValidHostname(v);

      if (!this._parts.hostname || this.is('IP')) {
        this._parts.hostname = v;
      } else {
        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.tld = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // return "org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      var pos = this._parts.hostname.lastIndexOf('.');
      var tld = this._parts.hostname.substring(pos + 1);

      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
        return SLD.get(this._parts.hostname) || tld;
      }

      return tld;
    } else {
      var replace;

      if (!v) {
        throw new TypeError('cannot set TLD empty');
      } else if (v.match(/[^a-zA-Z0-9-]/)) {
        if (SLD && SLD.is(v)) {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
        }
      } else if (!this._parts.hostname || this.is('IP')) {
        throw new ReferenceError('cannot set TLD on non-domain host');
      } else {
        replace = new RegExp(escapeRegEx(this.tld()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.directory = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path && !this._parts.hostname) {
        return '';
      }

      if (this._parts.path === '/') {
        return '/';
      }

      var end = this._parts.path.length - this.filename().length - 1;
      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

      return v ? URI.decodePath(res) : res;
    } else {
      var e = this._parts.path.length - this.filename().length;
      var directory = this._parts.path.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(directory));

      // fully qualifier directories begin with a slash
      if (!this.is('relative')) {
        if (!v) {
          v = '/';
        }

        if (v.charAt(0) !== '/') {
          v = '/' + v;
        }
      }

      // directories always end with a slash
      if (v && v.charAt(v.length - 1) !== '/') {
        v += '/';
      }

      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.filename = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var pos = this._parts.path.lastIndexOf('/');
      var res = this._parts.path.substring(pos + 1);

      return v ? URI.decodePathSegment(res) : res;
    } else {
      var mutatedDirectory = false;

      if (v.charAt(0) === '/') {
        v = v.substring(1);
      }

      if (v.match(/\.?\//)) {
        mutatedDirectory = true;
      }

      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);

      if (mutatedDirectory) {
        this.normalizePath(build);
      } else {
        this.build(!build);
      }

      return this;
    }
  };
  p.suffix = function (v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var filename = this.filename();
      var pos = filename.lastIndexOf('.');
      var s, res;

      if (pos === -1) {
        return '';
      }

      // suffix may only contain alnum characters (yup, I made this up.)
      s = filename.substring(pos + 1);
      res = /^[a-z0-9%]+$/i.test(s) ? s : '';
      return v ? URI.decodePathSegment(res) : res;
    } else {
      if (v.charAt(0) === '.') {
        v = v.substring(1);
      }

      var suffix = this.suffix();
      var replace;

      if (!suffix) {
        if (!v) {
          return this;
        }

        this._parts.path += '.' + URI.recodePath(v);
      } else if (!v) {
        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
      } else {
        replace = new RegExp(escapeRegEx(suffix) + '$');
      }

      if (replace) {
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.segment = function (segment, v, build) {
    var separator = this._parts.urn ? ':' : '/';
    var path = this.path();
    var absolute = path.substring(0, 1) === '/';
    var segments = path.split(separator);

    if (segment !== undefined && typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (segment !== undefined && typeof segment !== 'number') {
      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
    }

    if (absolute) {
      segments.shift();
    }

    if (segment < 0) {
      // allow negative indexes to address from the end
      segment = Math.max(segments.length + segment, 0);
    }

    if (v === undefined) {
      /*jshint laxbreak: true */
      return segment === undefined ? segments : segments[segment];
      /*jshint laxbreak: false */
    } else if (segment === null || segments[segment] === undefined) {
      if (isArray(v)) {
        segments = [];
        // collapse empty elements within array
        for (var i = 0, l = v.length; i < l; i++) {
          if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
            continue;
          }

          if (segments.length && !segments[segments.length - 1].length) {
            segments.pop();
          }

          segments.push(trimSlashes(v[i]));
        }
      } else if (v || typeof v === 'string') {
        v = trimSlashes(v);
        if (segments[segments.length - 1] === '') {
          // empty trailing elements have to be overwritten
          // to prevent results such as /foo//bar
          segments[segments.length - 1] = v;
        } else {
          segments.push(v);
        }
      }
    } else {
      if (v) {
        segments[segment] = trimSlashes(v);
      } else {
        segments.splice(segment, 1);
      }
    }

    if (absolute) {
      segments.unshift('');
    }

    return this.path(segments.join(separator), build);
  };
  p.segmentCoded = function (segment, v, build) {
    var segments, i, l;

    if (typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (v === undefined) {
      segments = this.segment(segment, v, build);
      if (!isArray(segments)) {
        segments = segments !== undefined ? URI.decode(segments) : undefined;
      } else {
        for (i = 0, l = segments.length; i < l; i++) {
          segments[i] = URI.decode(segments[i]);
        }
      }

      return segments;
    }

    if (!isArray(v)) {
      v = typeof v === 'string' || v instanceof String ? URI.encode(v) : v;
    } else {
      for (i = 0, l = v.length; i < l; i++) {
        v[i] = URI.encode(v[i]);
      }
    }

    return this.segment(segment, v, build);
  };

  // mutating query string
  var q = p.query;
  p.query = function (v, build) {
    if (v === true) {
      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    } else if (typeof v === 'function') {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      var result = v.call(this, data);
      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else if (v !== undefined && typeof v !== 'string') {
      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else {
      return q.call(this, v, build);
    }
  };
  p.setQuery = function (name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

    if (typeof name === 'string' || name instanceof String) {
      data[name] = value !== undefined ? value : null;
    } else if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          data[key] = name[key];
        }
      }
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }

    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.addQuery = function (name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.removeQuery = function (name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.hasQuery = function (name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    return URI.hasQuery(data, name, value, withinArray);
  };
  p.setSearch = p.setQuery;
  p.addSearch = p.addQuery;
  p.removeSearch = p.removeQuery;
  p.hasSearch = p.hasQuery;

  // sanitizing URLs
  p.normalize = function () {
    if (this._parts.urn) {
      return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
    }

    return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
  };
  p.normalizeProtocol = function (build) {
    if (typeof this._parts.protocol === 'string') {
      this._parts.protocol = this._parts.protocol.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizeHostname = function (build) {
    if (this._parts.hostname) {
      if (this.is('IDN') && punycode) {
        this._parts.hostname = punycode.toASCII(this._parts.hostname);
      } else if (this.is('IPv6') && IPv6) {
        this._parts.hostname = IPv6.best(this._parts.hostname);
      }

      this._parts.hostname = this._parts.hostname.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizePort = function (build) {
    // remove port of it's the protocol's default
    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
      this._parts.port = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizePath = function (build) {
    var _path = this._parts.path;
    if (!_path) {
      return this;
    }

    if (this._parts.urn) {
      this._parts.path = URI.recodeUrnPath(this._parts.path);
      this.build(!build);
      return this;
    }

    if (this._parts.path === '/') {
      return this;
    }

    _path = URI.recodePath(_path);

    var _was_relative;
    var _leadingParents = '';
    var _parent, _pos;

    // handle relative paths
    if (_path.charAt(0) !== '/') {
      _was_relative = true;
      _path = '/' + _path;
    }

    // handle relative files (as opposed to directories)
    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
      _path += '/';
    }

    // resolve simples
    _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, '/').replace(/\/{2,}/g, '/');

    // remember leading parents
    if (_was_relative) {
      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
      if (_leadingParents) {
        _leadingParents = _leadingParents[0];
      }
    }

    // resolve parents
    while (true) {
      _parent = _path.search(/\/\.\.(\/|$)/);
      if (_parent === -1) {
        // no more ../ to resolve
        break;
      } else if (_parent === 0) {
        // top level cannot be relative, skip it
        _path = _path.substring(3);
        continue;
      }

      _pos = _path.substring(0, _parent).lastIndexOf('/');
      if (_pos === -1) {
        _pos = _parent;
      }
      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }

    // revert to relative
    if (_was_relative && this.is('relative')) {
      _path = _leadingParents + _path.substring(1);
    }

    this._parts.path = _path;
    this.build(!build);
    return this;
  };
  p.normalizePathname = p.normalizePath;
  p.normalizeQuery = function (build) {
    if (typeof this._parts.query === 'string') {
      if (!this._parts.query.length) {
        this._parts.query = null;
      } else {
        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
      }

      this.build(!build);
    }

    return this;
  };
  p.normalizeFragment = function (build) {
    if (!this._parts.fragment) {
      this._parts.fragment = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizeSearch = p.normalizeQuery;
  p.normalizeHash = p.normalizeFragment;

  p.iso8859 = function () {
    // expect unicode input, iso8859 output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = escape;
    URI.decode = decodeURIComponent;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.unicode = function () {
    // expect iso8859 input, unicode output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.readable = function () {
    var uri = this.clone();
    // removing username, password, because they shouldn't be displayed according to RFC 3986
    uri.username('').password('').normalize();
    var t = '';
    if (uri._parts.protocol) {
      t += uri._parts.protocol + '://';
    }

    if (uri._parts.hostname) {
      if (uri.is('punycode') && punycode) {
        t += punycode.toUnicode(uri._parts.hostname);
        if (uri._parts.port) {
          t += ':' + uri._parts.port;
        }
      } else {
        t += uri.host();
      }
    }

    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
      t += '/';
    }

    t += uri.path(true);
    if (uri._parts.query) {
      var q = '';
      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
        var kv = (qp[i] || '').split('=');
        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, '%26');

        if (kv[1] !== undefined) {
          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, '%26');
        }
      }
      t += '?' + q.substring(1);
    }

    t += URI.decodeQuery(uri.hash(), true);
    return t;
  };

  // resolving relative and absolute URLs
  p.absoluteTo = function (base) {
    var resolved = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var basedir, i, p;

    if (this._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    if (!(base instanceof URI)) {
      base = new URI(base);
    }

    if (!resolved._parts.protocol) {
      resolved._parts.protocol = base._parts.protocol;
    }

    if (this._parts.hostname) {
      return resolved;
    }

    for (i = 0; p = properties[i]; i++) {
      resolved._parts[p] = base._parts[p];
    }

    if (!resolved._parts.path) {
      resolved._parts.path = base._parts.path;
      if (!resolved._parts.query) {
        resolved._parts.query = base._parts.query;
      }
    } else if (resolved._parts.path.substring(-2) === '..') {
      resolved._parts.path += '/';
    }

    if (resolved.path().charAt(0) !== '/') {
      basedir = base.directory();
      basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
      resolved._parts.path = (basedir ? basedir + '/' : '') + resolved._parts.path;
      resolved.normalizePath();
    }

    resolved.build();
    return resolved;
  };
  p.relativeTo = function (base) {
    var relative = this.clone().normalize();
    var relativeParts, baseParts, common, relativePath, basePath;

    if (relative._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    base = new URI(base).normalize();
    relativeParts = relative._parts;
    baseParts = base._parts;
    relativePath = relative.path();
    basePath = base.path();

    if (relativePath.charAt(0) !== '/') {
      throw new Error('URI is already relative');
    }

    if (basePath.charAt(0) !== '/') {
      throw new Error('Cannot calculate a URI relative to another relative URI');
    }

    if (relativeParts.protocol === baseParts.protocol) {
      relativeParts.protocol = null;
    }

    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
      return relative.build();
    }

    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
      return relative.build();
    }

    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
      relativeParts.hostname = null;
      relativeParts.port = null;
    } else {
      return relative.build();
    }

    if (relativePath === basePath) {
      relativeParts.path = '';
      return relative.build();
    }

    // determine common sub path
    common = URI.commonPath(relativePath, basePath);

    // If the paths have nothing in common, return a relative URL with the absolute path.
    if (!common) {
      return relative.build();
    }

    var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, '').replace(/.*?\//g, '../');

    relativeParts.path = parents + relativeParts.path.substring(common.length) || './';

    return relative.build();
  };

  // comparing URIs
  p.equals = function (uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;

    one.normalize();
    two.normalize();

    // exact match
    if (one.toString() === two.toString()) {
      return true;
    }

    // extract query string
    one_query = one.query();
    two_query = two.query();
    one.query('');
    two.query('');

    // definitely not equal if not even non-query parts match
    if (one.toString() !== two.toString()) {
      return false;
    }

    // query parameters have the same length, even if they're permuted
    if (one_query.length !== two_query.length) {
      return false;
    }

    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

    for (key in one_map) {
      if (hasOwn.call(one_map, key)) {
        if (!isArray(one_map[key])) {
          if (one_map[key] !== two_map[key]) {
            return false;
          }
        } else if (!arraysEqual(one_map[key], two_map[key])) {
          return false;
        }

        checked[key] = true;
      }
    }

    for (key in two_map) {
      if (hasOwn.call(two_map, key)) {
        if (!checked[key]) {
          // two contains a parameter not present in one
          return false;
        }
      }
    }

    return true;
  };

  // state
  p.duplicateQueryParameters = function (v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
  };

  p.escapeQuerySpace = function (v) {
    this._parts.escapeQuerySpace = !!v;
    return this;
  };

  return URI;
});
$__System.registerDynamic("11", [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // THIS FILE IS GENERATED - DO NOT EDIT!
    /*global module:false, define:false*/

    (function (define, undefined) {
        define(function () {
            'use strict';

            var impl = {};

            impl.mobileDetectRules = {
                "phones": {
                    "iPhone": "\\biPhone\\b|\\biPod\\b",
                    "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+",
                    "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m",
                    "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
                    "Dell": "Dell.*Streak|Dell.*Aero|Dell.*Venue|DELL.*Venue Pro|Dell Flash|Dell Smoke|Dell Mini 3iX|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
                    "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b",
                    "Samsung": "Samsung|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350",
                    "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323)",
                    "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
                    "Asus": "Asus.*Galaxy|PadFone.*Mobile",
                    "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
                    "Palm": "PalmSource|Palm",
                    "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
                    "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
                    "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
                    "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
                    "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
                    "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
                    "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
                    "Alcatel": "Alcatel",
                    "Nintendo": "Nintendo 3DS",
                    "Amoi": "Amoi",
                    "INQ": "INQ",
                    "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
                },
                "tablets": {
                    "iPad": "iPad|iPad.*Mobile",
                    "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
                    "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561",
                    "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI)\\b",
                    "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
                    "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
                    "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K017 |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C",
                    "BlackBerryTablet": "PlayBook|RIM Tablet",
                    "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
                    "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
                    "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
                    "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b",
                    "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
                    "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
                    "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
                    "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
                    "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)",
                    "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
                    "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
                    "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
                    "ArnovaTablet": "AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
                    "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
                    "IRUTablet": "M702pro",
                    "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
                    "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
                    "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
                    "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
                    "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
                    "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP612|SOT31",
                    "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
                    "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
                    "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
                    "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
                    "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
                    "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
                    "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
                    "FlyTablet": "IQ310|Fly Vision",
                    "bqTablet": "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris E10)|Maxwell.*Lite|Maxwell.*Plus",
                    "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim",
                    "NecTablet": "\\bN-06D|\\bN-08D",
                    "PantechTablet": "Pantech.*P4100",
                    "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
                    "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
                    "ZyncTablet": "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",
                    "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
                    "NabiTablet": "Android.*\\bNabi",
                    "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
                    "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
                    "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
                    "PlaystationTablet": "Playstation.*(Portable|Vita)",
                    "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
                    "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
                    "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
                    "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
                    "GalapadTablet": "Android.*\\bG1\\b",
                    "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
                    "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
                    "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
                    "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
                    "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
                    "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
                    "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
                    "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
                    "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)",
                    "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
                    "DPSTablet": "DPS Dream 9|DPS Dual 7",
                    "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
                    "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
                    "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
                    "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
                    "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
                    "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
                    "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
                    "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
                    "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
                    "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7",
                    "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
                    "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
                    "iMobileTablet": "i-mobile i-note",
                    "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
                    "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
                    "AMPETablet": "Android.* A78 ",
                    "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
                    "TecnoTablet": "TECNO P9",
                    "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
                    "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
                    "FX2Tablet": "FX2 PAD7|FX2 PAD10",
                    "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
                    "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
                    "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
                    "CaptivaTablet": "CAPTIVA PAD",
                    "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
                    "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
                    "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+",
                    "JaytechTablet": "TPC-PA762",
                    "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
                    "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
                    "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
                    "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
                    "AocTablet": "MW0811|MW0812|MW0922|MTK8382",
                    "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
                    "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
                    "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
                    "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
                    "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
                    "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
                    "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
                    "UbislateTablet": "UbiSlate[\\s]?7C",
                    "PocketBookTablet": "Pocketbook",
                    "Hudl": "Hudl HT7S3|Hudl 2",
                    "TelstraTablet": "T-Hub2",
                    "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bJolla\\b|\\bTP750\\b"
                },
                "oss": {
                    "AndroidOS": "Android",
                    "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
                    "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
                    "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
                    "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",
                    "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
                    "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad",
                    "MeeGoOS": "MeeGo",
                    "MaemoOS": "Maemo",
                    "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
                    "webOS": "webOS|hpwOS",
                    "badaOS": "\\bBada\\b",
                    "BREWOS": "BREW"
                },
                "uas": {
                    "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
                    "Dolfin": "\\bDolfin\\b",
                    "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+|Coast\/[0-9.]+",
                    "Skyfire": "Skyfire",
                    "IE": "IEMobile|MSIEMobile",
                    "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile",
                    "Bolt": "bolt",
                    "TeaShark": "teashark",
                    "Blazer": "Blazer",
                    "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
                    "Tizen": "Tizen",
                    "UCBrowser": "UC.*Browser|UCWEB",
                    "baiduboxapp": "baiduboxapp",
                    "baidubrowser": "baidubrowser",
                    "DiigoBrowser": "DiigoBrowser",
                    "Puffin": "Puffin",
                    "Mercury": "\\bMercury\\b",
                    "ObigoBrowser": "Obigo",
                    "NetFront": "NF-Browser",
                    "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger"
                },
                "props": {
                    "Mobile": "Mobile\/[VER]",
                    "Build": "Build\/[VER]",
                    "Version": "Version\/[VER]",
                    "VendorID": "VendorID\/[VER]",
                    "iPad": "iPad.*CPU[a-z ]+[VER]",
                    "iPhone": "iPhone.*CPU[a-z ]+[VER]",
                    "iPod": "iPod.*CPU[a-z ]+[VER]",
                    "Kindle": "Kindle\/[VER]",
                    "Chrome": ["Chrome\/[VER]", "CriOS\/[VER]", "CrMo\/[VER]"],
                    "Coast": ["Coast\/[VER]"],
                    "Dolfin": "Dolfin\/[VER]",
                    "Firefox": "Firefox\/[VER]",
                    "Fennec": "Fennec\/[VER]",
                    "IE": ["IEMobile\/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident\/[0-9.]+;.*rv:[VER]"],
                    "NetFront": "NetFront\/[VER]",
                    "NokiaBrowser": "NokiaBrowser\/[VER]",
                    "Opera": [" OPR\/[VER]", "Opera Mini\/[VER]", "Version\/[VER]"],
                    "Opera Mini": "Opera Mini\/[VER]",
                    "Opera Mobi": "Version\/[VER]",
                    "UC Browser": "UC Browser[VER]",
                    "MQQBrowser": "MQQBrowser\/[VER]",
                    "MicroMessenger": "MicroMessenger\/[VER]",
                    "baiduboxapp": "baiduboxapp\/[VER]",
                    "baidubrowser": "baidubrowser\/[VER]",
                    "Iron": "Iron\/[VER]",
                    "Safari": ["Version\/[VER]", "Safari\/[VER]"],
                    "Skyfire": "Skyfire\/[VER]",
                    "Tizen": "Tizen\/[VER]",
                    "Webkit": "webkit[ \/][VER]",
                    "Gecko": "Gecko\/[VER]",
                    "Trident": "Trident\/[VER]",
                    "Presto": "Presto\/[VER]",
                    "iOS": " \\bi?OS\\b [VER][ ;]{1}",
                    "Android": "Android [VER]",
                    "BlackBerry": ["BlackBerry[\\w]+\/[VER]", "BlackBerry.*Version\/[VER]", "Version\/[VER]"],
                    "BREW": "BREW [VER]",
                    "Java": "Java\/[VER]",
                    "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"],
                    "Windows Phone": "Windows Phone [VER]",
                    "Windows CE": "Windows CE\/[VER]",
                    "Windows NT": "Windows NT [VER]",
                    "Symbian": ["SymbianOS\/[VER]", "Symbian\/[VER]"],
                    "webOS": ["webOS\/[VER]", "hpwOS\/[VER];"]
                },
                "utils": {
                    "Bot": "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",
                    "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
                    "DesktopMode": "WPDesktop",
                    "TV": "SonyDTV|HbbTV",
                    "WebKit": "(webkit)[ \/]([\\w.]+)",
                    "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|PLAYSTATION|Xbox)\\b",
                    "Watch": "SM-V700"
                }
            };

            // following patterns come from http://detectmobilebrowsers.com/
            impl.detectMobileBrowsers = {
                fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
                shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
                tabletPattern: /android|ipad|playbook|silk/i
            };

            var hasOwnProp = Object.prototype.hasOwnProperty,
                isArray;

            impl.FALLBACK_PHONE = 'UnknownPhone';
            impl.FALLBACK_TABLET = 'UnknownTablet';
            impl.FALLBACK_MOBILE = 'UnknownMobile';

            isArray = 'isArray' in Array ? Array.isArray : function (value) {
                return Object.prototype.toString.call(value) === '[object Array]';
            };

            function equalIC(a, b) {
                return a != null && b != null && a.toLowerCase() === b.toLowerCase();
            }

            function containsIC(array, value) {
                var valueLC,
                    i,
                    len = array.length;
                if (!len || !value) {
                    return false;
                }
                valueLC = value.toLowerCase();
                for (i = 0; i < len; ++i) {
                    if (valueLC === array[i].toLowerCase()) {
                        return true;
                    }
                }
                return false;
            }

            function convertPropsToRegExp(object) {
                for (var key in object) {
                    if (hasOwnProp.call(object, key)) {
                        object[key] = new RegExp(object[key], 'i');
                    }
                }
            }

            (function init() {
                var key,
                    values,
                    value,
                    i,
                    len,
                    verPos,
                    mobileDetectRules = impl.mobileDetectRules;
                for (key in mobileDetectRules.props) {
                    if (hasOwnProp.call(mobileDetectRules.props, key)) {
                        values = mobileDetectRules.props[key];
                        if (!isArray(values)) {
                            values = [values];
                        }
                        len = values.length;
                        for (i = 0; i < len; ++i) {
                            value = values[i];
                            verPos = value.indexOf('[VER]');
                            if (verPos >= 0) {
                                value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
                            }
                            values[i] = new RegExp(value, 'i');
                        }
                        mobileDetectRules.props[key] = values;
                    }
                }
                convertPropsToRegExp(mobileDetectRules.oss);
                convertPropsToRegExp(mobileDetectRules.phones);
                convertPropsToRegExp(mobileDetectRules.tablets);
                convertPropsToRegExp(mobileDetectRules.uas);
                convertPropsToRegExp(mobileDetectRules.utils);

                // copy some patterns to oss0 which are tested first (see issue#15)
                mobileDetectRules.oss0 = {
                    WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
                    WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
                };
            })();

            /**
             * Test userAgent string against a set of rules and find the first matched key.
             * @param {Object} rules (key is String, value is RegExp)
             * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
             * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
             * @private
             */
            impl.findMatch = function (rules, userAgent) {
                for (var key in rules) {
                    if (hasOwnProp.call(rules, key)) {
                        if (rules[key].test(userAgent)) {
                            return key;
                        }
                    }
                }
                return null;
            };

            /**
             * Test userAgent string against a set of rules and return an array of matched keys.
             * @param {Object} rules (key is String, value is RegExp)
             * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
             * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
             * @private
             */
            impl.findMatches = function (rules, userAgent) {
                var result = [];
                for (var key in rules) {
                    if (hasOwnProp.call(rules, key)) {
                        if (rules[key].test(userAgent)) {
                            result.push(key);
                        }
                    }
                }
                return result;
            };

            /**
             * Check the version of the given property in the User-Agent.
             *
             * @param {String} propertyName
             * @param {String} userAgent
             * @return {String} version or <tt>null</tt> if version not found
             * @private
             */
            impl.getVersionStr = function (propertyName, userAgent) {
                var props = impl.mobileDetectRules.props,
                    patterns,
                    i,
                    len,
                    match;
                if (hasOwnProp.call(props, propertyName)) {
                    patterns = props[propertyName];
                    len = patterns.length;
                    for (i = 0; i < len; ++i) {
                        match = patterns[i].exec(userAgent);
                        if (match !== null) {
                            return match[1];
                        }
                    }
                }
                return null;
            };

            /**
             * Check the version of the given property in the User-Agent.
             * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
             *
             * @param {String} propertyName
             * @param {String} userAgent
             * @return {Number} version or <tt>NaN</tt> if version not found
             * @private
             */
            impl.getVersion = function (propertyName, userAgent) {
                var version = impl.getVersionStr(propertyName, userAgent);
                return version ? impl.prepareVersionNo(version) : NaN;
            };

            /**
             * Prepare the version number.
             *
             * @param {String} version
             * @return {Number} the version number as a floating number
             * @private
             */
            impl.prepareVersionNo = function (version) {
                var numbers;

                numbers = version.split(/[a-z._ \/\-]/i);
                if (numbers.length === 1) {
                    version = numbers[0];
                }
                if (numbers.length > 1) {
                    version = numbers[0] + '.';
                    numbers.shift();
                    version += numbers.join('');
                }
                return Number(version);
            };

            impl.isMobileFallback = function (userAgent) {
                return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
            };

            impl.isTabletFallback = function (userAgent) {
                return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
            };

            impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
                if (cache.mobile !== undefined) {
                    return;
                }
                var phone, tablet, phoneSized;

                // first check for stronger tablet rules, then phone (see issue#5)
                tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
                if (tablet) {
                    cache.mobile = cache.tablet = tablet;
                    cache.phone = null;
                    return; // unambiguously identified as tablet
                }

                phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
                if (phone) {
                    cache.mobile = cache.phone = phone;
                    cache.tablet = null;
                    return; // unambiguously identified as phone
                }

                // our rules haven't found a match -> try more general fallback rules
                if (impl.isMobileFallback(userAgent)) {
                    phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
                    if (phoneSized === undefined) {
                        cache.mobile = impl.FALLBACK_MOBILE;
                        cache.tablet = cache.phone = null;
                    } else if (phoneSized) {
                        cache.mobile = cache.phone = impl.FALLBACK_PHONE;
                        cache.tablet = null;
                    } else {
                        cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                        cache.phone = null;
                    }
                } else if (impl.isTabletFallback(userAgent)) {
                    cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                    cache.phone = null;
                } else {
                    // not mobile at all!
                    cache.mobile = cache.tablet = cache.phone = null;
                }
            };

            // t is a reference to a MobileDetect instance
            impl.mobileGrade = function (t) {
                // impl note:
                // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
                // When changes are made in Mobile_Detect.php, copy this method and replace:
                //     $this-> / t.
                //     self::MOBILE_GRADE_(.) / '$1'
                //     , self::VERSION_TYPE_FLOAT / (nothing)
                //     isIOS() / os('iOS')
                //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
                var $isMobile = t.mobile() !== null;

                if (
                // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
                t.os('iOS') && t.version('iPad') >= 4.3 || t.os('iOS') && t.version('iPhone') >= 3.1 || t.os('iOS') && t.version('iPod') >= 3.1 ||

                // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
                // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
                // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
                // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
                t.version('Android') > 2.1 && t.is('Webkit') ||

                // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
                t.version('Windows Phone OS') >= 7.0 ||

                // Blackberry 7 - Tested on BlackBerry Torch 9810
                // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
                t.is('BlackBerry') && t.version('BlackBerry') >= 6.0 ||
                // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
                t.match('Playbook.*Tablet') ||

                // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
                t.version('webOS') >= 1.4 && t.match('Palm|Pre|Pixi') ||
                // Palm WebOS 3.0  - Tested on HP TouchPad
                t.match('hp.*TouchPad') ||

                // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
                t.is('Firefox') && t.version('Firefox') >= 12 ||

                // Chrome for Android - Tested on Android 4.0, 4.1 device
                t.is('Chrome') && t.is('AndroidOS') && t.version('Android') >= 4.0 ||

                // Skyfire 4.1 - Tested on Android 2.3 device
                t.is('Skyfire') && t.version('Skyfire') >= 4.1 && t.is('AndroidOS') && t.version('Android') >= 2.3 ||

                // Opera Mobile 11.5-12: Tested on Android 2.3
                t.is('Opera') && t.version('Opera Mobi') > 11 && t.is('AndroidOS') ||

                // Meego 1.2 - Tested on Nokia 950 and N9
                t.is('MeeGoOS') ||

                // Tizen (pre-release) - Tested on early hardware
                t.is('Tizen') ||

                // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
                // @todo: more tests here!
                t.is('Dolfin') && t.version('Bada') >= 2.0 ||

                // UC Browser - Tested on Android 2.3 device
                (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android') >= 2.3 ||

                // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
                t.match('Kindle Fire') || t.is('Kindle') && t.version('Kindle') >= 3.0 ||

                // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
                t.is('AndroidOS') && t.is('NookTablet') ||

                // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
                t.version('Chrome') >= 11 && !$isMobile ||

                // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
                t.version('Safari') >= 5.0 && !$isMobile ||

                // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
                t.version('Firefox') >= 4.0 && !$isMobile ||

                // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
                t.version('MSIE') >= 7.0 && !$isMobile ||

                // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
                // @reference: http://my.opera.com/community/openweb/idopera/
                t.version('Opera') >= 10 && !$isMobile) {
                    return 'A';
                }

                if (t.os('iOS') && t.version('iPad') < 4.3 || t.os('iOS') && t.version('iPhone') < 3.1 || t.os('iOS') && t.version('iPod') < 3.1 ||

                // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
                t.is('Blackberry') && t.version('BlackBerry') >= 5 && t.version('BlackBerry') < 6 ||

                //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
                t.version('Opera Mini') >= 5.0 && t.version('Opera Mini') <= 6.5 && (t.version('Android') >= 2.3 || t.is('iOS')) ||

                // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
                t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||

                // @todo: report this (tested on Nokia N71)
                t.version('Opera Mobi') >= 11 && t.is('SymbianOS')) {
                    return 'B';
                }

                if (
                // Blackberry 4.x - Tested on the Curve 8330
                t.version('BlackBerry') < 5.0 ||
                // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
                t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile') <= 5.2) {
                    return 'C';
                }

                //All older smartphone platforms and featurephones - Any device that doesn't support media queries
                //will receive the basic, C grade experience.
                return 'C';
            };

            impl.detectOS = function (ua) {
                return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
            };

            impl.getDeviceSmallerSide = function () {
                return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
            };

            /**
             * Constructor for MobileDetect object.
             * <br>
             * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
             * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
             *     <strong>Find information how to download and install:</strong>
             *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
             * </div>
             *
             * @example <pre>
             *     var md = new MobileDetect(window.navigator.userAgent);
             *     if (md.mobile()) {
             *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
             *     }
             * </pre>
             *
             * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
             * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
             *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
             *        as phone.
             *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
             *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
             *        for Android</a>.<br>
             *        If you provide a value < 0, then this "fuzzy" check is disabled.
             * @constructor
             * @global
             */
            function MobileDetect(userAgent, maxPhoneWidth) {
                this.ua = userAgent || '';
                this._cache = {};
                //600dp is typical 7" tablet minimum width
                this.maxPhoneWidth = maxPhoneWidth || 600;
            }

            MobileDetect.prototype = {
                constructor: MobileDetect,

                /**
                 * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
                 * <br>
                 * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
                 * <br>
                 * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
                 * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
                 * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
                 * <code>UnknownMobile</code> is returned.<br>
                 * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
                 * <br>
                 * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
                 * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
                 * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
                 * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
                 * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
                 * <br>
                 * In most cases you will use the return value just as a boolean.
                 *
                 * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
                 * @function MobileDetect#mobile
                 */
                mobile: function () {
                    impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                    return this._cache.mobile;
                },

                /**
                 * Returns the detected phone type/family string or <tt>null</tt>.
                 * <br>
                 * The returned tablet (family or producer) is one of following keys:<br>
                 * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
                 * Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley, Wolfgang,
                 * Alcatel, Nintendo, Amoi, INQ, GenericPhone</tt><br>
                 * <br>
                 * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
                 * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
                 * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
                 * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
                 * <br>
                 * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
                 * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
                 * will return <code>UnknownMobile</code>.<br>
                 * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
                 * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
                 * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
                 * <br>
                 * In most cases you will use the return value just as a boolean.
                 *
                 * @returns {String} the key of the phone family or producer, e.g. "iPhone"
                 * @function MobileDetect#phone
                 */
                phone: function () {
                    impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                    return this._cache.phone;
                },

                /**
                 * Returns the detected tablet type/family string or <tt>null</tt>.
                 * <br>
                 * The returned tablet (family or producer) is one of following keys:<br>
                 * <br><tt>iPad, NexusTablet, SamsungTablet, Kindle, SurfaceTablet, HPTablet, AsusTablet,
                 * BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet, AcerTablet,
                 * ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet, LenovoTablet,
                 * DellTablet, YarvikTablet, MedionTablet, ArnovaTablet, IntensoTablet, IRUTablet,
                 * MegafonTablet, EbodaTablet, AllViewTablet, ArchosTablet, AinolTablet,
                 * SonyTablet, PhilipsTablet, CubeTablet, CobyTablet, MIDTablet, MSITablet,
                 * SMiTTablet, RockChipTablet, FlyTablet, bqTablet, HuaweiTablet, NecTablet,
                 * PantechTablet, BronchoTablet, VersusTablet, ZyncTablet, PositivoTablet,
                 * NabiTablet, KoboTablet, DanewTablet, TexetTablet, PlaystationTablet,
                 * TrekstorTablet, PyleAudioTablet, AdvanTablet, DanyTechTablet, GalapadTablet,
                 * MicromaxTablet, KarbonnTablet, AllFineTablet, PROSCANTablet, YONESTablet,
                 * ChangJiaTablet, GUTablet, PointOfViewTablet, OvermaxTablet, HCLTablet,
                 * DPSTablet, VistureTablet, CrestaTablet, MediatekTablet, ConcordeTablet,
                 * GoCleverTablet, ModecomTablet, VoninoTablet, ECSTablet, StorexTablet,
                 * VodafoneTablet, EssentielBTablet, RossMoorTablet, iMobileTablet, TolinoTablet,
                 * AudioSonicTablet, AMPETablet, SkkTablet, TecnoTablet, JXDTablet, iJoyTablet,
                 * FX2Tablet, XoroTablet, ViewsonicTablet, OdysTablet, CaptivaTablet,
                 * IconbitTablet, TeclastTablet, OndaTablet, JaytechTablet, BlaupunktTablet,
                 * DigmaTablet, EvolioTablet, LavaTablet, AocTablet, MpmanTablet, CelkonTablet,
                 * WolderTablet, MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
                 * PocketBookTablet, Hudl, TelstraTablet, GenericTablet</tt><br>
                 * <br>
                 * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
                 * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
                 * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
                 * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
                 * <br>
                 * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
                 * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
                 * will return <code>UnknownMobile</code>.<br>
                 * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
                 * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
                 * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
                 * <br>
                 * In most cases you will use the return value just as a boolean.
                 *
                 * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
                 * @function MobileDetect#tablet
                 */
                tablet: function () {
                    impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                    return this._cache.tablet;
                },

                /**
                 * Returns the (first) detected user-agent string or <tt>null</tt>.
                 * <br>
                 * The returned user-agent is one of following keys:<br>
                 * <br><tt>Chrome, Dolfin, Opera, Skyfire, IE, Firefox, Bolt, TeaShark, Blazer, Safari,
                 * Tizen, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Puffin, Mercury,
                 * ObigoBrowser, NetFront, GenericBrowser</tt><br>
                 * <br>
                 * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
                 * cases where a mobile device pretends to be more than one particular browser. You can get the
                 * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
                 * providing one of the defined keys as first argument to {@link MobileDetect#is}.
                 *
                 * @returns {String} the key for the detected user-agent or <tt>null</tt>
                 * @function MobileDetect#userAgent
                 */
                userAgent: function () {
                    if (this._cache.userAgent === undefined) {
                        this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
                    }
                    return this._cache.userAgent;
                },

                /**
                 * Returns all detected user-agent strings.
                 * <br>
                 * The array is empty or contains one or more of following keys:<br>
                 * <br><tt>Chrome, Dolfin, Opera, Skyfire, IE, Firefox, Bolt, TeaShark, Blazer, Safari,
                 * Tizen, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Puffin, Mercury,
                 * ObigoBrowser, NetFront, GenericBrowser</tt><br>
                 * <br>
                 * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
                 * cases where a mobile device pretends to be more than one particular browser. You can get the
                 * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
                 * providing one of the defined keys as first argument to {@link MobileDetect#is}.
                 *
                 * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
                 * @function MobileDetect#userAgents
                 */
                userAgents: function () {
                    if (this._cache.userAgents === undefined) {
                        this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
                    }
                    return this._cache.userAgents;
                },

                /**
                 * Returns the detected operating system string or <tt>null</tt>.
                 * <br>
                 * The operating system is one of following keys:<br>
                 * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
                 * iOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
                 *
                 * @returns {String} the key for the detected operating system.
                 * @function MobileDetect#os
                 */
                os: function () {
                    if (this._cache.os === undefined) {
                        this._cache.os = impl.detectOS(this.ua);
                    }
                    return this._cache.os;
                },

                /**
                 * Get the version (as Number) of the given property in the User-Agent.
                 * <br>
                 * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
                 *
                 * @param {String} key a key defining a thing which has a version.<br>
                 *        You can use one of following keys:<br>
                 * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
                 * Dolfin, Firefox, Fennec, IE, NetFront, NokiaBrowser, Opera, Opera Mini, Opera
                 * Mobi, UC Browser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser, Iron,
                 * Safari, Skyfire, Tizen, Webkit, Gecko, Trident, Presto, iOS, Android,
                 * BlackBerry, BREW, Java, Windows Phone OS, Windows Phone, Windows CE, Windows
                 * NT, Symbian, webOS</tt><br>
                 *
                 * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
                 *          Be careful when comparing this value with '==' operator!
                 * @function MobileDetect#version
                 */
                version: function (key) {
                    return impl.getVersion(key, this.ua);
                },

                /**
                 * Get the version (as String) of the given property in the User-Agent.
                 * <br>
                 *
                 * @param {String} key a key defining a thing which has a version.<br>
                 *        You can use one of following keys:<br>
                 * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
                 * Dolfin, Firefox, Fennec, IE, NetFront, NokiaBrowser, Opera, Opera Mini, Opera
                 * Mobi, UC Browser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser, Iron,
                 * Safari, Skyfire, Tizen, Webkit, Gecko, Trident, Presto, iOS, Android,
                 * BlackBerry, BREW, Java, Windows Phone OS, Windows Phone, Windows CE, Windows
                 * NT, Symbian, webOS</tt><br>
                 *
                 * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
                 *
                 * @function MobileDetect#versionStr
                 */
                versionStr: function (key) {
                    return impl.getVersionStr(key, this.ua);
                },

                /**
                 * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
                 *
                 * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
                 *        tablet family.<br>
                 *        For a complete list of possible values, see {@link MobileDetect#userAgent},
                 *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
                 *        Additionally you have following keys:<br>
                 * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
                 *
                 * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
                 *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
                 * @function MobileDetect#is
                 */
                is: function (key) {
                    return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
                },

                /**
                 * Do a quick test against navigator::userAgent.
                 *
                 * @param {String|RegExp} pattern the pattern, either as String or RegExp
                 *                        (a string will be converted to a case-insensitive RegExp).
                 * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
                 * @function MobileDetect#match
                 */
                match: function (pattern) {
                    if (!(pattern instanceof RegExp)) {
                        pattern = new RegExp(pattern, 'i');
                    }
                    return pattern.test(this.ua);
                },

                /**
                 * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
                 * <br>
                 * Obviously this method makes sense in browser environments only (not for Node.js)!
                 * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
                 *        The argument is optional and if not present or falsy, the value of the constructor is taken.
                 * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
                 *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
                 *          Will always return <code>undefined</code> server-side.
                 */
                isPhoneSized: function (maxPhoneWidth) {
                    return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
                },

                /**
                 * Returns the mobile grade ('A', 'B', 'C').
                 *
                 * @returns {String} one of the mobile grades ('A', 'B', 'C').
                 * @function MobileDetect#mobileGrade
                 */
                mobileGrade: function () {
                    if (this._cache.grade === undefined) {
                        this._cache.grade = impl.mobileGrade(this);
                    }
                    return this._cache.grade;
                }
            };

            // environment-dependent
            if (typeof window !== 'undefined' && window.screen) {
                MobileDetect.isPhoneSized = function (maxPhoneWidth) {
                    return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
                };
            } else {
                MobileDetect.isPhoneSized = function () {};
            }

            // should not be replaced by a completely new object - just overwrite existing methods
            MobileDetect._impl = impl;

            return MobileDetect;
        }); // end of call of define()
    })(function (undefined) {
        if (typeof module !== 'undefined' && module.exports) {
            return function (factory) {
                module.exports = factory();
            };
        } else if (typeof undefined === 'function' && define.amd) {
            return undefined;
        } else if (typeof window !== 'undefined') {
            return function (factory) {
                window.MobileDetect = factory();
            };
        } else {
            // please file a bug if you get this error!
            throw new Error('unknown environment');
        }
    }());
});
$__System.register('12', ['15', '13', '14', '11'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, cesium_imports_1, context_2, mobile_detect_1;
    var DeviceService;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }, function (context_2_1) {
            context_2 = context_2_1;
        }, function (mobile_detect_1_1) {
            mobile_detect_1 = mobile_detect_1_1;
        }],
        execute: function () {
            /**
            * Provides pose state for the device.
            */
            DeviceService = function () {
                /**
                * Initialize the DeviceService
                */
                function DeviceService(context) {
                    this.locationUpdatesEnabled = true;
                    this.orientationUpdatesEnabled = true;
                    /**
                     * An ENU coordinate frame centered at the gps location reported by this device
                     */
                    this.geolocationEntity = new cesium_imports_1.Entity({ id: 'ar.device.geolocation', name: 'Device Geolocation' });
                    /**
                     * A frame which represents the orientation of this device relative to it's ENU coordinate frame (geolocationEntity)
                     */
                    this.orientationEntity = new cesium_imports_1.Entity({ id: 'ar.device.orientation', name: 'Device Orientation' });
                    /**
                     * A frame which represents the pose of this device
                     */
                    this.entity = new cesium_imports_1.Entity({ id: 'ar.device', name: 'Device' });
                    /**
                     * A frame which describes the pose of the display relative to this device
                     */
                    this.displayEntity = new cesium_imports_1.Entity({
                        id: 'ar.device.display',
                        name: 'Device Display',
                        position: new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, this.entity),
                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY)
                    });
                    this._scratchCartesian = new cesium_imports_1.Cartesian3();
                    this._scratchQuaternion1 = new cesium_imports_1.Quaternion();
                    this._scratchQuaternion2 = new cesium_imports_1.Quaternion();
                    this._x90Rot = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_X, cesium_imports_1.CesiumMath.PI_OVER_TWO);
                    this._headingDrift = 0;
                    context.wellKnownReferenceFrames.add(this.geolocationEntity);
                    context.wellKnownReferenceFrames.add(this.orientationEntity);
                    context.wellKnownReferenceFrames.add(this.entity);
                    context.wellKnownReferenceFrames.add(this.displayEntity);
                    if (typeof navigator !== 'undefined') {
                        this._mobileDetect = new mobile_detect_1.default(navigator.userAgent);
                    }
                }
                DeviceService.prototype.onIdle = function () {
                    if (typeof navigator === 'undefined') return;
                    if (cesium_imports_1.defined(this._geolocationWatchId)) {
                        navigator.geolocation.clearWatch(this._geolocationWatchId);
                        this._geolocationWatchId = undefined;
                    }
                    if (cesium_imports_1.defined(this._deviceorientationListener)) {
                        window.removeEventListener('deviceorientation', this._deviceorientationListener);
                        this._deviceorientationListener = undefined;
                        this._alphaOffset = undefined;
                    }
                };
                DeviceService.prototype.onUpdate = function () {
                    var _this = this;
                    if (typeof navigator !== 'undefined') {
                        var interfaceOrientationProperty = this.displayEntity.orientation;
                        var interfaceOrientation = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_Z, (-window.orientation || 0) * cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE, this._scratchQuaternion1);
                        if (this._mobileDetect && !this._mobileDetect.mobile()) {
                            // for laptops, rotate device orientation by 90° around +X so that it 
                            // corresponds to an upright display rather than the integrated keyboard
                            interfaceOrientation = cesium_imports_1.Quaternion.multiply(this._x90Rot, interfaceOrientation, interfaceOrientation);
                        }
                        interfaceOrientationProperty.setValue(interfaceOrientation);
                        if (!cesium_imports_1.defined(this._geolocationWatchId) && this.locationUpdatesEnabled) {
                            this._geolocationWatchId = navigator.geolocation.watchPosition(function (pos) {
                                if (_this.geolocationEntity.position instanceof cesium_imports_1.SampledPositionProperty === false) {
                                    var sampledPostionProperty = new cesium_imports_1.SampledPositionProperty(cesium_imports_1.ReferenceFrame.FIXED);
                                    sampledPostionProperty.forwardExtrapolationType = cesium_imports_1.ExtrapolationType.HOLD;
                                    sampledPostionProperty.backwardExtrapolationType = cesium_imports_1.ExtrapolationType.HOLD;
                                    sampledPostionProperty.maxNumSamples = 10;
                                    _this.geolocationEntity.position = sampledPostionProperty;
                                }
                                var positionTime = cesium_imports_1.JulianDate.fromDate(new Date(pos.timestamp));
                                var positionECEF = cesium_imports_1.Cartesian3.fromDegrees(pos.coords.longitude, pos.coords.latitude, pos.coords.altitude || 0, undefined, _this._scratchCartesian);
                                _this.geolocationEntity.position.addSample(positionTime, positionECEF);
                                if (_this.geolocationEntity.orientation instanceof cesium_imports_1.ConstantProperty === false) {
                                    _this.geolocationEntity.orientation = new cesium_imports_1.ConstantProperty();
                                }
                                var enuOrientation = cesium_imports_1.Transforms.headingPitchRollQuaternion(positionECEF, 0, 0, 0, undefined, _this._scratchQuaternion1);
                                _this.geolocationEntity.orientation.setValue(enuOrientation);
                            }, function (error) {
                                console.error(error);
                            }, {
                                enableHighAccuracy: true
                            });
                        } else if (cesium_imports_1.defined(this._geolocationWatchId) && !this.locationUpdatesEnabled) {
                            navigator.geolocation.clearWatch(this._geolocationWatchId);
                            this._geolocationWatchId = undefined;
                        }
                        if (!cesium_imports_1.defined(this._deviceorientationListener) && this.orientationUpdatesEnabled) {
                            this._deviceorientationListener = function (e) {
                                var alphaDegrees = e.alpha;
                                if (!cesium_imports_1.defined(alphaDegrees)) {
                                    return;
                                }
                                if (e.absolute) {
                                    _this._alphaOffset = 0;
                                }
                                var webkitCompassHeading = e['webkitCompassHeading'];
                                var webkitCompassAccuracy = +e['webkitCompassAccuracy'];
                                // when the phone is almost updside down, webkit flips the compass heading 
                                // (not documented anywhere, annoyingly)
                                // if (e.beta >= 130 || e.beta <= -130) webkitCompassHeading = undefined;
                                if ((!cesium_imports_1.defined(_this._alphaOffset) || Math.abs(_this._headingDrift) > 5) && cesium_imports_1.defined(webkitCompassHeading) && webkitCompassAccuracy >= 0 && webkitCompassAccuracy < 50 && webkitCompassHeading >= 0) {
                                    if (!cesium_imports_1.defined(_this._alphaOffset)) {
                                        _this._alphaOffset = -webkitCompassHeading;
                                    } else {
                                        _this._alphaOffset -= _this._headingDrift;
                                    }
                                }
                                var alphaOffset = _this._alphaOffset || -webkitCompassHeading || 0;
                                // TODO: deal with various browser quirks :\
                                // https://mobiforge.com/design-development/html5-mobile-web-device-orientation-events
                                var alpha = cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE * (e.alpha + alphaOffset);
                                var beta = cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE * e.beta;
                                var gamma = cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE * e.gamma;
                                var alphaQuat = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_Z, alpha, _this._scratchQuaternion1);
                                var betaQuat = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_X, beta, _this._scratchQuaternion2);
                                var alphaBetaQuat = cesium_imports_1.Quaternion.multiply(alphaQuat, betaQuat, _this._scratchQuaternion1);
                                var gammaQuat = cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_Y, gamma, _this._scratchQuaternion2);
                                var alphaBetaGammaQuat = cesium_imports_1.Quaternion.multiply(alphaBetaQuat, gammaQuat, alphaBetaQuat);
                                // update orientationEntity
                                if (_this.orientationEntity.position instanceof cesium_imports_1.ConstantPositionProperty == false) {
                                    _this.orientationEntity.position = new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, _this.geolocationEntity);
                                }
                                if (_this.orientationEntity.orientation instanceof cesium_imports_1.ConstantProperty == false) {
                                    _this.orientationEntity.orientation = new cesium_imports_1.ConstantProperty();
                                }
                                _this.orientationEntity.orientation.setValue(alphaBetaGammaQuat);
                                // make sure the device entity has a defined pose relative to the device orientation entity
                                if (_this.entity.position instanceof cesium_imports_1.ConstantPositionProperty == false) {
                                    _this.entity.position = new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, _this.orientationEntity);
                                }
                                if (_this.entity.orientation instanceof cesium_imports_1.ConstantProperty == false) {
                                    _this.entity.orientation = new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY);
                                }
                                // TODO: fix heading drift calculation (heading should match webkitCompassHeading)
                                // if (defined(webkitCompassHeading)) {
                                //     const q = alphaBetaGammaQuat//utils.getEntityOrientationInReferenceFrame(this.interfaceEntity, JulianDate.now(), this.locationEntity, this._scratchQuaternion1);
                                //     var heading = -Math.atan2(2*(q.w*q.z + q.x*q.y), 1 - 2*(q.y*q.y + q.z*q.z));
                                //     if (heading < 0) heading += 2*Math.PI;
                                //     const {swing,twist} = swingTwistDecomposition(alphaBetaGammaQuat, Cartesian3.UNIT_Z);
                                //     const twistAngle = 2 * Math.acos(twist.w);
                                //     console.log(twist.w + ' ' + twistAngle * CesiumMath.DEGREES_PER_RADIAN + '\n' + webkitCompassHeading);
                                //     // this._headingDrift = webkitCompassHeading - heading * CesiumMath.DEGREES_PER_RADIAN;
                                // }
                            };
                            window.addEventListener('deviceorientation', this._deviceorientationListener);
                        } else if (cesium_imports_1.defined(this._deviceorientationListener) && !this.orientationUpdatesEnabled) {
                            window.removeEventListener('deviceorientation', this._deviceorientationListener);
                            this._deviceorientationListener = undefined;
                        }
                    }
                };
                /**
                * Update the pose with latest sensor data
                */
                DeviceService.prototype.update = function () {
                    var _this = this;
                    if (cesium_imports_1.defined(this._idleTimeoutId)) clearTimeout(this._idleTimeoutId);
                    this._idleTimeoutId = setTimeout(function () {
                        _this.onIdle();
                    }, 2000);
                    this.onUpdate();
                };
                DeviceService = __decorate([aurelia_dependency_injection_1.inject(context_2.ContextService)], DeviceService);
                return DeviceService;
            }();
            exports_1("DeviceService", DeviceService);
        }
    };
});
$__System.register('16', ['13'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var cesium_imports_1;
    var TimerService, lastTime;
    function requestAnimationFramePoly(callback) {
        var currTime = Date.now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    }
    return {
        setters: [function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }],
        execute: function () {
            /**
             * Provides timer service
             */
            TimerService = function () {
                function TimerService() {
                    this.frameNumbers = new WeakMap();
                }
                /**
                 * Request that the callback function be called for the next frame.
                 *
                 * @param callback function
                 */
                TimerService.prototype.requestFrame = function (callback) {
                    var _this = this;
                    if (typeof requestAnimationFrame !== 'undefined' && typeof performance !== 'undefined') {
                        this.navigationStartDate = this.navigationStartDate || cesium_imports_1.JulianDate.fromDate(new Date(performance.timing.navigationStart));
                        requestAnimationFrame(function (time) {
                            var frameTime = cesium_imports_1.JulianDate.addSeconds(_this.navigationStartDate, time / 1000, new cesium_imports_1.JulianDate(0, 0));
                            callback(frameTime, _this.getNextFrameNumber(callback));
                        });
                    } else {
                        requestAnimationFramePoly(function (time) {
                            var frameTime = cesium_imports_1.JulianDate.fromDate(new Date(time));
                            callback(frameTime, _this.getNextFrameNumber(callback));
                        });
                    }
                };
                TimerService.prototype.getNextFrameNumber = function (callback) {
                    var frameNumber = this.frameNumbers.get(callback) || 0;
                    this.frameNumbers.set(callback, frameNumber + 1);
                    return frameNumber;
                };
                return TimerService;
            }();
            exports_1("TimerService", TimerService);
            lastTime = 0;
        }
    };
});
$__System.register('17', ['15', '18', '19', '12', '16', '1a', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, common_1, session_1, device_1, timer_1, reality_1, utils_1;
    var EmptyRealityLoader;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (common_1_1) {
            common_1 = common_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (device_1_1) {
            device_1 = device_1_1;
        }, function (timer_1_1) {
            timer_1 = timer_1_1;
        }, function (reality_1_1) {
            reality_1 = reality_1_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }],
        execute: function () {
            EmptyRealityLoader = function (_super) {
                __extends(EmptyRealityLoader, _super);
                function EmptyRealityLoader(sessionService, deviceService, timer) {
                    _super.call(this);
                    this.sessionService = sessionService;
                    this.deviceService = deviceService;
                    this.timer = timer;
                    this.type = 'empty';
                }
                EmptyRealityLoader.prototype.load = function (reality, callback) {
                    var _this = this;
                    var realitySession = this.sessionService.addManagedSessionPort(reality.uri);
                    var remoteRealitySession = this.sessionService.createSessionPort();
                    var doUpdate = true;
                    remoteRealitySession.on['ar.context.update'] = function () {};
                    remoteRealitySession.connectEvent.addEventListener(function () {
                        var update = function (time, index) {
                            if (doUpdate) {
                                _this.deviceService.update();
                                var frameState = {
                                    time: time,
                                    index: index,
                                    eye: {
                                        pose: utils_1.getSerializedEntityPose(_this.deviceService.displayEntity, time)
                                    }
                                };
                                remoteRealitySession.send('ar.reality.frameState', frameState);
                                _this.timer.requestFrame(update);
                            }
                        };
                        _this.timer.requestFrame(update);
                    });
                    remoteRealitySession.closeEvent.addEventListener(function () {
                        doUpdate = false;
                    });
                    callback(realitySession);
                    // Only connect after the caller is able to attach connectEvent handlers
                    var messageChannel = this.sessionService.createSynchronousMessageChannel();
                    realitySession.open(messageChannel.port1, this.sessionService.configuration);
                    remoteRealitySession.open(messageChannel.port2, { role: common_1.Role.REALITY_VIEW });
                };
                EmptyRealityLoader = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, device_1.DeviceService, timer_1.TimerService)], EmptyRealityLoader);
                return EmptyRealityLoader;
            }(reality_1.RealityLoader);
            exports_1("EmptyRealityLoader", EmptyRealityLoader);
        }
    };
});
$__System.register('1c', ['15', '1d', '19', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, focus_1, session_1, utils_1;
    var VuforiaInitResult, VuforiaHint, VuforiaServiceDelegateBase, VuforiaServiceDelegate, VuforiaService, VuforiaAPI, VuforiaTracker, VuforiaObjectTracker, VuforiaDataSet;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (focus_1_1) {
            focus_1 = focus_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }],
        execute: function () {
            /**
             * The set of possible error codes that can be returned from vuforia's
             * initialization function.
             */
            (function (VuforiaInitResult) {
                VuforiaInitResult[VuforiaInitResult["SUCCESS"] = 100] = "SUCCESS";
                /** Error during initialization. */
                VuforiaInitResult[VuforiaInitResult["INIT_ERROR"] = -1] = "INIT_ERROR";
                /** The device is not supported. */
                VuforiaInitResult[VuforiaInitResult["INIT_DEVICE_NOT_SUPPORTED"] = -2] = "INIT_DEVICE_NOT_SUPPORTED";
                /** Cannot access the camera. */
                VuforiaInitResult[VuforiaInitResult["INIT_NO_CAMERA_ACCESS"] = -3] = "INIT_NO_CAMERA_ACCESS";
                /** License key is missing. */
                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_MISSING_KEY"] = -4] = "INIT_LICENSE_ERROR_MISSING_KEY";
                /** Invalid license key passed to SDK. */
                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_INVALID_KEY"] = -5] = "INIT_LICENSE_ERROR_INVALID_KEY";
                /** Unable to verify license key due to network (Permanent error). */
                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT"] = -6] = "INIT_LICENSE_ERROR_NO_NETWORK_PERMANENT";
                /** Unable to verify license key due to network (Transient error). */
                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT"] = -7] = "INIT_LICENSE_ERROR_NO_NETWORK_TRANSIENT";
                /** Provided key is no longer valid. */
                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_CANCELED_KEY"] = -8] = "INIT_LICENSE_ERROR_CANCELED_KEY";
                /** Provided key is not valid for this product. */
                VuforiaInitResult[VuforiaInitResult["INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH"] = -9] = "INIT_LICENSE_ERROR_PRODUCT_TYPE_MISMATCH";
                /** Dependent external device not detected/plugged in. */
                VuforiaInitResult[VuforiaInitResult["INIT_EXTERNAL_DEVICE_NOT_DETECTED"] = -10] = "INIT_EXTERNAL_DEVICE_NOT_DETECTED";
            })(VuforiaInitResult || (VuforiaInitResult = {}));
            exports_1("VuforiaInitResult", VuforiaInitResult);
            (function (VuforiaHint) {
                VuforiaHint[VuforiaHint["MaxSimultaneousImageTargets"] = 0] = "MaxSimultaneousImageTargets";
                VuforiaHint[VuforiaHint["MaxSimultaneousObjectTargets"] = 1] = "MaxSimultaneousObjectTargets";
                VuforiaHint[VuforiaHint["DelayedLoadingObjectDatasets"] = 2] = "DelayedLoadingObjectDatasets";
            })(VuforiaHint || (VuforiaHint = {}));
            exports_1("VuforiaHint", VuforiaHint);
            /**
             * An abstract class representing the Vuforia API.
             */
            VuforiaServiceDelegateBase = function () {
                function VuforiaServiceDelegateBase() {
                    this.stateUpdateEvent = new utils_1.Event();
                }
                return VuforiaServiceDelegateBase;
            }();
            exports_1("VuforiaServiceDelegateBase", VuforiaServiceDelegateBase);
            /**
             * An no-op implementation of VuforiaServiceDelegate.
             */
            VuforiaServiceDelegate = function (_super) {
                __extends(VuforiaServiceDelegate, _super);
                function VuforiaServiceDelegate() {
                    _super.apply(this, arguments);
                }
                VuforiaServiceDelegate.prototype.isAvailable = function () {
                    return false;
                };
                VuforiaServiceDelegate.prototype.setHint = function (hint, value) {
                    return true;
                };
                VuforiaServiceDelegate.prototype.decryptLicenseKey = function (encryptedLicenseData, session) {
                    return Promise.resolve(undefined);
                };
                VuforiaServiceDelegate.prototype.init = function (options) {
                    return Promise.resolve(VuforiaInitResult.SUCCESS);
                };
                VuforiaServiceDelegate.prototype.deinit = function () {};
                VuforiaServiceDelegate.prototype.cameraDeviceInitAndStart = function () {
                    return true;
                };
                VuforiaServiceDelegate.prototype.cameraDeviceSetFlashTorchMode = function (on) {
                    return true;
                };
                VuforiaServiceDelegate.prototype.objectTrackerInit = function () {
                    return true;
                };
                VuforiaServiceDelegate.prototype.objectTrackerCreateDataSet = function (url) {
                    return '';
                };
                VuforiaServiceDelegate.prototype.objectTrackerDestroyDataSet = function (id) {
                    return true;
                };
                VuforiaServiceDelegate.prototype.objectTrackerActivateDataSet = function (id) {
                    return true;
                };
                VuforiaServiceDelegate.prototype.objectTrackerDeactivateDataSet = function (id) {
                    return true;
                };
                VuforiaServiceDelegate.prototype.dataSetFetch = function (id) {
                    return Promise.resolve(undefined);
                };
                VuforiaServiceDelegate.prototype.dataSetLoad = function (id) {
                    return Promise.resolve();
                };
                return VuforiaServiceDelegate;
            }(VuforiaServiceDelegateBase);
            exports_1("VuforiaServiceDelegate", VuforiaServiceDelegate);
            /**
             * Mediates requests to the Vuforia API. Handles the following requests:
             * // TODO
             */
            VuforiaService = function () {
                function VuforiaService(sessionService, focusService, delegate) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.focusService = focusService;
                    this.delegate = delegate;
                    this._sessionSwitcherCommandQueue = new utils_1.CommandQueue();
                    this._sessionCommandQueue = new WeakMap();
                    this._sessionInitOptions = new WeakMap();
                    this._sessionInitPromise = new WeakMap();
                    this._sessionIsInitialized = new WeakMap();
                    this._sessionCreatedDataSets = new WeakMap();
                    this._sessionActivatedDataSets = new WeakMap();
                    if (sessionService.isRealityManager) {
                        this._sessionSwitcherCommandQueue.errorEvent.addEventListener(function (err) {
                            _this.sessionService.errorEvent.raiseEvent(err);
                        });
                        sessionService.connectEvent.addEventListener(function (session) {
                            var commandQueue = new utils_1.CommandQueue();
                            commandQueue.errorEvent.addEventListener(function (err) {
                                _this.sessionService.errorEvent.raiseEvent(err);
                                session.sendError(err);
                            });
                            _this._sessionCommandQueue.set(session, commandQueue);
                            var createdDataSets = new Set();
                            _this._sessionCreatedDataSets.set(session, createdDataSets);
                            var activatedDataSets = new Set();
                            _this._sessionActivatedDataSets.set(session, activatedDataSets);
                            session.on['ar.vuforia.isAvailable'] = function () {
                                return Promise.resolve({ available: delegate.isAvailable() });
                            };
                            session.on['ar.vuforia.init'] = function (options) {
                                if (!delegate.isAvailable()) throw new Error("Vuforia is not supported");
                                if (_this._sessionIsInitialized.get(session)) throw new Error("Vuforia has already been initialized");
                                if (!options.key && !options.encryptedLicenseData) throw new Error("Expected `encryptedLicenseData` field. You can encrypt your Vuforia license key at http://docs.argonjs.io/start/vuforia-pgp-encryptor");
                                var keyPromise = options.key ? Promise.resolve(options.key) : delegate.decryptLicenseKey(options.encryptedLicenseData, session);
                                return keyPromise.then(function (key) {
                                    _this._sessionInitOptions.set(session, {
                                        key: key
                                    });
                                    var result = commandQueue.push(function () {
                                        return _this._init(session).then(function () {
                                            _this._sessionIsInitialized.set(session, true);
                                        });
                                    }, _this._controllingSession === session);
                                    if (_this.focusService.getSession() === session) {
                                        _this._setControllingSession(session);
                                    }
                                    _this._sessionInitPromise.set(session, result);
                                    return result;
                                });
                            };
                            session.on['ar.vuforia.objectTrackerCreateDataSet'] = function (_a) {
                                var url = _a.url;
                                return commandQueue.push(function () {
                                    var id = delegate.objectTrackerCreateDataSet(url);
                                    if (id) {
                                        createdDataSets.add(id);
                                        return Promise.resolve({ id: id });
                                    }
                                    throw new Error('Unable to create DataSet');
                                }, _this._controllingSession === session);
                            };
                            session.on['ar.vuforia.objectTrackerActivateDataSet'] = function (_a) {
                                var id = _a.id;
                                return commandQueue.push(function () {
                                    if (delegate.objectTrackerActivateDataSet(id)) {
                                        activatedDataSets.add(id);
                                        session.send('ar.vuforia.objectTrackerActivateDataSetEvent', { id: id });
                                        return;
                                    }
                                    throw new Error("Unable to activate DataSet (" + id + ")");
                                }, _this._controllingSession === session);
                            };
                            session.on['ar.vuforia.objectTrackerDeactivateDataSet'] = function (_a) {
                                var id = _a.id;
                                return commandQueue.push(function () {
                                    if (delegate.objectTrackerDeactivateDataSet(id)) {
                                        activatedDataSets.delete(id);
                                        session.send('ar.vuforia.objectTrackerDeactivateDataSetEvent', { id: id });
                                        return;
                                    }
                                    throw new Error("Unable to deactivate DataSet (" + id + ")");
                                }, _this._controllingSession === session);
                            };
                            session.on['ar.vuforia.dataSetFetch'] = function (_a) {
                                var id = _a.id;
                                return commandQueue.push(function () {
                                    return delegate.dataSetFetch(id);
                                }, _this._controllingSession === session);
                            };
                            session.on['ar.vuforia.dataSetLoad'] = function (_a) {
                                var id = _a.id;
                                return commandQueue.push(function () {
                                    return delegate.dataSetLoad(id);
                                }, _this._controllingSession === session);
                            };
                            session.closeEvent.addEventListener(function () {
                                if (_this._controllingSession === session) {
                                    commandQueue.clear();
                                    commandQueue.push(function () {
                                        _this._cleanupSession(session);
                                        setTimeout(function () {
                                            _this._ensureActiveSession();
                                        }, 2000);
                                    }, true);
                                } else {
                                    _this._cleanupSession(session);
                                }
                            });
                        });
                        focusService.sessionFocusEvent.addEventListener(function (_a) {
                            var current = _a.current;
                            if (current && _this._sessionInitOptions.get(current)) {
                                _this._setControllingSession(current);
                            }
                        });
                    }
                }
                ;
                VuforiaService.prototype.isAvailable = function () {
                    return this.sessionService.manager.request('ar.vuforia.isAvailable').then(function (message) {
                        return message.available;
                    });
                };
                /**
                 * Initialize vuforia with an unecrypted key. Manager-only, unless the "force" (flag) is used.
                 * It's a bad idea to publish your private vuforia key on the internet.
                 */
                VuforiaService.prototype.initWithUnencryptedKey = function (options, force) {
                    var _this = this;
                    if (!force) this.sessionService.ensureIsRealityManager();
                    return this.sessionService.manager.request('ar.vuforia.init', options).then(function () {
                        return new VuforiaAPI(_this.sessionService.manager);
                    });
                };
                /**
                 * Initialize vuforia using an encrypted license key.
                 * You can encrypt your license key at http://docs.argonjs.io/start/vuforia-pgp-encryptor
                 */
                VuforiaService.prototype.init = function (options) {
                    var _this = this;
                    if (!options.encryptedLicenseData || typeof options.encryptedLicenseData !== 'string') throw new Error('options.encryptedLicenseData is required.');
                    return this.sessionService.manager.request('ar.vuforia.init', options).then(function () {
                        return new VuforiaAPI(_this.sessionService.manager);
                    });
                };
                VuforiaService.prototype._ensureActiveSession = function () {
                    console.log("VuforiaService: Ensuring an active session is in control.");
                    if (this._controllingSession && this._controllingSession.isConnected) return;
                    this._selectControllingSession();
                };
                VuforiaService.prototype._selectControllingSession = function () {
                    var focusSession = this.focusService.getSession();
                    if (focusSession && this._sessionInitOptions.get(focusSession)) {
                        this._setControllingSession(focusSession);
                        return;
                    }
                    for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
                        var session = _a[_i];
                        if (this._sessionInitOptions.get(session)) {
                            this._setControllingSession(session);
                            return;
                        }
                    }
                    if (this._sessionInitOptions.get(this.sessionService.manager)) this._setControllingSession(this.sessionService.manager);
                };
                VuforiaService.prototype._setControllingSession = function (session) {
                    var _this = this;
                    if (this._controllingSession === session) return;
                    console.log("VuforiaService: Setting controlling session to " + session.uri);
                    this._sessionSwitcherCommandQueue.clear();
                    this._sessionSwitcherCommandQueue.push(function () {
                        return _this._pauseSession().then(function () {
                            return _this._resumeSession(session);
                        });
                    }, true);
                };
                VuforiaService.prototype._resumeSession = function (session) {
                    if (this._controllingSession) throw new Error('Attempted to resume a session while a session is still in control');
                    if (session) console.log("VuforiaService: Resuming session " + session.uri);
                    var initOptions = this._sessionInitOptions.get(session);
                    if (!initOptions) {
                        throw new Error('Attempted to resume a session without initialization options');
                    }
                    this._controllingSession = session;
                    var commandQueue = this._sessionCommandQueue.get(session);
                    if (this._sessionIsInitialized.get(session)) {
                        return this._init(session).then(function () {
                            commandQueue.execute();
                        }).catch(function (err) {
                            session.sendError(err);
                        });
                    } else {
                        commandQueue.execute();
                        return this._sessionInitPromise.get(session);
                    }
                };
                VuforiaService.prototype._pauseSession = function () {
                    var _this = this;
                    var session = this._controllingSession;
                    if (!session) return Promise.resolve(undefined);
                    console.log("VuforiaService: Pausing session " + session.uri);
                    var commandQueue = this._sessionCommandQueue.get(session);
                    return commandQueue.push(function () {
                        commandQueue.pause();
                        _this._controllingSession = undefined;
                        return _this._deinit(session);
                    }, true);
                };
                VuforiaService.prototype._cleanupSession = function (session) {
                    var _this = this;
                    if (!this._sessionInitOptions.has(session)) return;
                    // delete session init options
                    this._sessionInitOptions.delete(session);
                    var createdDataSets = this._sessionCreatedDataSets.get(session);
                    // Deactivate session datasets / trackables
                    console.log('VuforiaService: Deactivating datasets for session ' + session.uri);
                    this._sessionActivatedDataSets.get(session).forEach(function (id) {
                        _this.delegate.objectTrackerDeactivateDataSet(id);
                    });
                    this._sessionActivatedDataSets.delete(session);
                    // destroy session objects                   
                    console.log('VuforiaService: Destroying objects for session ' + session.uri);
                    createdDataSets.forEach(function (id) {
                        _this.delegate.objectTrackerDestroyDataSet(id);
                    });
                    this._sessionCreatedDataSets.delete(session);
                };
                VuforiaService.prototype._init = function (session) {
                    var _this = this;
                    console.log("Attempting to initialize vuforia for " + session.uri);
                    var options = this._sessionInitOptions.get(session);
                    return this.delegate.init(options).then(function (initResult) {
                        if (initResult !== VuforiaInitResult.SUCCESS) {
                            throw new Error("Vuforia init failed: " + VuforiaInitResult[initResult]);
                        }
                        // must initialize trackers before initializing the camera device
                        if (!_this.delegate.objectTrackerInit()) {
                            throw new Error("Vuforia init failed: Unable to initialize ObjectTracker");
                        }
                        // restore active datasets & trackables
                        var success = true;
                        _this._sessionActivatedDataSets.get(session).forEach(function (id) {
                            success = success && _this.delegate.objectTrackerActivateDataSet(id);
                            if (success) {
                                session.send('ar.vuforia.objectTrackerActivateDataSetEvent', { id: id });
                            }
                        });
                        if (!success) {
                            throw new Error("Vuforia init failed: Unable to restore active datasets");
                        }
                        // todo: also activate datasets / trackables created by other sessions
                        // (if this fails, then vuforia has probably started forbidding datasets created 
                        // by one developer account to work while using a license key from a different
                        // developer account, so no need to return a rejected promise in that case)
                        if (!_this.delegate.cameraDeviceInitAndStart()) {
                            throw new Error("Vuforia init failed: Unable to complete initialization");
                        }
                        console.log("Vuforia init success");
                    }).catch(function (err) {
                        console.log("Vuforia init fail: " + err.message);
                        _this._sessionInitOptions.delete(session);
                        _this._sessionIsInitialized.set(session, false);
                        _this._deinit(session);
                        _this._ensureActiveSession();
                        throw err;
                    });
                };
                VuforiaService.prototype._deinit = function (session) {
                    // Deactivate any activated datasets, stop trackers, and deinit. 
                    // Don't actually destroy created resources so we can use them to restore state. 
                    var _this = this;
                    var activatedDataSets = this._sessionActivatedDataSets.get(session);
                    if (activatedDataSets) {
                        activatedDataSets.forEach(function (id) {
                            _this.delegate.objectTrackerDeactivateDataSet(id);
                            session.send('ar.vuforia.objectTrackerDeactivateDataSetEvent', { id: id });
                        });
                    }
                    // right now the delegate.deinit() call deinitiailizes trackers and camera device for us. 
                    // May want to move here instead?
                    // const errors:Array<string> = [];
                    // if (!this.delegate.objectTrackerDeinit()) {
                    //     errors.push("Unable to deinitialize ObjectTracker");
                    // } 
                    // if (!this.delegate.cameraDeviceDeinit()) {
                    //     errors.push("Unable to deinitialize CameraDevice");
                    // }
                    this.delegate.deinit();
                    // if (errors.length > 0) {
                    //     throw new Error(errors.join('\n'));
                    // }
                };
                VuforiaService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, focus_1.FocusService, VuforiaServiceDelegate)], VuforiaService);
                return VuforiaService;
            }();
            exports_1("VuforiaService", VuforiaService);
            VuforiaAPI = function () {
                function VuforiaAPI(manager) {
                    this.objectTracker = new VuforiaObjectTracker(manager);
                }
                return VuforiaAPI;
            }();
            exports_1("VuforiaAPI", VuforiaAPI);
            VuforiaTracker = function () {
                function VuforiaTracker() {}
                return VuforiaTracker;
            }();
            exports_1("VuforiaTracker", VuforiaTracker);
            /**
             * Vuforia Object Tracker
             */
            VuforiaObjectTracker = function (_super) {
                __extends(VuforiaObjectTracker, _super);
                function VuforiaObjectTracker(manager) {
                    var _this = this;
                    _super.call(this);
                    this.manager = manager;
                    this._dataSetMap = new Map();
                    this.dataSetActivateEvent = new utils_1.Event();
                    this.dataSetDeactivateEvent = new utils_1.Event();
                    manager.on['ar.vuforia.objectTrackerActivateDataSetEvent'] = function (_a) {
                        var id = _a.id;
                        var dataSet = _this._dataSetMap.get(id);
                        dataSet._onActivate();
                        _this.dataSetActivateEvent.raiseEvent(dataSet);
                    };
                    manager.on['ar.vuforia.objectTrackerDeactivateDataSetEvent'] = function (_a) {
                        var id = _a.id;
                        var dataSet = _this._dataSetMap.get(id);
                        dataSet._onDeactivate();
                        _this.dataSetDeactivateEvent.raiseEvent(dataSet);
                    };
                }
                VuforiaObjectTracker.prototype.createDataSet = function (url) {
                    var _this = this;
                    if (url && window.document) {
                        url = utils_1.resolveURL(url);
                    }
                    return this.manager.request('ar.vuforia.objectTrackerCreateDataSet', { url: url }).then(function (message) {
                        var dataSet = new VuforiaDataSet(message.id, _this.manager);
                        _this._dataSetMap.set(message.id, dataSet);
                        return dataSet;
                    });
                };
                VuforiaObjectTracker.prototype.activateDataSet = function (dataSet) {
                    return this.manager.request('ar.vuforia.objectTrackerActivateDataSet', { id: dataSet.id });
                };
                VuforiaObjectTracker.prototype.deactivateDataSet = function (dataSet) {
                    return this.manager.request('ar.vuforia.objectTrackerDeactivateDataSet', { id: dataSet.id });
                };
                return VuforiaObjectTracker;
            }(VuforiaTracker);
            exports_1("VuforiaObjectTracker", VuforiaObjectTracker);
            /**
             * A vuforia data set. TODO
             */
            VuforiaDataSet = function () {
                function VuforiaDataSet(id, manager) {
                    this.id = id;
                    this.manager = manager;
                    this._isActive = false;
                }
                VuforiaDataSet.prototype._onActivate = function () {
                    this._isActive = true;
                };
                VuforiaDataSet.prototype._onDeactivate = function () {
                    this._isActive = false;
                };
                VuforiaDataSet.prototype.fetch = function () {
                    return this.manager.request('ar.vuforia.dataSetFetch', { id: this.id }).then(function () {});
                };
                VuforiaDataSet.prototype.load = function () {
                    var _this = this;
                    return this.manager.request('ar.vuforia.dataSetLoad', { id: this.id }).then(function (trackables) {
                        _this._trackables = trackables;
                        return trackables;
                    });
                };
                VuforiaDataSet.prototype.isActive = function () {
                    return this._isActive;
                };
                VuforiaDataSet.prototype.getTrackables = function () {
                    return this._trackables;
                };
                return VuforiaDataSet;
            }();
            exports_1("VuforiaDataSet", VuforiaDataSet);
        }
    };
});
$__System.register('1e', ['15', '18', '19', '1a', '1c'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, common_1, session_1, reality_1, vuforia_1;
    var LiveVideoRealityLoader;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (common_1_1) {
            common_1 = common_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (reality_1_1) {
            reality_1 = reality_1_1;
        }, function (vuforia_1_1) {
            vuforia_1 = vuforia_1_1;
        }],
        execute: function () {
            LiveVideoRealityLoader = function (_super) {
                __extends(LiveVideoRealityLoader, _super);
                function LiveVideoRealityLoader(sessionService, vuforiaDelegate) {
                    _super.call(this);
                    this.sessionService = sessionService;
                    this.vuforiaDelegate = vuforiaDelegate;
                    this.type = 'live-video';
                }
                LiveVideoRealityLoader.prototype.load = function (reality, callback) {
                    var _this = this;
                    var realitySession = this.sessionService.addManagedSessionPort(reality.uri);
                    var remoteRealitySession = this.sessionService.createSessionPort();
                    remoteRealitySession.on['ar.context.update'] = function () {};
                    remoteRealitySession.connectEvent.addEventListener(function () {
                        var remove = _this.vuforiaDelegate.stateUpdateEvent.addEventListener(function (frameState) {
                            remoteRealitySession.send('ar.reality.frameState', frameState);
                        });
                        _this.vuforiaDelegate.videoEnabled = true;
                        _this.vuforiaDelegate.trackingEnabled = true;
                        remoteRealitySession.closeEvent.addEventListener(function () {
                            remove();
                            _this.vuforiaDelegate.videoEnabled = false;
                            _this.vuforiaDelegate.trackingEnabled = false;
                        });
                    });
                    callback(realitySession);
                    // Only connect after the caller is able to attach connectEvent handlers
                    var messageChannel = this.sessionService.createSynchronousMessageChannel();
                    realitySession.open(messageChannel.port1, this.sessionService.configuration);
                    remoteRealitySession.open(messageChannel.port2, { role: common_1.Role.REALITY_VIEW });
                };
                LiveVideoRealityLoader = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, vuforia_1.VuforiaServiceDelegate)], LiveVideoRealityLoader);
                return LiveVideoRealityLoader;
            }(reality_1.RealityLoader);
            exports_1("LiveVideoRealityLoader", LiveVideoRealityLoader);
        }
    };
});
$__System.register('14', ['15', '13', '19', '1a', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, cesium_imports_1, session_1, reality_1, utils_1;
    var PoseStatus, scratchCartesian3, scratchQuaternion, scratchOriginCartesian3, ContextService;
    function _stringFromReferenceFrame(referenceFrame) {
        var rf = referenceFrame;
        return cesium_imports_1.defined(rf.id) ? rf.id : '' + rf;
    }
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (reality_1_1) {
            reality_1 = reality_1_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }],
        execute: function () {
            /**
            * A bitmask that provides metadata about the pose of an EntityPose.
            *   KNOWN - the pose of the entity state is defined.
            *   KNOWN & FOUND - the pose was undefined when the entity state was last queried, and is now defined.
            *   LOST - the pose was defined when the entity state was last queried, and is now undefined
            */
            (function (PoseStatus) {
                PoseStatus[PoseStatus["KNOWN"] = 1] = "KNOWN";
                PoseStatus[PoseStatus["FOUND"] = 2] = "FOUND";
                PoseStatus[PoseStatus["LOST"] = 4] = "LOST";
            })(PoseStatus || (PoseStatus = {}));
            exports_1("PoseStatus", PoseStatus);
            scratchCartesian3 = new cesium_imports_1.Cartesian3(0, 0);
            scratchQuaternion = new cesium_imports_1.Quaternion(0, 0);
            scratchOriginCartesian3 = new cesium_imports_1.Cartesian3(0, 0);
            /**
             * Provides a means of querying the current state of reality.
             *
             * This class adds the following message handlers to any sessions
             * managed by the session service:
             *
             *  * `ar.context.subscribe` - Subscribes the session to updates from an
             *    entity with the provided id.
             *    * Parameters:
             *      * id: string - The id of an entity the session wishes to recieve
             *        updates on.
             *
             * This service sends the following messages to managed sessions
             *
             *  * `ar.context.update` - Indicates to this context that the session wants
             *    to be focused on.
             */
            ContextService = function () {
                function ContextService(sessionService, realityService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.realityService = realityService;
                    /**
                     * An event that is raised when all remotely managed entities are are up-to-date for
                     * the current frame. It is suggested that all modifications to locally managed entities
                     * should occur within this event.
                     */
                    this.updateEvent = new utils_1.Event();
                    /**
                     * An event that is raised when it is an approriate time to render graphics.
                     * This event fires after the update event.
                     */
                    this.renderEvent = new utils_1.Event();
                    /**
                     * The set of entities representing well-known reference frames.
                     * These are assumed to be readily available to applications.
                     */
                    this.wellKnownReferenceFrames = new cesium_imports_1.EntityCollection();
                    /**
                     * The set of subscribed entities.
                     */
                    this.subscribedEntities = new cesium_imports_1.EntityCollection();
                    /**
                     * The set of entities that this session is aware of.
                     */
                    this.entities = new cesium_imports_1.CompositeEntityCollection();
                    /**
                     * An event that fires when the local origin changes.
                     */
                    this.localOriginChangeEvent = new utils_1.Event();
                    /**
                     * An entity representing the location and orientation of the user.
                     */
                    this.user = new cesium_imports_1.Entity({
                        id: 'ar.user',
                        name: 'user',
                        position: new cesium_imports_1.ConstantPositionProperty(undefined, cesium_imports_1.ReferenceFrame.FIXED),
                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY)
                    });
                    /**
                     * An entity positioned near the user, aligned with the local East-North-Up
                     * coordinate system.
                     */
                    this.localOriginEastNorthUp = new cesium_imports_1.Entity({
                        id: 'ar.localENU',
                        name: 'localOriginENU',
                        position: new cesium_imports_1.ConstantPositionProperty(undefined, cesium_imports_1.ReferenceFrame.FIXED),
                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.IDENTITY)
                    });
                    /**
                     * An entity positioned near the user, aligned with the East-Up-South
                     * coordinate system. This useful for converting to the Y-Up convention
                     * used in some libraries, such as three.js.
                     */
                    this.localOriginEastUpSouth = new cesium_imports_1.Entity({
                        id: 'ar.localEUS',
                        name: 'localOriginEUS',
                        position: new cesium_imports_1.ConstantPositionProperty(cesium_imports_1.Cartesian3.ZERO, this.localOriginEastNorthUp),
                        orientation: new cesium_imports_1.ConstantProperty(cesium_imports_1.Quaternion.fromAxisAngle(cesium_imports_1.Cartesian3.UNIT_X, Math.PI / 2))
                    });
                    /**
                     * This value caps the deltaTime for each frame
                     */
                    this.maxDeltaTime = 1 / 3 * 1000;
                    this._frame = {
                        time: new cesium_imports_1.JulianDate(0, 0),
                        systemTime: 0,
                        deltaTime: 0
                    };
                    // The default origin to use when calling `getEntityPose`.
                    this._defaultReferenceFrame = this.localOriginEastNorthUp;
                    this._entityPoseCache = {};
                    this._entityPoseMap = new Map();
                    this._subscribedEntities = new WeakMap();
                    this._updatingEntities = new Set();
                    this._knownEntities = new Set();
                    this.entities.addCollection(this.wellKnownReferenceFrames);
                    this.entities.addCollection(this.subscribedEntities);
                    this.subscribedEntities.add(this.user);
                    if (this.sessionService.isRealityManager) {
                        this.realityService.frameEvent.addEventListener(function (state) {
                            _this._update(state);
                        });
                        this.sessionService.connectEvent.addEventListener(function (session) {
                            _this._subscribedEntities.set(session, new Set());
                            session.on['ar.context.subscribe'] = function (_a) {
                                var id = _a.id;
                                var subscriptions = _this._subscribedEntities.get(session);
                                if (subscriptions) subscriptions.add(id);
                            };
                        });
                    } else {
                        this.sessionService.manager.on['ar.context.update'] = function (state) {
                            _this._update(state);
                        };
                    }
                }
                Object.defineProperty(ContextService.prototype, "frame", {
                    /**
                     * The current frame
                     */
                    get: function () {
                        if (!cesium_imports_1.defined(this.serializedFrameState)) throw new Error('A frame state has not yet been received');
                        return this._frame;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextService.prototype, "serializedFrameState", {
                    /**
                     * The serialized frame state for this frame
                     */
                    get: function () {
                        return this._serializedState;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Get the current time
                 */
                ContextService.prototype.getTime = function () {
                    return this.frame.time;
                };
                /**
                 * Set the default reference frame for `getCurrentEntityState`.
                 */
                ContextService.prototype.setDefaultReferenceFrame = function (origin) {
                    this._defaultReferenceFrame = origin;
                };
                /**
                 * Get the default reference frame to use when calling `getEntityPose`.
                 * By default, this is the `localOriginEastNorthUp` reference frame.
                 */
                ContextService.prototype.getDefaultReferenceFrame = function () {
                    return this._defaultReferenceFrame;
                };
                /**
                 * Adds an entity to this session's set of tracked entities.
                 *
                 * @param id - The unique identifier of an entity.
                 * @returns The entity that was subscribed to.
                 */
                ContextService.prototype.subscribeToEntityById = function (id) {
                    this.sessionService.manager.send('ar.context.subscribe', { id: id });
                    return this.subscribedEntities.getOrCreateEntity(id);
                };
                /**
                 * Gets the current pose of an entity, relative to a given reference frame.
                 *
                 * @param entity - The entity whose state is to be queried.
                 * @param referenceFrame - The intended reference frame. Defaults to `this.defaultReferenceFrame`.
                 * @returns If the position and orientation exist for the given entity, an
                 * object with the fields `position` and `orientation`, both of type
                 * `Cartesian3`. Otherwise undefined.
                 */
                ContextService.prototype.getEntityPose = function (entity, referenceFrame) {
                    if (referenceFrame === void 0) {
                        referenceFrame = this._defaultReferenceFrame;
                    }
                    var time = this.getTime();
                    var key = entity.id + '@' + _stringFromReferenceFrame(referenceFrame);
                    var entityPose = this._entityPoseMap.get(key);
                    if (!cesium_imports_1.defined(entityPose)) {
                        entityPose = {
                            position: new cesium_imports_1.Cartesian3(),
                            orientation: new cesium_imports_1.Quaternion(),
                            time: cesium_imports_1.JulianDate.clone(time),
                            poseStatus: 0
                        };
                        this._entityPoseMap.set(key, entityPose);
                    } else {
                        cesium_imports_1.JulianDate.clone(time, entityPose.time);
                    }
                    var position = utils_1.getEntityPositionInReferenceFrame(entity, time, referenceFrame, entityPose.position);
                    var orientation = utils_1.getEntityOrientationInReferenceFrame(entity, time, referenceFrame, entityPose.orientation);
                    var hasPose = position && orientation;
                    var poseStatus = 0;
                    var previousStatus = entityPose.poseStatus;
                    if (hasPose) {
                        poseStatus |= PoseStatus.KNOWN;
                    }
                    if (hasPose && !(previousStatus & PoseStatus.KNOWN)) {
                        poseStatus |= PoseStatus.FOUND;
                    } else if (!hasPose && previousStatus & PoseStatus.KNOWN) {
                        poseStatus |= PoseStatus.LOST;
                    }
                    entityPose.poseStatus = poseStatus;
                    return entityPose;
                };
                /**
                 * deprecated
                 */
                ContextService.prototype.getCurrentEntityState = function (entity, referenceFrame) {
                    console.warn('getCurrentEntityState is deprecated. Use getEntityPose instead.');
                    return this.getEntityPose(entity, referenceFrame);
                };
                // TODO: This function is called a lot. Potential for optimization. 
                ContextService.prototype._update = function (serializedState) {
                    var _this = this;
                    // if this session is the manager, we need to update our child sessions a.s.a.p
                    if (this.sessionService.isRealityManager) {
                        delete serializedState.entities[this.user.id]; // children don't need this
                        this._entityPoseCache = {};
                        for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
                            var session = _a[_i];
                            this._sendUpdateForSession(serializedState, session);
                        }
                    }
                    // our user entity is defined by the current view pose (the current reality must provide this)
                    serializedState.entities[this.user.id] = serializedState.view.pose;
                    // update the entities the manager knows about
                    this._knownEntities.clear();
                    for (var id in serializedState.entities) {
                        this.updateEntityFromFrameState(id, serializedState);
                        this._updatingEntities.add(id);
                        this._knownEntities.add(id);
                    }
                    // if the mangager didn't send us an update for a particular entity,
                    // assume the manager no longer knows about it
                    this._updatingEntities.forEach(function (id) {
                        if (!_this._knownEntities.has(id)) {
                            var entity = _this.subscribedEntities.getById(id);
                            entity.position = undefined;
                            entity.orientation = undefined;
                            // WORKAROUND until https://github.com/AnalyticalGraphicsInc/cesium/issues/4225 is fixed
                            entity = _this.entities.getById(id);
                            entity.position = undefined;
                            entity.orientation = undefined;
                            _this._updatingEntities.delete(id);
                        }
                    });
                    // update our local origin
                    this._updateLocalOrigin(serializedState);
                    // update our frame object
                    var frame = this._frame;
                    var now = typeof performance !== 'undefined' ? performance.now() : Date.now();
                    frame.deltaTime = Math.max(now - frame.systemTime, this.maxDeltaTime);
                    frame.systemTime = now;
                    cesium_imports_1.JulianDate.clone(serializedState.time, frame.time);
                    this._serializedState = serializedState;
                    // raise an event for the user update and render the scene
                    this.updateEvent.raiseEvent(frame);
                    this.renderEvent.raiseEvent(frame);
                };
                ContextService.prototype.updateEntityFromFrameState = function (id, state) {
                    var entityPose = state.entities[id];
                    if (!entityPose) {
                        if (!this.wellKnownReferenceFrames.getById(id)) {
                            this.subscribedEntities.getOrCreateEntity(id);
                        }
                        return;
                    }
                    var referenceFrame;
                    if (cesium_imports_1.defined(entityPose.r)) {
                        if (typeof entityPose.r === 'number') {
                            referenceFrame = entityPose.r;
                        } else {
                            referenceFrame = this.entities.getById(entityPose.r);
                        }
                    } else {
                        referenceFrame = cesium_imports_1.ReferenceFrame.FIXED;
                    }
                    if (!cesium_imports_1.defined(referenceFrame)) {
                        this.updateEntityFromFrameState(entityPose.r, state);
                        referenceFrame = this.entities.getById(entityPose.r);
                    }
                    var positionValue = entityPose.p === 0 ? cesium_imports_1.Cartesian3.ZERO : entityPose.p;
                    var orientationValue = entityPose.o === 0 ? cesium_imports_1.Quaternion.IDENTITY : entityPose.o;
                    var entity = this.subscribedEntities.getOrCreateEntity(id);
                    var entityPosition = entity.position;
                    var entityOrientation = entity.orientation;
                    if (!entityPosition || entityPosition.referenceFrame !== referenceFrame) {
                        entityPosition = new cesium_imports_1.ConstantPositionProperty(positionValue, referenceFrame);
                        entity.position = entityPosition;
                    } else if (entityPosition instanceof cesium_imports_1.ConstantPositionProperty) {
                        entityPosition.setValue(positionValue, referenceFrame);
                    } else if (entityPosition instanceof cesium_imports_1.SampledPositionProperty) {
                        entityPosition.addSample(cesium_imports_1.JulianDate.clone(state.time), positionValue);
                    }
                    if (!entityOrientation) {
                        entityOrientation = new cesium_imports_1.ConstantProperty(orientationValue);
                        entity.orientation = entityOrientation;
                    } else if (entityOrientation instanceof cesium_imports_1.ConstantProperty) {
                        entityOrientation.setValue(orientationValue);
                    } else if (entityOrientation instanceof cesium_imports_1.SampledProperty) {
                        entityOrientation.addSample(cesium_imports_1.JulianDate.clone(state.time), orientationValue);
                    }
                    return entity;
                };
                ContextService.prototype.publishEntityState = function (entity, referenceFrame) {};
                ContextService.prototype._updateLocalOrigin = function (state) {
                    var userRootFrame = utils_1.getRootReferenceFrame(this.user);
                    var userPosition = this.user.position && this.user.position.getValueInReferenceFrame(state.time, userRootFrame, scratchCartesian3);
                    var localENUFrame = this.localOriginEastNorthUp.position && this.localOriginEastNorthUp.position.referenceFrame;
                    var localENUPosition = this.localOriginEastNorthUp.position && localENUFrame && this.localOriginEastNorthUp.position.getValueInReferenceFrame(state.time, localENUFrame, scratchOriginCartesian3);
                    if (userPosition && (!localENUPosition || localENUFrame !== userRootFrame || cesium_imports_1.Cartesian3.magnitudeSquared(cesium_imports_1.Cartesian3.subtract(userPosition, localENUPosition, scratchOriginCartesian3)) > 25000000)) {
                        var localENUPositionProperty = this.localOriginEastNorthUp.position;
                        var localENUOrientationProperty = this.localOriginEastNorthUp.orientation;
                        localENUPositionProperty.setValue(userPosition, userRootFrame);
                        if (userRootFrame === cesium_imports_1.ReferenceFrame.FIXED) {
                            var enuOrientation = cesium_imports_1.Transforms.headingPitchRollQuaternion(userPosition, 0, 0, 0, undefined, scratchQuaternion);
                            localENUOrientationProperty.setValue(enuOrientation);
                        } else {
                            localENUOrientationProperty.setValue(cesium_imports_1.Quaternion.IDENTITY);
                        }
                        this.localOriginChangeEvent.raiseEvent(undefined);
                    }
                };
                ContextService.prototype._sendUpdateForSession = function (parentState, session) {
                    var _this = this;
                    var sessionPoseMap = {};
                    for (var id in parentState.entities) {
                        sessionPoseMap[id] = parentState.entities[id];
                    }
                    var subscriptions = this._subscribedEntities.get(session);
                    subscriptions.forEach(function (id) {
                        _this._addEntityAndAncestorsToPoseMap(sessionPoseMap, id, parentState.time);
                    });
                    var sessionState = {
                        reality: parentState.reality,
                        index: parentState.index,
                        time: parentState.time,
                        view: parentState.view,
                        entities: sessionPoseMap,
                        sendTime: cesium_imports_1.JulianDate.now()
                    };
                    session.send('ar.context.update', sessionState);
                };
                ContextService.prototype._addEntityAndAncestorsToPoseMap = function (poseMap, id, time) {
                    if (!cesium_imports_1.defined(this._entityPoseCache[id])) {
                        var entity = this.subscribedEntities.getById(id);
                        if (!entity) return;
                        this._entityPoseCache[id] = utils_1.getSerializedEntityPose(entity, time);
                        if (entity.position && entity.position.referenceFrame instanceof cesium_imports_1.Entity) {
                            var refId = _stringFromReferenceFrame(entity.position.referenceFrame);
                            this._addEntityAndAncestorsToPoseMap(poseMap, refId, time);
                        }
                    }
                    poseMap[id] = this._entityPoseCache[id];
                };
                ContextService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, reality_1.RealityService)], ContextService);
                return ContextService;
            }();
            exports_1("ContextService", ContextService);
        }
    };
});
$__System.register('1d', ['15', '19', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, session_1, utils_1;
    var FocusService;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }],
        execute: function () {
            /**
             * Manages focus state
             */
            FocusService = function () {
                function FocusService(sessionService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    /**
                     * An event that is raised when this session has gained focus
                     */
                    this.focusEvent = new utils_1.Event();
                    /**
                     * An event that is raised when this session has lost focus
                     */
                    this.blurEvent = new utils_1.Event();
                    this._hasFocus = false;
                    this._sessionFocusEvent = new utils_1.Event();
                    sessionService.manager.on['ar.focus.state'] = function (message) {
                        _this._setFocus(message.state);
                    };
                    if (sessionService.isRealityManager) {
                        sessionService.manager.connectEvent.addEventListener(function () {
                            setTimeout(function () {
                                if (!_this._session) _this.setSession(_this.sessionService.manager);
                            });
                        });
                    }
                }
                Object.defineProperty(FocusService.prototype, "hasFocus", {
                    /**
                     * True if this session has focus
                     */
                    get: function () {
                        return this._hasFocus;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FocusService.prototype, "sessionFocusEvent", {
                    /**
                     * Manager-only. An event that is raised when a managed session has acquired focus.
                     */
                    get: function () {
                        this.sessionService.ensureIsRealityManager();
                        return this._sessionFocusEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Manager-only. The managed session which currently has focus.
                 */
                FocusService.prototype.getSession = function () {
                    this.sessionService.ensureIsRealityManager();
                    return this._session;
                };
                /**
                 *  Manager-only. Grant focus to a managed session.
                 */
                FocusService.prototype.setSession = function (session) {
                    this.sessionService.ensureIsRealityManager();
                    if (session && !session.isConnected) throw new Error('Only a connected session can be granted focus');
                    var previousFocussedSession = this._session;
                    if (previousFocussedSession !== session) {
                        if (previousFocussedSession) previousFocussedSession.send('ar.focus.state', { state: false });
                        if (session) session.send('ar.focus.state', { state: true });
                        this._session = session;
                        this.sessionFocusEvent.raiseEvent({
                            previous: previousFocussedSession,
                            current: session
                        });
                    }
                };
                FocusService.prototype.whenSessionHasFocus = function (session) {
                    var _this = this;
                    this.sessionService.ensureIsRealityManager();
                    return new Promise(function (resolve) {
                        var remove = _this.sessionFocusEvent.addEventListener(function (_a) {
                            var current = _a.current;
                            if (current === session) {
                                remove();
                                resolve();
                            }
                        });
                    });
                };
                FocusService.prototype._setFocus = function (state) {
                    if (this._hasFocus !== state) {
                        this._hasFocus = state;
                        if (state) {
                            this.focusEvent.raiseEvent(undefined);
                        } else {
                            this.blurEvent.raiseEvent(undefined);
                        }
                    }
                };
                FocusService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService)], FocusService);
                return FocusService;
            }();
            exports_1("FocusService", FocusService);
        }
    };
});
$__System.registerDynamic('1f', ['c'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaPal) {
    'use strict';

    exports.__esModule = true;

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }return target;
    };

    exports.decorators = decorators;
    exports.deprecated = deprecated;
    exports.mixin = mixin;
    exports.protocol = protocol;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var metadata = {
      resource: 'aurelia:resource',
      paramTypes: 'design:paramtypes',
      properties: 'design:properties',
      get: function get(metadataKey, target, targetKey) {
        if (!target) {
          return undefined;
        }
        var result = metadata.getOwn(metadataKey, target, targetKey);
        return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
      },
      getOwn: function getOwn(metadataKey, target, targetKey) {
        if (!target) {
          return undefined;
        }
        return Reflect.getOwnMetadata(metadataKey, target, targetKey);
      },
      define: function define(metadataKey, metadataValue, target, targetKey) {
        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
      },
      getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
        var result = metadata.getOwn(metadataKey, target, targetKey);

        if (result === undefined) {
          result = new Type();
          Reflect.defineMetadata(metadataKey, result, target, targetKey);
        }

        return result;
      }
    };

    exports.metadata = metadata;
    var originStorage = new Map();
    var unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

    var Origin = function () {
      function Origin(moduleId, moduleMember) {
        _classCallCheck(this, Origin);

        this.moduleId = moduleId;
        this.moduleMember = moduleMember;
      }

      Origin.get = function get(fn) {
        var origin = originStorage.get(fn);

        if (origin === undefined) {
          _aureliaPal.PLATFORM.eachModule(function (key, value) {
            for (var _name in value) {
              var exp = value[_name];
              if (exp === fn) {
                originStorage.set(fn, origin = new Origin(key, _name));
                return true;
              }
            }

            if (value === fn) {
              originStorage.set(fn, origin = new Origin(key, 'default'));
              return true;
            }
          });
        }

        return origin || unknownOrigin;
      };

      Origin.set = function set(fn, origin) {
        originStorage.set(fn, origin);
      };

      return Origin;
    }();

    exports.Origin = Origin;

    function decorators() {
      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      var applicator = function applicator(target, key, descriptor) {
        var i = rest.length;

        if (key) {
          descriptor = descriptor || {
            value: target[key],
            writable: true,
            configurable: true,
            enumerable: true
          };

          while (i--) {
            descriptor = rest[i](target, key, descriptor) || descriptor;
          }

          Object.defineProperty(target, key, descriptor);
        } else {
          while (i--) {
            target = rest[i](target) || target;
          }
        }

        return target;
      };

      applicator.on = applicator;
      return applicator;
    }

    function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
      function decorator(target, key, descriptor) {
        var methodSignature = target.constructor.name + '#' + key;
        var options = maybeKey ? {} : optionsOrTarget || {};
        var message = 'DEPRECATION - ' + methodSignature;

        if (typeof descriptor.value !== 'function') {
          throw new SyntaxError('Only methods can be marked as deprecated.');
        }

        if (options.message) {
          message += ' - ' + options.message;
        }

        return _extends({}, descriptor, {
          value: function deprecationWrapper() {
            if (options.error) {
              throw new Error(message);
            } else {
              console.warn(message);
            }

            return descriptor.value.apply(this, arguments);
          }
        });
      }

      return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
    }

    function mixin(behavior) {
      var instanceKeys = Object.keys(behavior);

      function _mixin(possible) {
        var decorator = function decorator(target) {
          var resolvedTarget = typeof target === 'function' ? target.prototype : target;

          for (var _iterator = instanceKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var property = _ref;

            Object.defineProperty(resolvedTarget, property, {
              value: behavior[property],
              writable: true
            });
          }
        };

        return possible ? decorator(possible) : decorator;
      }

      return _mixin;
    }

    function alwaysValid() {
      return true;
    }
    function noCompose() {}

    function ensureProtocolOptions(options) {
      if (options === undefined) {
        options = {};
      } else if (typeof options === 'function') {
        options = {
          validate: options
        };
      }

      if (!options.validate) {
        options.validate = alwaysValid;
      }

      if (!options.compose) {
        options.compose = noCompose;
      }

      return options;
    }

    function createProtocolValidator(validate) {
      return function (target) {
        var result = validate(target);
        return result === true;
      };
    }

    function createProtocolAsserter(name, validate) {
      return function (target) {
        var result = validate(target);
        if (result !== true) {
          throw new Error(result || name + ' was not correctly implemented.');
        }
      };
    }

    function protocol(name, options) {
      options = ensureProtocolOptions(options);

      var result = function result(target) {
        var resolvedTarget = typeof target === 'function' ? target.prototype : target;

        options.compose(resolvedTarget);
        result.assert(resolvedTarget);

        Object.defineProperty(resolvedTarget, 'protocol:' + name, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: true
        });
      };

      result.validate = createProtocolValidator(options.validate);
      result.assert = createProtocolAsserter(name, options.validate);

      return result;
    }

    protocol.create = function (name, options) {
      options = ensureProtocolOptions(options);
      var hidden = 'protocol:' + name;
      var result = function result(target) {
        var decorator = protocol(name, options);
        return target ? decorator(target) : decorator;
      };

      result.decorates = function (obj) {
        return obj[hidden] === true;
      };
      result.validate = createProtocolValidator(options.validate);
      result.assert = createProtocolAsserter(name, options.validate);

      return result;
    };
  }).call($__exports, $__exports, $__require('c'));
});
$__System.registerDynamic('c', [], false, function ($__require, $__exports, $__module) {
  return (function (exports) {
    'use strict';

    exports.__esModule = true;
    exports.AggregateError = AggregateError;
    exports.initializePAL = initializePAL;

    function AggregateError(message, innerError, skipIfAlreadyAggregate) {
      if (innerError) {
        if (innerError.innerError && skipIfAlreadyAggregate) {
          return innerError;
        }

        if (innerError.stack) {
          message += '\n------------------------------------------------\ninner error: ' + innerError.stack;
        }
      }

      var e = new Error(message);
      if (innerError) {
        e.innerError = innerError;
      }

      return e;
    }

    var FEATURE = {};

    exports.FEATURE = FEATURE;
    var PLATFORM = {
      noop: function noop() {},
      eachModule: function eachModule() {}
    };

    exports.PLATFORM = PLATFORM;
    PLATFORM.global = function () {
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof global !== 'undefined') {
        return global;
      }

      return new Function('return this')();
    }();

    var DOM = {};

    exports.DOM = DOM;

    function initializePAL(callback) {
      if (typeof Object.getPropertyDescriptor !== 'function') {
        Object.getPropertyDescriptor = function (subject, name) {
          var pd = Object.getOwnPropertyDescriptor(subject, name);
          var proto = Object.getPrototypeOf(subject);
          while (typeof pd === 'undefined' && proto !== null) {
            pd = Object.getOwnPropertyDescriptor(proto, name);
            proto = Object.getPrototypeOf(proto);
          }
          return pd;
        };
      }

      callback(PLATFORM, FEATURE, DOM);
    }
  }).call($__exports, $__exports, $__require);
});
$__System.registerDynamic('15', ['1f', 'c'], false, function ($__require, $__exports, $__module) {
  return (function (exports, _aureliaMetadata, _aureliaPal) {
    'use strict';

    exports.__esModule = true;

    var _classInvokers;

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
      }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
      };
    }();

    exports.invoker = invoker;
    exports.factory = factory;
    exports.registration = registration;
    exports.transient = transient;
    exports.singleton = singleton;
    exports.autoinject = autoinject;
    exports.inject = inject;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function (target) {
      if (!(typeof target.get === 'function')) {
        return 'Resolvers must implement: get(container: Container, key: any): any';
      }

      return true;
    });

    exports.resolver = resolver;

    var Lazy = function () {
      function Lazy(key) {
        _classCallCheck(this, _Lazy);

        this._key = key;
      }

      Lazy.prototype.get = function get(container) {
        var _this = this;

        return function () {
          return container.get(_this._key);
        };
      };

      Lazy.of = function of(key) {
        return new Lazy(key);
      };

      var _Lazy = Lazy;
      Lazy = resolver()(Lazy) || Lazy;
      return Lazy;
    }();

    exports.Lazy = Lazy;

    var All = function () {
      function All(key) {
        _classCallCheck(this, _All);

        this._key = key;
      }

      All.prototype.get = function get(container) {
        return container.getAll(this._key);
      };

      All.of = function of(key) {
        return new All(key);
      };

      var _All = All;
      All = resolver()(All) || All;
      return All;
    }();

    exports.All = All;

    var Optional = function () {
      function Optional(key) {
        var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        _classCallCheck(this, _Optional);

        this._key = key;
        this._checkParent = checkParent;
      }

      Optional.prototype.get = function get(container) {
        if (container.hasResolver(this._key, this._checkParent)) {
          return container.get(this._key);
        }

        return null;
      };

      Optional.of = function of(key) {
        var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        return new Optional(key, checkParent);
      };

      var _Optional = Optional;
      Optional = resolver()(Optional) || Optional;
      return Optional;
    }();

    exports.Optional = Optional;

    var Parent = function () {
      function Parent(key) {
        _classCallCheck(this, _Parent);

        this._key = key;
      }

      Parent.prototype.get = function get(container) {
        return container.parent ? container.parent.get(this._key) : null;
      };

      Parent.of = function of(key) {
        return new Parent(key);
      };

      var _Parent = Parent;
      Parent = resolver()(Parent) || Parent;
      return Parent;
    }();

    exports.Parent = Parent;

    var StrategyResolver = function () {
      function StrategyResolver(strategy, state) {
        _classCallCheck(this, _StrategyResolver);

        this.strategy = strategy;
        this.state = state;
      }

      StrategyResolver.prototype.get = function get(container, key) {
        switch (this.strategy) {
          case 0:
            return this.state;
          case 1:
            var singleton = container.invoke(this.state);
            this.state = singleton;
            this.strategy = 0;
            return singleton;
          case 2:
            return container.invoke(this.state);
          case 3:
            return this.state(container, key, this);
          case 4:
            return this.state[0].get(container, key);
          case 5:
            return container.get(this.state);
          default:
            throw new Error('Invalid strategy: ' + this.strategy);
        }
      };

      var _StrategyResolver = StrategyResolver;
      StrategyResolver = resolver()(StrategyResolver) || StrategyResolver;
      return StrategyResolver;
    }();

    exports.StrategyResolver = StrategyResolver;

    function invoker(value) {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
      };
    }

    function factory(potentialTarget) {
      var deco = function deco(target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
      };

      return potentialTarget ? deco(potentialTarget) : deco;
    }

    var FactoryInvoker = function () {
      function FactoryInvoker() {
        _classCallCheck(this, FactoryInvoker);
      }

      FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
        var i = dependencies.length;
        var args = new Array(i);

        while (i--) {
          args[i] = container.get(dependencies[i]);
        }

        return fn.apply(undefined, args);
      };

      FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
        var i = staticDependencies.length;
        var args = new Array(i);

        while (i--) {
          args[i] = container.get(staticDependencies[i]);
        }

        if (dynamicDependencies !== undefined) {
          args = args.concat(dynamicDependencies);
        }

        return fn.apply(undefined, args);
      };

      _createClass(FactoryInvoker, null, [{
        key: 'instance',
        value: new FactoryInvoker(),
        enumerable: true
      }]);

      return FactoryInvoker;
    }();

    exports.FactoryInvoker = FactoryInvoker;

    function registration(value) {
      return function (target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
      };
    }

    function transient(key) {
      return registration(new TransientRegistration(key));
    }

    function singleton(keyOrRegisterInChild) {
      var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
    }

    var TransientRegistration = function () {
      function TransientRegistration(key) {
        _classCallCheck(this, TransientRegistration);

        this._key = key;
      }

      TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
        var resolver = new StrategyResolver(2, fn);
        container.registerResolver(this._key || key, resolver);
        return resolver;
      };

      return TransientRegistration;
    }();

    exports.TransientRegistration = TransientRegistration;

    var SingletonRegistration = function () {
      function SingletonRegistration(keyOrRegisterInChild) {
        var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        _classCallCheck(this, SingletonRegistration);

        if (typeof keyOrRegisterInChild === 'boolean') {
          this._registerInChild = keyOrRegisterInChild;
        } else {
          this._key = keyOrRegisterInChild;
          this._registerInChild = registerInChild;
        }
      }

      SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
        var resolver = new StrategyResolver(1, fn);

        if (this._registerInChild) {
          container.registerResolver(this._key || key, resolver);
        } else {
          container.root.registerResolver(this._key || key, resolver);
        }

        return resolver;
      };

      return SingletonRegistration;
    }();

    exports.SingletonRegistration = SingletonRegistration;

    var badKeyError = 'key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?';
    var _emptyParameters = Object.freeze([]);

    exports._emptyParameters = _emptyParameters;
    _aureliaMetadata.metadata.registration = 'aurelia:registration';
    _aureliaMetadata.metadata.invoker = 'aurelia:invoker';

    var resolverDecorates = resolver.decorates;

    var InvocationHandler = function () {
      function InvocationHandler(fn, invoker, dependencies) {
        _classCallCheck(this, InvocationHandler);

        this.fn = fn;
        this.invoker = invoker;
        this.dependencies = dependencies;
      }

      InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
        return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
      };

      return InvocationHandler;
    }();

    exports.InvocationHandler = InvocationHandler;

    function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
      var i = staticDependencies.length;
      var args = new Array(i);

      while (i--) {
        args[i] = container.get(staticDependencies[i]);
      }

      if (dynamicDependencies !== undefined) {
        args = args.concat(dynamicDependencies);
      }

      return Reflect.construct(fn, args);
    }

    var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
      invoke: function invoke(container, Type) {
        return new Type();
      },
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[1] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]));
      },
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[2] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]));
      },
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[3] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
      },
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[4] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
      },
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers[5] = {
      invoke: function invoke(container, Type, deps) {
        return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
      },
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers.fallback = {
      invoke: invokeWithDynamicDependencies,
      invokeWithDynamicDependencies: invokeWithDynamicDependencies
    }, _classInvokers);

    var Container = function () {
      function Container(configuration) {
        _classCallCheck(this, Container);

        if (configuration === undefined) {
          configuration = {};
        }

        this._configuration = configuration;
        this._onHandlerCreated = configuration.onHandlerCreated;
        this._handlers = configuration.handlers || (configuration.handlers = new Map());
        this._resolvers = new Map();
        this.root = this;
        this.parent = null;
      }

      Container.prototype.makeGlobal = function makeGlobal() {
        Container.instance = this;
        return this;
      };

      Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
        this._onHandlerCreated = onHandlerCreated;
        this._configuration.onHandlerCreated = onHandlerCreated;
      };

      Container.prototype.registerInstance = function registerInstance(key, instance) {
        this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
      };

      Container.prototype.registerSingleton = function registerSingleton(key, fn) {
        this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
      };

      Container.prototype.registerTransient = function registerTransient(key, fn) {
        this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
      };

      Container.prototype.registerHandler = function registerHandler(key, handler) {
        this.registerResolver(key, new StrategyResolver(3, handler));
      };

      Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
        this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
      };

      Container.prototype.registerResolver = function registerResolver(key, resolver) {
        if (key === null || key === undefined) {
          throw new Error(badKeyError);
        }

        var allResolvers = this._resolvers;
        var result = allResolvers.get(key);

        if (result === undefined) {
          allResolvers.set(key, resolver);
        } else if (result.strategy === 4) {
          result.state.push(resolver);
        } else {
          allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
        }
      };

      Container.prototype.autoRegister = function autoRegister(fn, key) {
        var resolver = undefined;

        if (typeof fn === 'function') {
          var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);

          if (_registration === undefined) {
            resolver = new StrategyResolver(1, fn);
            this.registerResolver(key === undefined ? fn : key, resolver);
          } else {
            resolver = _registration.registerResolver(this, key === undefined ? fn : key, fn);
          }
        } else {
          resolver = new StrategyResolver(0, fn);
          this.registerResolver(key === undefined ? fn : key, resolver);
        }

        return resolver;
      };

      Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
        var i = fns.length;
        while (i--) {
          this.autoRegister(fns[i]);
        }
      };

      Container.prototype.unregister = function unregister(key) {
        this._resolvers['delete'](key);
      };

      Container.prototype.hasResolver = function hasResolver(key) {
        var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        if (key === null || key === undefined) {
          throw new Error(badKeyError);
        }

        return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
      };

      Container.prototype.get = function get(key) {
        if (key === null || key === undefined) {
          throw new Error(badKeyError);
        }

        if (key === Container) {
          return this;
        }

        if (resolverDecorates(key)) {
          return key.get(this, key);
        }

        var resolver = this._resolvers.get(key);

        if (resolver === undefined) {
          if (this.parent === null) {
            return this.autoRegister(key).get(this, key);
          }

          return this.parent._get(key);
        }

        return resolver.get(this, key);
      };

      Container.prototype._get = function _get(key) {
        var resolver = this._resolvers.get(key);

        if (resolver === undefined) {
          if (this.parent === null) {
            return this.autoRegister(key).get(this, key);
          }

          return this.parent._get(key);
        }

        return resolver.get(this, key);
      };

      Container.prototype.getAll = function getAll(key) {
        if (key === null || key === undefined) {
          throw new Error(badKeyError);
        }

        var resolver = this._resolvers.get(key);

        if (resolver === undefined) {
          if (this.parent === null) {
            return _emptyParameters;
          }

          return this.parent.getAll(key);
        }

        if (resolver.strategy === 4) {
          var state = resolver.state;
          var i = state.length;
          var results = new Array(i);

          while (i--) {
            results[i] = state[i].get(this, key);
          }

          return results;
        }

        return [resolver.get(this, key)];
      };

      Container.prototype.createChild = function createChild() {
        var child = new Container(this._configuration);
        child.root = this.root;
        child.parent = this;
        return child;
      };

      Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
        try {
          var _handler = this._handlers.get(fn);

          if (_handler === undefined) {
            _handler = this._createInvocationHandler(fn);
            this._handlers.set(fn, _handler);
          }

          return _handler.invoke(this, dynamicDependencies);
        } catch (e) {
          throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
        }
      };

      Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
        var dependencies = undefined;

        if (typeof fn.inject === 'function') {
          dependencies = fn.inject();
        } else if (fn.inject === undefined) {
          dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
        } else {
          dependencies = fn.inject;
        }

        var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;

        var handler = new InvocationHandler(fn, invoker, dependencies);
        return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
      };

      return Container;
    }();

    exports.Container = Container;

    function autoinject(potentialTarget) {
      var deco = function deco(target) {
        target.inject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
      };

      return potentialTarget ? deco(potentialTarget) : deco;
    }

    function inject() {
      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      return function (target, key, descriptor) {
        if (descriptor) {
          var _fn = descriptor.value;
          _fn.inject = rest;
        } else {
          target.inject = rest;
        }
      };
    }
  }).call($__exports, $__exports, $__require('1f'), $__require('c'));
});
$__System.register("18", [], function (exports_1, context_1) {
  "use strict";

  var __moduleName = context_1 && context_1.id;
  var Role, SubviewType, RealityView;
  return {
    setters: [],
    execute: function () {
      /**
       * Describes the role of an [[ArgonSystem]]
       */
      (function (Role) {
        /**
         * A system with this role is responsible for augmenting an arbitrary view of reality,
         * generally by overlaying computer generated graphics. A reality augmentor may also,
         * if appropriate, be elevated to the role of a [[REALITY_MANAGER]].
         */
        Role[Role["REALITY_AUGMENTOR"] = "RealityAugmentor"] = "REALITY_AUGMENTOR";
        /**
         * A system with this role is responsible for (at minimum) describing (and providing,
         * if necessary) a visual representation of the world and the 3D eye pose of the viewer.
         */
        Role[Role["REALITY_VIEW"] = "RealityView"] = "REALITY_VIEW";
        /**
         * A system with this role is responsible for mediating access to sensors/trackers
         * and pose data for known entities in the world, selecting/configuring/loading
         * [[REALITY_VIEW]]s, and providing the mechanism by which any given [[REALITY_AUGMENTOR]]
         * can augment any given [[REALITY_VIEW]]. The reality manager may also, when appropriate,
         * take on the role of [[REALITY_AUGMENTOR]].
         */
        Role[Role["REALITY_MANAGER"] = "RealityManager"] = "REALITY_MANAGER";
        /**
         * Deprecated. Use [[REALITY_AUGMENTOR]].
         * @private
         */
        Role[Role["APPLICATION"] = "Application"] = "APPLICATION";
        /**
         * Deprecated. Use [[REALITY_MANAGER]].
         * @private
         */
        Role[Role["MANAGER"] = "Manager"] = "MANAGER";
      })(Role || (Role = {}));
      exports_1("Role", Role);
      /**
       * Identifies a subview in a [[SerializedSubview]]
       */
      (function (SubviewType) {
        /*
         * Identities a subview for a handheld display.
         */
        SubviewType[SubviewType["SINGULAR"] = "Singular"] = "SINGULAR";
        /*
         * Identifies a subview for the left eye (when the user is wearing an HMD or Viewer)
         */
        SubviewType[SubviewType["LEFTEYE"] = "LeftEye"] = "LEFTEYE";
        /*
         * Identifies a subview for the right eye (when the user is wearing an HMD or Viewer)
         */
        SubviewType[SubviewType["RIGHTEYE"] = "RightEye"] = "RIGHTEYE";
        /*
         * Identifies a subview for a custom view configuration
         */
        SubviewType[SubviewType["OTHER"] = "Other"] = "OTHER";
      })(SubviewType || (SubviewType = {}));
      exports_1("SubviewType", SubviewType);
      /**
      * Represents a view of Reality
      */
      RealityView = function () {
        function RealityView() {}
        RealityView.getType = function (reality) {
          var uri = reality.uri;
          var parts = uri.split(':');
          if (parts[0] === 'reality') {
            return parts[1];
          }
          return 'hosted';
        };
        RealityView.EMPTY = {
          uri: 'reality:empty',
          title: 'Reality',
          providedReferenceFrames: ['FIXED']
        };
        return RealityView;
      }();
      exports_1("RealityView", RealityView);
    }
  };
});
$__System.register('19', ['13', '15', '18', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var cesium_imports_1, aurelia_dependency_injection_1, common_1, utils_1;
    var SessionPort, SessionPortFactory, ConnectService, SessionService, LoopbackConnectService, DOMConnectService, DebugConnectService, WKWebViewConnectService;
    return {
        setters: [function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }, function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (common_1_1) {
            common_1 = common_1_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }],
        execute: function () {
            ;
            /**
             * Provides two-way communication between two [[SessionPort]] instances.
             */
            SessionPort = function () {
                function SessionPort(uri) {
                    var _this = this;
                    this.uri = uri;
                    this._connectEvent = new utils_1.Event();
                    /**
                     * An event which fires when this port has closed
                     */
                    this.closeEvent = new utils_1.Event();
                    /**
                     * An error which fires when an error occurs.
                     */
                    this.errorEvent = new utils_1.Event();
                    /**
                     * A map from topic to message handler.
                     */
                    this.on = {};
                    this._isOpened = false;
                    this._isConnected = false;
                    this._isClosed = false;
                    this.on[SessionPort.OPEN] = function (info) {
                        if (!info) throw new Error('Session did not provide a configuration');
                        if (_this._isConnected) throw new Error('Session has already connected!');
                        _this.info = info;
                        _this._isConnected = true;
                        _this._connectEvent.raiseEvent(undefined);
                    };
                    this.on[SessionPort.CLOSE] = function () {
                        _this._isClosed = true;
                        _this._isConnected = false;
                        if (_this.messagePort && _this.messagePort.close) _this.messagePort.close();
                        _this.closeEvent.raiseEvent(undefined);
                    };
                    this.on[SessionPort.ERROR] = function (error) {
                        var e = new Error("Session Error: " + error.message);
                        if (error.stack) e['stack'] = error.stack;
                        _this.errorEvent.raiseEvent(e);
                    };
                    this.errorEvent.addEventListener(function (error) {
                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
                    });
                }
                Object.defineProperty(SessionPort.prototype, "connectEvent", {
                    /**
                     * An event which fires when a connection has been
                     * established to the other [[SessionPort]].
                     */
                    get: function () {
                        if (this._isConnected) throw new Error('The connectEvent only fires once and the session is already connected.');
                        return this._connectEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                ;
                /**
                 * Check if a protocol is supported by this session.
                 */
                SessionPort.prototype.supportsProtocol = function (name, versions) {
                    if (!this._isConnected) throw new Error('Session has not yet connected');
                    var protocols = this.info.protocols;
                    if (!protocols) return false;
                    var supported = false;
                    var foundVersions = new Set();
                    protocols.forEach(function (p) {
                        if (p.indexOf(name) !== -1) {
                            var v = +p.split('@v')[1] || 0;
                            foundVersions.add(v);
                        }
                    });
                    if (versions) {
                        if (Array.isArray(versions)) {
                            versions.forEach(function (v) {
                                if (foundVersions.has(v)) {
                                    supported = true;
                                }
                            });
                        } else {
                            if (foundVersions.has(versions)) {
                                supported = true;
                            }
                        }
                    } else if (!versions) {
                        supported = true;
                    }
                    return supported;
                };
                /**
                 * Establish a connection to another [[SessionPort]] via the provided [[MessagePort]] instance.
                 * @param messagePort the message port to post and receive messages.
                 * @param options the configuration which describes this [[ArgonSystem]].
                 */
                SessionPort.prototype.open = function (messagePort, options) {
                    var _this = this;
                    if (this._isClosed) return;
                    if (this._isOpened) throw new Error('Session can only be opened once');
                    if (!options) throw new Error('Session options must be provided');
                    this.messagePort = messagePort;
                    this._isOpened = true;
                    this.messagePort.onmessage = function (evt) {
                        if (_this._isClosed) return;
                        var id = evt.data[0];
                        var topic = evt.data[1];
                        var message = evt.data[2] || {};
                        var expectsResponse = evt.data[3];
                        var handler = _this.on[topic];
                        if (handler && !expectsResponse) {
                            try {
                                var response = handler(message, evt);
                                if (response) console.warn("Handler for " + topic + " returned an unexpected response");
                            } catch (e) {
                                _this.sendError(e);
                                _this.errorEvent.raiseEvent(e);
                            }
                        } else if (handler) {
                            var response = new Promise(function (resolve) {
                                return resolve(handler(message, evt));
                            });
                            Promise.resolve(response).then(function (response) {
                                if (_this._isClosed) return;
                                _this.send(topic + ':resolve:' + id, response);
                            }).catch(function (error) {
                                if (_this._isClosed) return;
                                var errorMessage;
                                if (typeof error === 'string') errorMessage = error;else if (typeof error.message === 'string') errorMessage = error.message;
                                _this.send(topic + ':reject:' + id, { reason: errorMessage });
                            });
                        } else {
                            var errorMessage = 'Unable to handle message ' + topic;
                            if (expectsResponse) {
                                _this.send(topic + ':reject:' + id, { reason: errorMessage });
                            } else {
                                _this.sendError({ message: errorMessage });
                            }
                            _this.errorEvent.raiseEvent(new Error('No handlers are available for topic ' + topic));
                        }
                    };
                    this.send(SessionPort.OPEN, options);
                };
                /**
                 * Send a message
                 * @param topic the message topic.
                 * @param message the message to be sent.
                 * @return Return true if the message is posted successfully,
                 * return false if the session is closed.
                 */
                SessionPort.prototype.send = function (topic, message) {
                    if (!this._isOpened) throw new Error('Session must be open to send messages');
                    if (this._isClosed) return false;
                    var id = cesium_imports_1.createGuid();
                    this.messagePort.postMessage([id, topic, message]);
                    return true;
                };
                /**
                 * Send an error message.
                 * @param errorMessage An error message.
                 * @return Return true if the error message is sent successfully,
                 * otherwise, return false.
                 */
                SessionPort.prototype.sendError = function (e) {
                    var errorMessage = e;
                    if (errorMessage instanceof Error) {
                        errorMessage = {
                            message: errorMessage.message,
                            stack: errorMessage['stack']
                        };
                    }
                    return this.send(SessionPort.ERROR, errorMessage);
                };
                /**
                 * Send a request and return a promise for the result.
                 * @param topic the message topic.
                 * @param message the message to be sent.
                 * @return if the session is not opened or is closed, return a rejected promise,
                 * Otherwise, the returned promise is resolved or rejected based on the response.
                 */
                SessionPort.prototype.request = function (topic, message) {
                    var _this = this;
                    if (!this._isOpened || this._isClosed) throw new Error('Session must be open to make requests');
                    var id = cesium_imports_1.createGuid();
                    var resolveTopic = topic + ':resolve:' + id;
                    var rejectTopic = topic + ':reject:' + id;
                    var result = new Promise(function (resolve, reject) {
                        _this.on[resolveTopic] = function (message) {
                            delete _this.on[resolveTopic];
                            delete _this.on[rejectTopic];
                            resolve(message);
                        };
                        _this.on[rejectTopic] = function (message) {
                            delete _this.on[resolveTopic];
                            delete _this.on[rejectTopic];
                            console.warn("Request '" + topic + "' rejected with reason:\n" + message.reason);
                            reject(new Error(message.reason));
                        };
                    });
                    this.messagePort.postMessage([id, topic, message || {}, true]);
                    return result;
                };
                /**
                 * Close the connection to the remote session.
                 */
                SessionPort.prototype.close = function () {
                    if (this._isClosed) return;
                    if (this._isOpened) {
                        this.send(SessionPort.CLOSE);
                    }
                    this._isClosed = true;
                    this._isConnected = false;
                    if (this.messagePort && this.messagePort.close) this.messagePort.close();
                    this.closeEvent.raiseEvent(undefined);
                };
                Object.defineProperty(SessionPort.prototype, "isConnected", {
                    get: function () {
                        return this._isConnected;
                    },
                    enumerable: true,
                    configurable: true
                });
                SessionPort.OPEN = 'ar.session.open';
                SessionPort.CLOSE = 'ar.session.close';
                SessionPort.ERROR = 'ar.session.error';
                return SessionPort;
            }();
            exports_1("SessionPort", SessionPort);
            /**
             * A factory for creating [[SessionPort]] instances.
             */
            SessionPortFactory = function () {
                function SessionPortFactory() {}
                SessionPortFactory.prototype.create = function (uri) {
                    return new SessionPort(uri);
                };
                return SessionPortFactory;
            }();
            exports_1("SessionPortFactory", SessionPortFactory);
            /**
             * A service for establishing a connection to the [[REALITY_MANAGER]].
             */
            ConnectService = function () {
                function ConnectService() {}
                return ConnectService;
            }();
            exports_1("ConnectService", ConnectService);
            /**
             * A service for managing connections to other ArgonSystem instances
             */
            SessionService = function () {
                function SessionService(
                /**
                 * The configuration of this [[ArgonSystem]]
                 */
                configuration, connectService, sessionPortFactory, messageChannelFactory) {
                    var _this = this;
                    this.configuration = configuration;
                    this.connectService = connectService;
                    this.sessionPortFactory = sessionPortFactory;
                    this.messageChannelFactory = messageChannelFactory;
                    /**
                     * The port which handles communication between this session and the manager session.
                     */
                    this.manager = this.createSessionPort('argon:manager');
                    /**
                     * An event that is raised when an error occurs.
                     */
                    this.errorEvent = new utils_1.Event();
                    this._connectEvent = new utils_1.Event();
                    this._managedSessions = [];
                    this.errorEvent.addEventListener(function (error) {
                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
                    });
                    this.manager.errorEvent.addEventListener(function (error) {
                        _this.errorEvent.raiseEvent(error);
                    });
                    Object.freeze(this);
                }
                Object.defineProperty(SessionService.prototype, "connectEvent", {
                    /**
                     * An event that is raised when a managed session is opened.
                     */
                    get: function () {
                        return this._connectEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                ;
                Object.defineProperty(SessionService.prototype, "managedSessions", {
                    /**
                     * Manager-only. A collection of ports for the sessions managed by this session.
                     */
                    get: function () {
                        this.ensureIsRealityManager();
                        return this._managedSessions;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Establishes a connection with the [[REALITY_MANAGER]].
                 * Called internally by the composition root ([[ArgonSystem]]).
                 */
                SessionService.prototype.connect = function () {
                    if (this.connectService && this.connectService.connect) {
                        this.connectService.connect(this);
                    } else {
                        console.warn('Argon: Unable to connect to a manager session; a connect service is not available');
                    }
                };
                /**
                 * Manager-only. Creates a [[SessionPort]] that is managed by the current [[ArgonSystem]].
                 * Session ports that are managed will automatically forward open events to
                 * [[SessionService#sessionConnectEvent]] and error events to [[SessionService#errorEvent]].
                 * Other services that are part of the current [[ArgonSystem]] are likely to
                 * add message handlers to a newly connected [[SessionPort]].
                 * @return a new [[SessionPort]] instance
                 */
                SessionService.prototype.addManagedSessionPort = function (uri) {
                    var _this = this;
                    this.ensureIsRealityManager();
                    var session = this.sessionPortFactory.create(uri);
                    session.errorEvent.addEventListener(function (error) {
                        _this.errorEvent.raiseEvent(error);
                    });
                    session.connectEvent.addEventListener(function () {
                        _this.managedSessions.push(session);
                        _this.connectEvent.raiseEvent(session);
                    });
                    session.closeEvent.addEventListener(function () {
                        var index = _this.managedSessions.indexOf(session);
                        if (index > -1) _this.managedSessions.splice(index, 1);
                    });
                    return session;
                };
                /**
                 * Creates a [[SessionPort]] that is not managed by the current [[ArgonSystem]].
                 * Unmanaged session ports will not forward open events or error events
                 * to this [[ArgonSystem]].
                 * @return a new SessionPort instance
                 */
                SessionService.prototype.createSessionPort = function (uri) {
                    return this.sessionPortFactory.create(uri);
                };
                /**
                 * Creates a message channel which asyncrhonously sends and receives messages.
                 */
                SessionService.prototype.createMessageChannel = function () {
                    return this.messageChannelFactory.create();
                };
                /**
                 * Creates a message channel which syncrhonously sends and receives messages.
                 */
                SessionService.prototype.createSynchronousMessageChannel = function () {
                    return this.messageChannelFactory.createSynchronous();
                };
                Object.defineProperty(SessionService.prototype, "isRealityManager", {
                    /**
                     * Returns true if this system represents a [[REALITY_MANAGER]]
                     */
                    get: function () {
                        return this.configuration.role === common_1.Role.REALITY_MANAGER || this.configuration.role === common_1.Role.MANAGER; // TODO: phase out of using Role.MANAGER enum
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isRealityAugmenter", {
                    /**
                     * Returns true if this system represents a [[REALITY_AUGMENTOR]], meaning,
                     * it is running within a [[REALITY_MANAGER]]
                     */
                    get: function () {
                        return this.configuration.role === common_1.Role.REALITY_AUGMENTOR || this.configuration.role === common_1.Role.APPLICATION; // TODO: phase out use of Role.APPLICATION
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isRealityView", {
                    /**
                     * Returns true if this system is a [[REALITY_VIEW]]
                     */
                    get: function () {
                        return this.configuration.role === common_1.Role.REALITY_VIEW;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isManager", {
                    /**
                     * @private
                     */
                    get: function () {
                        console.warn("Deprecated. Use isRealityManager()");return this.isManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SessionService.prototype, "isApplication", {
                    /**
                     * @private
                     */
                    get: function () {
                        console.warn("Deprecated. Use isRealityAugmenter()");return this.isRealityAugmenter;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Throws an error if this system is not a [[REALITY_MANAGER]]
                 */
                SessionService.prototype.ensureIsRealityManager = function () {
                    if (!this.isRealityManager) throw new Error('An reality-manager only API was accessed from a non reality-manager.');
                };
                /**
                 * Throws an error if this session is not a [[REALITY_VIEW]]
                 */
                SessionService.prototype.ensureIsRealityView = function () {
                    if (!this.isRealityView) throw new Error('An reality-view only API was accessed from a non reality-view.');
                };
                /**
                 * Throws an error if this session is a [[REALITY_VIEW]]
                 */
                SessionService.prototype.ensureNotRealityView = function () {
                    if (this.isRealityView) throw new Error('An non-permitted API was accessed from a reality-view.');
                };
                SessionService = __decorate([aurelia_dependency_injection_1.inject('config', ConnectService, SessionPortFactory, utils_1.MessageChannelFactory)], SessionService);
                return SessionService;
            }();
            exports_1("SessionService", SessionService);
            /**
             * Connect the current [[ArgonSystem]] to itself as the [[REALITY_MANAGER]].
             */
            LoopbackConnectService = function (_super) {
                __extends(LoopbackConnectService, _super);
                function LoopbackConnectService() {
                    _super.apply(this, arguments);
                }
                /**
                 * Create a loopback connection.
                 */
                LoopbackConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createSynchronousMessageChannel();
                    var messagePort = messageChannel.port1;
                    messageChannel.port2.onmessage = function (evt) {
                        messageChannel.port2.postMessage(evt.data);
                    };
                    sessionService.manager.connectEvent.addEventListener(function () {
                        sessionService.connectEvent.raiseEvent(sessionService.manager);
                    });
                    sessionService.manager.open(messagePort, sessionService.configuration);
                };
                return LoopbackConnectService;
            }(ConnectService);
            exports_1("LoopbackConnectService", LoopbackConnectService);
            /**
             * Connect this [[ArgonSystem]] to the [[REALITY_MANAGER]] via the parent document
             * (assuming this system is running in an iFrame).
             */
            DOMConnectService = function (_super) {
                __extends(DOMConnectService, _super);
                function DOMConnectService() {
                    _super.apply(this, arguments);
                }
                /**
                  * Check whether this connect method is available or not.
                  */
                DOMConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && typeof window.parent !== 'undefined';
                };
                /**
                 * Connect to the manager.
                 */
                DOMConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createMessageChannel();
                    window.parent.postMessage({ type: 'ARGON_SESSION' }, '*', [messageChannel.port1]);
                    sessionService.manager.open(messageChannel.port2, sessionService.configuration);
                };
                return DOMConnectService;
            }(ConnectService);
            exports_1("DOMConnectService", DOMConnectService);
            /**
             * Connect this system to a remote manager for debugging.
             */
            DebugConnectService = function (_super) {
                __extends(DebugConnectService, _super);
                function DebugConnectService() {
                    _super.apply(this, arguments);
                }
                /**
                 * Check whether this connect method is available or not.
                 */
                DebugConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && !!window['__ARGON_DEBUG_PORT__'];
                };
                /**
                 * Connect to the manager.
                 */
                DebugConnectService.prototype.connect = function (_a) {
                    var manager = _a.manager,
                        configuration = _a.configuration;
                    manager.open(window['__ARGON_DEBUG_PORT__'], configuration);
                };
                return DebugConnectService;
            }(ConnectService);
            exports_1("DebugConnectService", DebugConnectService);
            /**
             * A service which connects this system to the [[REALITY_MANAGER]] via a WKWebview message handler.
             */
            WKWebViewConnectService = function (_super) {
                __extends(WKWebViewConnectService, _super);
                function WKWebViewConnectService() {
                    _super.apply(this, arguments);
                }
                /**
                 * Check whether this connect method is available or not.
                 */
                WKWebViewConnectService.isAvailable = function () {
                    return typeof window !== 'undefined' && window['webkit'] && window['webkit'].messageHandlers;
                };
                /**
                 * Connect to the manager.
                 */
                WKWebViewConnectService.prototype.connect = function (sessionService) {
                    var messageChannel = sessionService.createSynchronousMessageChannel();
                    messageChannel.port2.onmessage = function (event) {
                        webkit.messageHandlers.argon.postMessage(JSON.stringify(event.data));
                    };
                    window['__ARGON_PORT__'] = messageChannel.port2;
                    sessionService.manager.open(messageChannel.port1, sessionService.configuration);
                    window.addEventListener("beforeunload", function () {
                        sessionService.manager.close();
                    });
                };
                return WKWebViewConnectService;
            }(ConnectService);
            exports_1("WKWebViewConnectService", WKWebViewConnectService);
        }
    };
});
$__System.register('1a', ['15', '13', '18', '1d', '19', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, cesium_imports_1, common_1, focus_1, session_1, utils_1;
    var RealityLoader, RealityZoomState, RealityService;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }, function (common_1_1) {
            common_1 = common_1_1;
        }, function (focus_1_1) {
            focus_1 = focus_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }],
        execute: function () {
            /**
             * Abstract class for a reality setup handler
             */
            RealityLoader = function () {
                function RealityLoader() {}
                return RealityLoader;
            }();
            exports_1("RealityLoader", RealityLoader);
            (function (RealityZoomState) {
                RealityZoomState[RealityZoomState["OTHER"] = 0] = "OTHER";
                RealityZoomState[RealityZoomState["START"] = 1] = "START";
                RealityZoomState[RealityZoomState["CHANGE"] = 2] = "CHANGE";
                RealityZoomState[RealityZoomState["END"] = 3] = "END";
            })(RealityZoomState || (RealityZoomState = {}));
            exports_1("RealityZoomState", RealityZoomState);
            /**
            * A service which manages the reality view.
            * For an app developer, the RealityService instance can be used to
            * set preferences which can affect how the manager selects a reality view.
            */
            RealityService = function () {
                function RealityService(sessionService, focusService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.focusService = focusService;
                    /**
                     * A collection of known reality views from which the reality service can select.
                     */
                    this.realities = new Array();
                    /**
                     * An event that is raised when a reality control port is opened.
                     */
                    this.connectEvent = new utils_1.Event();
                    /**
                     * Manager-only. An event that is raised when the current reality is changed.
                     */
                    this._changeEvent = new utils_1.Event();
                    /**
                     * Manager-only. An event that is raised when the current reality emits the next frame state.
                     * This event contains pose updates for the entities that are managed by
                     * the current reality.
                     */
                    this._frameEvent = new utils_1.Event();
                    /**
                     * Manager-only. A map from a managed session to the desired reality
                     */
                    this.desiredRealityMap = new WeakMap();
                    /**
                     * Manager-only. A map from a desired reality to the session which requested it
                     */
                    this.desiredRealityMapInverse = new WeakMap();
                    /**
                     * Manager-only. An event that is raised when a session changes it's desired reality.
                     */
                    this.sessionDesiredRealityChangeEvent = new utils_1.Event();
                    // RealitySetupHandlers
                    this._loaders = [];
                    this._defaultFov = Math.PI / 2;
                    this._scratchFrustum = new cesium_imports_1.PerspectiveFrustum();
                    this._scratchArray = new Array();
                    this._loadID = -1;
                    if (sessionService.isRealityManager) {
                        sessionService.manager.connectEvent.addEventListener(function () {
                            setTimeout(function () {
                                if (_this._loadID === -1) _this._setNextReality(_this.onSelectReality());
                            });
                        });
                    }
                    sessionService.connectEvent.addEventListener(function (session) {
                        if (session.info.role !== common_1.Role.REALITY_VIEW) {
                            session.on['ar.reality.desired'] = function (message) {
                                var reality = message.reality;
                                var previous = _this.desiredRealityMap.get(session);
                                console.log('Session set desired reality: ' + JSON.stringify(reality));
                                if (reality) {
                                    if (reality['type']) {
                                        var type = reality['type'];
                                        reality.uri = reality.uri || 'reality:' + type;
                                        if (type === 'hosted') reality.uri = reality['url'];
                                        if (!reality.title && reality['name']) reality.title = reality['name'];
                                    }
                                    if (_this.isSupported(reality)) {
                                        _this.desiredRealityMap.set(session, reality);
                                        _this.desiredRealityMapInverse.set(reality, session);
                                    } else {
                                        session.sendError({ message: 'Reality of type "' + reality.uri + '" is not available on this platform' });
                                        return;
                                    }
                                } else {
                                    _this.desiredRealityMap.delete(session);
                                }
                                _this._setNextReality(_this.onSelectReality());
                                _this.sessionDesiredRealityChangeEvent.raiseEvent({ session: session, previous: previous, current: reality });
                            };
                        }
                    });
                    sessionService.manager.on['ar.reality.connect'] = function (_a) {
                        var id = _a.id;
                        var realityControlSession = _this.sessionService.createSessionPort();
                        var messageChannel = _this.sessionService.createSynchronousMessageChannel();
                        var ROUTE_MESSAGE_KEY = 'ar.reality.message.route.' + id;
                        var SEND_MESSAGE_KEY = 'ar.reality.message.send.' + id;
                        var CLOSE_SESSION_KEY = 'ar.reality.close.' + id;
                        messageChannel.port1.onmessage = function (msg) {
                            _this.sessionService.manager.send(ROUTE_MESSAGE_KEY, msg.data);
                        };
                        _this.sessionService.manager.on[SEND_MESSAGE_KEY] = function (message) {
                            messageChannel.port1.postMessage(message);
                        };
                        _this.sessionService.manager.on[CLOSE_SESSION_KEY] = function () {
                            realityControlSession.close();
                        };
                        realityControlSession.connectEvent.addEventListener(function () {
                            _this.connectEvent.raiseEvent(realityControlSession);
                        });
                        _this.sessionService.manager.closeEvent.addEventListener(function () {
                            realityControlSession.close();
                            delete _this.sessionService.manager.on[SEND_MESSAGE_KEY];
                            delete _this.sessionService.manager.on[CLOSE_SESSION_KEY];
                        });
                        realityControlSession.open(messageChannel.port2, _this.sessionService.configuration);
                    };
                    sessionService.manager.on['ar.reality.zoom'] = function (data) {
                        _this.zoom(data);
                    };
                }
                Object.defineProperty(RealityService.prototype, "changeEvent", {
                    get: function () {
                        this.sessionService.ensureIsRealityManager();
                        return this._changeEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RealityService.prototype, "frameEvent", {
                    get: function () {
                        this.sessionService.ensureIsRealityManager();
                        return this._frameEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Set the default reality.
                 */
                RealityService.prototype.setDefault = function (reality) {
                    this._default = reality;
                };
                /**
                 * Manager-only. Register a reality loader
                 */
                RealityService.prototype.registerLoader = function (handler) {
                    this.sessionService.ensureIsRealityManager();
                    this._loaders.push(handler);
                };
                /**
                 * Manager-only. Get the current reality view.
                 * @deprecated. Use app.context.getCurrentReality()
                 */
                RealityService.prototype.getCurrent = function () {
                    this.sessionService.ensureIsRealityManager();
                    return this._current;
                };
                /**
                * Manager-only. Check if a type of reality is supported.
                * @param type reality type
                * @return true if a handler exists and false otherwise
                */
                RealityService.prototype.isSupported = function (reality) {
                    this.sessionService.ensureIsRealityManager();
                    return !!this._getLoader(reality);
                };
                /**
                 * Reality-only. Publish the next frame state.
                 */
                RealityService.prototype.publishFrame = function (state) {
                    this.sessionService.ensureIsRealityView();
                    if (this.sessionService.manager.isConnected) {
                        this.sessionService.manager.send('ar.reality.frameState', state);
                    }
                };
                /**
                 * Set the desired reality.
                 */
                RealityService.prototype.setDesired = function (reality) {
                    this.sessionService.ensureNotRealityView();
                    this._desired = reality;
                    if (this.sessionService.isRealityManager) {
                        this._setNextReality(reality, true);
                    } else {
                        this.sessionService.manager.send('ar.reality.desired', { reality: reality });
                    }
                };
                /**
                 * Get the desired reality
                 */
                RealityService.prototype.getDesired = function () {
                    return this._desired;
                };
                /**
                 * Set the optional reference frames for this app
                 */
                RealityService.prototype.setOptionalReferenceFrames = function (referenceFrames) {};
                /**
                 * Set the optional reference frames for this app
                 */
                RealityService.prototype.setRequiredReferenceFrames = function (referenceFrames) {};
                /**
                 * Set a desired fov in radians.
                 */
                RealityService.prototype.setDesiredFov = function (fov) {
                    this._desiredFov = fov;
                    this.zoom({ fov: fov || this._defaultFov, zoom: 1, state: RealityZoomState.OTHER });
                };
                /**
                 * Get the desired fov in radians
                 */
                RealityService.prototype.getDesiredFov = function () {
                    return this._desiredFov;
                };
                /**
                 * Set the default fov in radians, and adjust the desired fov to match the
                 * previous desired / default ratio.
                 */
                RealityService.prototype.setDefaultFov = function (fov) {
                    if (cesium_imports_1.defined(this._desiredFov)) {
                        var ratio = this._desiredFov / this._defaultFov;
                        this.setDesiredFov(fov * ratio);
                    }
                    this._defaultFov = fov;
                };
                /**
                 * Get the default fov in radians
                 */
                RealityService.prototype.getDefaultFov = function () {
                    return this._defaultFov;
                };
                /**
                 * Returns a maximum viewport
                 */
                RealityService.prototype.getMaximumViewport = function () {
                    if (typeof document !== 'undefined' && document.documentElement) {
                        return {
                            x: 0,
                            y: 0,
                            width: document.documentElement.clientWidth,
                            height: document.documentElement.clientHeight
                        };
                    }
                    throw new Error("Not implemeneted for the current platform");
                };
                /**
                * Manager-only. Selects the best reality based on the realites
                * requested by all managed sessions. Can be overriden for customized selection.
                *
                * @returns The reality chosen for this context. May be undefined if no
                * realities have been requested.
                */
                RealityService.prototype.onSelectReality = function () {
                    this.sessionService.ensureIsRealityManager();
                    var selectedReality = this.desiredRealityMap.get(this.sessionService.manager);
                    if (!selectedReality) {
                        var focusSession = this.focusService.getSession();
                        if (focusSession && focusSession.isConnected) {
                            selectedReality = this.desiredRealityMap.get(focusSession);
                        }
                    }
                    if (!selectedReality) {
                        // TODO: sort and select based on some kind of ranking system
                        for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
                            var session = _a[_i];
                            if (!session.isConnected) continue;
                            var desiredReality = this.desiredRealityMap.get(session);
                            if (desiredReality && this.isSupported(desiredReality)) {
                                selectedReality = desiredReality;
                                break;
                            }
                        }
                    }
                    return selectedReality;
                };
                RealityService.prototype.onGenerateViewFromEyeParameters = function (eye) {
                    var fov = eye.fov || this._desiredFov || this._defaultFov;
                    var viewport = eye.viewport || this.getMaximumViewport();
                    var aspectRatio = eye.aspect || viewport.width / viewport.height;
                    this._scratchFrustum.fov = fov;
                    this._scratchFrustum.aspectRatio = aspectRatio;
                    this._scratchFrustum.near = 0.01;
                    this._scratchFrustum.far = 10000000;
                    return {
                        viewport: viewport,
                        pose: eye.pose,
                        subviews: [{
                            type: common_1.SubviewType.SINGULAR,
                            frustum: {
                                fov: fov,
                                aspectRatio: aspectRatio
                            },
                            // TODO: remove this later  
                            projectionMatrix: cesium_imports_1.Matrix4.toArray(this._scratchFrustum.projectionMatrix, this._scratchArray)
                        }]
                    };
                };
                RealityService.prototype.zoom = function (data) {
                    data.naturalFov = data.naturalFov || this._defaultFov;
                    if (this._realitySession && this._realitySession.info['reality.handlesZoom']) {
                        this._realitySession.send('ar.reality.zoom', data);
                    } else {
                        var fov = this._desiredFov = this.onZoom(data);
                        if (this.sessionService.isRealityView) {
                            this.sessionService.manager.send('ar.reality.desiredFov', { fov: fov });
                        }
                    }
                };
                RealityService.prototype.onZoom = function (data) {
                    var newFov = 2 * Math.atan(Math.tan(data.fov * 0.5) / data.zoom);
                    newFov = Math.max(10 * cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE, Math.min(newFov, 160 * cesium_imports_1.CesiumMath.RADIANS_PER_DEGREE));
                    if (data.state === RealityZoomState.END && Math.abs(newFov - data.naturalFov) < 0.05 /* +-6deg */) {
                            newFov = data.naturalFov;
                        }
                    return newFov;
                };
                RealityService.prototype._setNextReality = function (reality, force) {
                    var _this = this;
                    if (force === void 0) {
                        force = false;
                    }
                    if (this._current && reality && this._current === reality && !force) return;
                    if (this._current && !reality && this._realitySession) return;
                    if (!this._current && !cesium_imports_1.defined(reality)) {
                        reality = this._default;
                    }
                    if (cesium_imports_1.defined(reality)) {
                        if (!this.isSupported(reality)) {
                            this.sessionService.errorEvent.raiseEvent(new Error('Reality of type "' + reality.uri + '" is not available on this platform'));
                            return;
                        }
                        var loadID_1 = ++this._loadID;
                        this._executeRealityLoader(reality, function (realitySession) {
                            if (realitySession.isConnected) throw new Error('Expected an unconnected session');
                            if (loadID_1 !== _this._loadID) {
                                realitySession.close();
                                return;
                            }
                            var previousRealitySession = _this._realitySession;
                            _this._realitySession = realitySession;
                            _this._setCurrent(reality);
                            realitySession.on['ar.reality.frameState'] = function (serializedState) {
                                var state = serializedState;
                                if (!cesium_imports_1.defined(serializedState.view)) {
                                    if (!cesium_imports_1.defined(serializedState.eye)) throw new Error("Unable to construct view configuration: missing eye parameters");
                                    state.view = _this.onGenerateViewFromEyeParameters(serializedState.eye);
                                    state.eye = undefined;
                                    state.entities = serializedState.entities || {};
                                }
                                state.reality = _this.getCurrent();
                                _this.frameEvent.raiseEvent(state);
                            };
                            realitySession.on['ar.reality.desiredFov'] = function (state) {
                                _this._desiredFov = state.fov;
                            };
                            realitySession.closeEvent.addEventListener(function () {
                                console.log('Reality session closed: ' + JSON.stringify(reality));
                                // select a new reality if the current reality has closed without 
                                // another reality having been requested
                                if (_this._loadID === loadID_1) {
                                    _this._realitySession = undefined;
                                    _this._current = undefined;
                                    _this._setNextReality(_this.onSelectReality());
                                }
                            });
                            realitySession.connectEvent.addEventListener(function () {
                                if (realitySession.info.role !== common_1.Role.REALITY_VIEW) {
                                    realitySession.sendError({ message: "Expected a reality session" });
                                    realitySession.close();
                                    throw new Error('The application "' + realitySession.uri + '" does not support being loaded as a reality');
                                }
                                if (previousRealitySession) {
                                    previousRealitySession.close();
                                }
                                if (realitySession.info['reality.supportsControlPort']) {
                                    var ownerSession_1 = _this.desiredRealityMapInverse.get(reality) || _this.sessionService.manager;
                                    var id = cesium_imports_1.createGuid();
                                    var ROUTE_MESSAGE_KEY = 'ar.reality.message.route.' + id;
                                    var SEND_MESSAGE_KEY_1 = 'ar.reality.message.send.' + id;
                                    var CLOSE_SESSION_KEY_1 = 'ar.reality.close.' + id;
                                    realitySession.on[ROUTE_MESSAGE_KEY] = function (message) {
                                        ownerSession_1.send(SEND_MESSAGE_KEY_1, message);
                                    };
                                    ownerSession_1.on[ROUTE_MESSAGE_KEY] = function (message) {
                                        realitySession.send(SEND_MESSAGE_KEY_1, message);
                                    };
                                    realitySession.send('ar.reality.connect', { id: id });
                                    ownerSession_1.send('ar.reality.connect', { id: id });
                                    realitySession.closeEvent.addEventListener(function () {
                                        ownerSession_1.send(CLOSE_SESSION_KEY_1);
                                    });
                                    ownerSession_1.closeEvent.addEventListener(function () {
                                        realitySession.send(CLOSE_SESSION_KEY_1);
                                        realitySession.close();
                                    });
                                }
                            });
                        });
                    }
                };
                RealityService.prototype._getLoader = function (reality) {
                    var found;
                    for (var _i = 0, _a = this._loaders; _i < _a.length; _i++) {
                        var loader = _a[_i];
                        if (loader.type === common_1.RealityView.getType(reality)) {
                            found = loader;
                            break;
                        }
                    }
                    return found;
                };
                RealityService.prototype._setCurrent = function (reality) {
                    if (this._current === undefined || this._current !== reality) {
                        var previous = this._current;
                        this._current = reality;
                        this.changeEvent.raiseEvent({ previous: previous, current: reality });
                        console.log('Reality changed to: ' + JSON.stringify(reality));
                    }
                };
                RealityService.prototype._executeRealityLoader = function (reality, callback) {
                    this.sessionService.ensureIsRealityManager();
                    var loader = this._getLoader(reality);
                    if (!loader) throw new Error('Unable to setup unsupported reality type: ' + reality.uri);
                    loader.load(reality, callback);
                };
                RealityService = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, focus_1.FocusService)], RealityService);
                return RealityService;
            }();
            exports_1("RealityService", RealityService);
        }
    };
});
$__System.register('20', ['15', '13', '19', '14', '1b', '1d', '1a'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, cesium_imports_1, session_1, context_2, utils_1, focus_1, reality_1;
    var argonContainer, argonContainerPromise, ViewService, PinchZoomService;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (context_2_1) {
            context_2 = context_2_1;
        }, function (utils_1_1) {
            utils_1 = utils_1_1;
        }, function (focus_1_1) {
            focus_1 = focus_1_1;
        }, function (reality_1_1) {
            reality_1 = reality_1_1;
        }],
        execute: function () {
            // setup our DOM environment
            if (typeof document !== 'undefined' && document.createElement) {
                var viewportMetaTag = document.querySelector('meta[name=viewport]');
                if (!viewportMetaTag) viewportMetaTag = document.createElement('meta');
                viewportMetaTag.name = 'viewport';
                viewportMetaTag.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
                document.head.appendChild(viewportMetaTag);
                var argonMetaTag = document.querySelector('meta[name=argon]');
                if (!argonMetaTag) argonMetaTag = document.createElement('meta');
                argonMetaTag.name = 'argon';
                document.head.appendChild(argonMetaTag);
                argonContainerPromise = new Promise(function (resolve) {
                    var resolveArgonContainer = function () {
                        var container = document.querySelector('#argon');
                        if (!container) container = document.createElement('div');
                        container.id = 'argon';
                        container.classList.add('argon-view');
                        document.body.appendChild(container);
                        argonContainer = container;
                        resolve(container);
                    };
                    if (document.readyState == 'loading') {
                        document.addEventListener('DOMContentLoaded', resolveArgonContainer);
                    } else {
                        resolveArgonContainer();
                    }
                });
                var style = document.createElement("style");
                style.type = 'text/css';
                document.head.insertBefore(style, document.head.firstChild);
                var sheet = style.sheet;
                sheet.insertRule("\n        #argon {\n            position: fixed;\n            left: 0px;\n            bottom: 0px;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            border: 0;\n            padding: 0;\n        }\n    ", 0);
                sheet.insertRule("\n        .argon-view > * {\n            position: absolute;\n            pointer-events: none;\n        }\n    ", 1);
            }
            /**
             * Manages the view state
             */
            ViewService = function () {
                function ViewService(containerElement, sessionService, focusService, contextService) {
                    var _this = this;
                    this.sessionService = sessionService;
                    this.focusService = focusService;
                    this.contextService = contextService;
                    /**
                     * An event that is raised when the root viewport has changed
                     */
                    this.viewportChangeEvent = new utils_1.Event();
                    /**
                     * An event that is raised when ownership of the view has been acquired by this application
                     */
                    this.acquireEvent = new utils_1.Event();
                    /**
                     * An event that is raised when ownership of the view has been released from this application
                    */
                    this.releaseEvent = new utils_1.Event();
                    /**
                     *  Manager-only. A map of sessions to their desired viewports.
                     */
                    this.desiredViewportMap = new WeakMap();
                    this._subviews = [];
                    this._subviewEntities = [];
                    this._frustums = [];
                    if (typeof document !== 'undefined' && document.createElement) {
                        var element_1 = this.element = document.createElement('div');
                        element_1.style.width = '100%';
                        element_1.style.height = '100%';
                        element_1.classList.add('argon-view');
                        this.containingElementPromise = new Promise(function (resolve) {
                            if (containerElement && containerElement instanceof HTMLElement) {
                                containerElement.insertBefore(element_1, containerElement.firstChild);
                                resolve(containerElement);
                            } else {
                                argonContainer = document.querySelector('#argon');
                                if (argonContainer) {
                                    argonContainer.insertBefore(element_1, argonContainer.firstChild);
                                    resolve(argonContainer);
                                } else {
                                    argonContainerPromise.then(function (argonContainer) {
                                        argonContainer.insertBefore(element_1, argonContainer.firstChild);
                                        resolve(argonContainer);
                                    });
                                }
                                _this.focusService.focusEvent.addEventListener(function () {
                                    argonContainerPromise.then(function (argonContainer) {
                                        argonContainer.classList.remove('argon-no-focus');
                                        argonContainer.classList.add('argon-focus');
                                    });
                                });
                                _this.focusService.blurEvent.addEventListener(function () {
                                    argonContainerPromise.then(function (argonContainer) {
                                        argonContainer.classList.remove('argon-focus');
                                        argonContainer.classList.add('argon-no-focus');
                                    });
                                });
                            }
                        });
                    }
                    if (this.sessionService.isRealityManager) {
                        this.sessionService.connectEvent.addEventListener(function (session) {
                            session.on['ar.viewport.desired'] = function (viewport) {
                                _this.desiredViewportMap.set(session, viewport);
                            };
                        });
                    }
                    this.contextService.renderEvent.addEventListener(function () {
                        var state = _this.contextService.serializedFrameState;
                        var subviewEntities = _this._subviewEntities;
                        subviewEntities.length = 0;
                        state.view.subviews.forEach(function (subview, index) {
                            var id = 'ar.view_' + index;
                            state.entities[id] = subview.pose || state.view.pose;
                            _this.contextService.updateEntityFromFrameState(id, state);
                            delete state.entities[id];
                            subviewEntities[index] = _this.contextService.entities.getById(id);
                        });
                        _this._update();
                    });
                }
                ViewService.prototype.getSubviews = function (referenceFrame) {
                    var _this = this;
                    this._update();
                    var subviews = this._subviews;
                    subviews.length = this._current.subviews.length;
                    this._current.subviews.forEach(function (serializedSubview, index) {
                        var subviewEntity = _this._subviewEntities[index];
                        var subview = subviews[index] = subviews[index] || {};
                        subview.index = index;
                        subview.type = serializedSubview.type;
                        subview.pose = _this.contextService.getEntityPose(subviewEntity, referenceFrame);
                        subview.viewport = serializedSubview.viewport || _this._current.viewport;
                        subview.frustum = _this._frustums[index];
                        if (!subview.frustum) {
                            subview.frustum = _this._frustums[index] = new cesium_imports_1.PerspectiveFrustum();
                            subview.frustum.near = 0.01;
                            subview.frustum.far = 10000000;
                        }
                        subview.frustum.fov = serializedSubview.frustum.fov;
                        subview.frustum.aspectRatio = serializedSubview.frustum.aspectRatio || subview.viewport.width / subview.viewport.height;
                        subview.frustum.xOffset = serializedSubview.frustum.xOffset || 0;
                        subview.frustum.yOffset = serializedSubview.frustum.yOffset || 0;
                        subview.projectionMatrix = serializedSubview.projectionMatrix || subview.frustum.infiniteProjectionMatrix;
                    });
                    return subviews;
                };
                ViewService.prototype.getViewport = function () {
                    return this._current.viewport;
                };
                /**
                 * Set the desired root viewport
                 */
                ViewService.prototype.setDesiredViewport = function (viewport) {
                    this.sessionService.manager.send('ar.view.desiredViewport', viewport);
                };
                /**
                 * Request control over the view.
                 * The manager is likely to reject this request if this application is not in focus.
                 * When running on an HMD, this request will always fail. If the current reality view
                 * does not support custom views, this request will fail. The manager may revoke
                 * ownership at any time (even without this application calling releaseOwnership)
                 */
                ViewService.prototype.requestOwnership = function () {};
                /**
                 * Release control over the view.
                 */
                ViewService.prototype.releaseOwnership = function () {};
                /**
                 * Returns true if this application has control over the view.
                 */
                ViewService.prototype.isOwner = function () {};
                // Updates the element, if necessary, and raise a view change event
                ViewService.prototype._update = function () {
                    var _this = this;
                    var state = this.contextService.serializedFrameState;
                    if (!state) throw new Error('Expected state to be defined');
                    var view = state.view;
                    var viewportJSON = JSON.stringify(view.viewport);
                    var previousViewport = this._current && this._current.viewport;
                    this._current = view;
                    if (!this._currentViewportJSON || this._currentViewportJSON !== viewportJSON) {
                        this._currentViewportJSON = viewportJSON;
                        if (this.element) {
                            requestAnimationFrame(function () {
                                var viewport = view.viewport;
                                _this.element.style.left = viewport.x + 'px';
                                _this.element.style.bottom = viewport.y + 'px';
                                _this.element.style.width = viewport.width + 'px';
                                _this.element.style.height = viewport.height + 'px';
                            });
                        }
                        this.viewportChangeEvent.raiseEvent({ previous: previousViewport });
                    }
                };
                ViewService = __decorate([aurelia_dependency_injection_1.inject('containerElement', session_1.SessionService, focus_1.FocusService, context_2.ContextService)], ViewService);
                return ViewService;
            }();
            exports_1("ViewService", ViewService);
            PinchZoomService = function () {
                function PinchZoomService(viewService, realityService, contextService, sessionService) {
                    var _this = this;
                    this.viewService = viewService;
                    this.realityService = realityService;
                    this.contextService = contextService;
                    this.sessionService = sessionService;
                    if (this.sessionService.isRealityManager) {
                        this.viewService.containingElementPromise.then(function (el) {
                            el.style.pointerEvents = 'auto';
                            var fov = -1;
                            if (typeof PointerEvent !== 'undefined') {
                                var evCache_1 = new Array();
                                var startDistSquared_1 = -1;
                                var zoom_1 = 1;
                                var remove_event_1 = function (ev) {
                                    // Remove this event from the target's cache
                                    for (var i = 0; i < evCache_1.length; i++) {
                                        if (evCache_1[i].pointerId == ev.pointerId) {
                                            evCache_1.splice(i, 1);
                                            break;
                                        }
                                    }
                                };
                                var pointerdown_handler = function (ev) {
                                    // The pointerdown event signals the start of a touch interaction.
                                    // This event is cached to support 2-finger gestures
                                    evCache_1.push(ev);
                                };
                                var pointermove_handler = function (ev) {
                                    // This function implements a 2-pointer pinch/zoom gesture. 
                                    // Find this event in the cache and update its record with this event
                                    for (var i = 0; i < evCache_1.length; i++) {
                                        if (ev.pointerId == evCache_1[i].pointerId) {
                                            evCache_1[i] = ev;
                                            break;
                                        }
                                    }
                                    var state = _this.contextService.serializedFrameState;
                                    if (!state) return;
                                    // If two pointers are down, check for pinch gestures
                                    if (evCache_1.length == 2) {
                                        // Calculate the distance between the two pointers
                                        var curDiffX = Math.abs(evCache_1[0].clientX - evCache_1[1].clientX);
                                        var curDiffY = Math.abs(evCache_1[0].clientY - evCache_1[1].clientY);
                                        var currDistSquared = curDiffX * curDiffX + curDiffY * curDiffY;
                                        if (startDistSquared_1 == -1) {
                                            // start pinch
                                            startDistSquared_1 = currDistSquared;
                                            fov = state.view.subviews[0].frustum.fov;
                                            zoom_1 = 1;
                                            _this.realityService.zoom({ zoom: zoom_1, fov: fov, state: reality_1.RealityZoomState.START });
                                        } else {
                                            // change pinch
                                            zoom_1 = currDistSquared / startDistSquared_1;
                                            _this.realityService.zoom({ zoom: zoom_1, fov: fov, state: reality_1.RealityZoomState.CHANGE });
                                        }
                                    } else {
                                        // end pinch                            
                                        _this.realityService.zoom({ zoom: zoom_1, fov: fov, state: reality_1.RealityZoomState.END });
                                        startDistSquared_1 = -1;
                                    }
                                };
                                var pointerup_handler = function (ev) {
                                    // Remove this pointer from the cache
                                    remove_event_1(ev);
                                    // If the number of pointers down is less than two then reset diff tracker
                                    if (evCache_1.length < 2) startDistSquared_1 = -1;
                                };
                                el.onpointerdown = pointerdown_handler;
                                el.onpointermove = pointermove_handler;
                                // Use same handler for pointer{up,cancel,out,leave} events since
                                // the semantics for these events - in this app - are the same.
                                el.onpointerup = pointerup_handler;
                                el.onpointercancel = pointerup_handler;
                                el.onpointerout = pointerup_handler;
                                el.onpointerleave = pointerup_handler;
                            } else {
                                el.addEventListener('gesturestart', function (ev) {
                                    var state = _this.contextService.serializedFrameState;
                                    if (state && state.view.subviews[0]) {
                                        fov = state.view.subviews[0].frustum.fov;
                                        _this.realityService.zoom({ zoom: ev.scale, fov: fov, state: reality_1.RealityZoomState.START });
                                    }
                                });
                                el.addEventListener('gesturechange', function (ev) {
                                    _this.realityService.zoom({ zoom: ev.scale, fov: fov, state: reality_1.RealityZoomState.CHANGE });
                                });
                                el.addEventListener('gestureend', function (ev) {
                                    _this.realityService.zoom({ zoom: ev.scale, fov: fov, state: reality_1.RealityZoomState.END });
                                });
                            }
                        });
                    }
                }
                PinchZoomService = __decorate([aurelia_dependency_injection_1.inject(ViewService, reality_1.RealityService, context_2.ContextService, session_1.SessionService)], PinchZoomService);
                return PinchZoomService;
            }();
            exports_1("PinchZoomService", PinchZoomService);
        }
    };
});
$__System.register('21', ['15', '19', '1a', '20'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var __extends = this && this.__extends || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var aurelia_dependency_injection_1, session_1, reality_1, view_1;
    var HostedRealityLoader;
    return {
        setters: [function (aurelia_dependency_injection_1_1) {
            aurelia_dependency_injection_1 = aurelia_dependency_injection_1_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
        }, function (reality_1_1) {
            reality_1 = reality_1_1;
        }, function (view_1_1) {
            view_1 = view_1_1;
        }],
        execute: function () {
            HostedRealityLoader = function (_super) {
                __extends(HostedRealityLoader, _super);
                function HostedRealityLoader(sessionService, viewService) {
                    var _this = this;
                    _super.call(this);
                    this.sessionService = sessionService;
                    this.viewService = viewService;
                    this.type = 'hosted';
                    this.iframeElement = document.createElement('iframe');
                    this.iframeElement.style.border = '0';
                    this.iframeElement.width = '100%';
                    this.iframeElement.height = '100%';
                    viewService.containingElementPromise.then(function (container) {
                        container.insertBefore(_this.iframeElement, container.firstChild);
                    });
                }
                HostedRealityLoader.prototype.load = function (reality, callback) {
                    var _this = this;
                    this.viewService.containingElementPromise.then(function (container) {
                        var handleConnectMessage = function (ev) {
                            if (ev.data.type !== 'ARGON_SESSION') return;
                            var messagePort = ev.ports && ev.ports[0];
                            if (!messagePort) throw new Error('Received an ARGON_SESSION message without a MessagePort object');
                            // get the event.source iframe
                            var i = 0;
                            var frame;
                            while (i < window.frames.length && !frame) {
                                if (window.frames[i] == ev.source) frame = document.getElementsByTagName('iframe')[i];
                            }
                            if (frame !== _this.iframeElement) return;
                            window.removeEventListener('message', handleConnectMessage);
                            var realitySession = _this.sessionService.addManagedSessionPort(reality.uri);
                            callback(realitySession);
                            realitySession.open(messagePort, _this.sessionService.configuration);
                        };
                        window.addEventListener('message', handleConnectMessage);
                        _this.iframeElement.src = '';
                        _this.iframeElement.src = reality.uri;
                        _this.iframeElement.style.pointerEvents = 'auto';
                    });
                };
                HostedRealityLoader = __decorate([aurelia_dependency_injection_1.inject(session_1.SessionService, view_1.ViewService)], HostedRealityLoader);
                return HostedRealityLoader;
            }(reality_1.RealityLoader);
            exports_1("HostedRealityLoader", HostedRealityLoader);
        }
    };
});
// @singleton()
// @inject(SessionFactory)
// export class DOMSessionListenerService {
// 	public sessionEvent = new Event<Session>();
// 	constructor(sessionFactory:SessionFactory) {
// 		window.addEventListener('message', ev => {
// 			if (ev.data.type != 'ARGON_SESSION') return;
// 			const messagePort:MessagePortLike = ev.ports && ev.ports[0];
// 			if (!messagePort) 
// 				throw new Error('Received an ARGON_SESSION message without a MessagePort object');
// 			// get the event.source iframe
// 			let i = 0;
// 			let frame:HTMLIFrameElement = null;
// 			while (i < window.frames.length && frame != null) {
// 				if (window.frames[i] == ev.source)
// 					frame = document.getElementsByTagName( 'iframe' )[i];
// 			}			
// 			const session = sessionFactory.create();
// 			session.frame = frame;
// 			if (frame) frame.addEventListener('load', function close() {
// 				frame.removeEventListener('load', close);
// 				console.log('IFrameSessionHandler: frame load detected, closing current session.', frame, session)
// 				session.close()
// 			});
// 			this.sessionEvent.raiseEvent(session);
// 		});
// 	}
// }
/*global define*/
$__System.registerDynamic('22', ['23', '24', '25', '26'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError, Event) {
        'use strict';

        /**
         * A {@link Property} whose value is lazily evaluated by a callback function.
         *
         * @alias CallbackProperty
         * @constructor
         *
         * @param {CallbackProperty~Callback} callback The function to be called when the property is evaluated.
         * @param {Boolean} isConstant <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
         */

        function CallbackProperty(callback, isConstant) {
            this._callback = undefined;
            this._isConstant = undefined;
            this._definitionChanged = new Event();
            this.setCallback(callback, isConstant);
        }

        defineProperties(CallbackProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.
             * @memberof CallbackProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: function () {
                    return this._isConstant;
                }
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is changed whenever setCallback is called.
             * @memberof CallbackProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            }
        });

        /**
         * Gets the value of the property.
         *
         * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
         */
        CallbackProperty.prototype.getValue = function (time, result) {
            return this._callback(time, result);
        };

        /**
         * Sets the callback to be used.
         *
         * @param {CallbackProperty~Callback} callback The function to be called when the property is evaluated.
         * @param {Boolean} isConstant <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
         */
        CallbackProperty.prototype.setCallback = function (callback, isConstant) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(callback)) {
                throw new DeveloperError('callback is required.');
            }
            if (!defined(isConstant)) {
                throw new DeveloperError('isConstant is required.');
            }
            //>>includeEnd('debug');

            var changed = this._callback !== callback || this._isConstant !== isConstant;

            this._callback = callback;
            this._isConstant = isConstant;

            if (changed) {
                this._definitionChanged.raiseEvent(this);
            }
        };

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        CallbackProperty.prototype.equals = function (other) {
            return this === other || other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant;
        };

        /**
         * A function that returns the value of the property.
         * @callback CallbackProperty~Callback
         *
         * @param {JulianDate} [time] The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
         */

        return CallbackProperty;
    }).call(this, $__require('23'), $__require('24'), $__require('25'), $__require('26'));
});
/*global define*/
$__System.registerDynamic('27', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * Constants used by {@link Clock#tick} to determine behavior
     * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
     *
     * @exports ClockRange
     *
     * @see Clock
     * @see ClockStep
     */

    var ClockRange = {
      /**
       * {@link Clock#tick} will always advances the clock in its current direction.
       *
       * @type {Number}
       * @constant
       */
      UNBOUNDED: 0,

      /**
       * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
       * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
       *
       * @type {Number}
       * @constant
       */
      CLAMPED: 1,

      /**
       * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance
       * {@link Clock#currentTime} to the opposite end of the interval.  When
       * time is moving backwards, {@link Clock#tick} will not advance past
       * {@link Clock#startTime}
       *
       * @type {Number}
       * @constant
       */
      LOOP_STOP: 2
    };

    return freezeObject(ClockRange);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('29', ['23'], false, function ($__require, $__exports, $__module) {
    return (function (defined) {
        'use strict';
        /*global performance*/

        /**
         * Gets a timestamp that can be used in measuring the time between events.  Timestamps
         * are expressed in milliseconds, but it is not specified what the milliseconds are
         * measured from.  This function uses performance.now() if it is available, or Date.now()
         * otherwise.
         *
         * @exports getTimestamp
         *
         * @returns {Number} The timestamp in milliseconds since some unspecified reference time.
         */

        var getTimestamp;

        if (typeof performance !== 'undefined' && defined(performance.now)) {
            getTimestamp = function () {
                return performance.now();
            };
        } else {
            getTimestamp = function () {
                return Date.now();
            };
        }

        return getTimestamp;
    }).call(this, $__require('23'));
});
/*global define*/
$__System.registerDynamic('2a', ['27', '2b', '2c', '23', '25', '26', '29', '2d'], false, function ($__require, $__exports, $__module) {
    return (function (ClockRange, ClockStep, defaultValue, defined, DeveloperError, Event, getTimestamp, JulianDate) {
        'use strict';

        /**
         * A simple clock for keeping track of simulated time.
         *
         * @alias Clock
         * @constructor
         *
         * @param {Object} [options] Object with the following properties:
         * @param {JulianDate} [options.startTime] The start time of the clock.
         * @param {JulianDate} [options.stopTime] The stop time of the clock.
         * @param {JulianDate} [options.currentTime] The current time.
         * @param {Number} [options.multiplier=1.0] Determines how much time advances when tick is called, negative values allow for advancing backwards.
         * @param {ClockStep} [options.clockStep=ClockStep.SYSTEM_CLOCK_MULTIPLIER] Determines if calls to <code>tick</code> are frame dependent or system clock dependent.
         * @param {ClockRange} [options.clockRange=ClockRange.UNBOUNDED] Determines how the clock should behave when <code>startTime</code> or <code>stopTime</code> is reached.
         * @param {Boolean} [options.canAnimate=true] Indicates whether tick can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
         * @param {Boolean} [options.shouldAnimate=true] Indicates whether tick should attempt to advance time.  The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
         *
         * @exception {DeveloperError} startTime must come before stopTime.
         *
         *
         * @example
         * // Create a clock that loops on Christmas day 2013 and runs in real-time.
         * var clock = new Cesium.Clock({
         *    startTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
         *    currentTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
         *    stopTime : Cesium.JulianDate.fromIso8601("2013-12-26"),
         *    clockRange : Cesium.ClockRange.LOOP_STOP,
         *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER
         * });
         * 
         * @see ClockStep
         * @see ClockRange
         * @see JulianDate
         */

        function Clock(options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);

            var startTime = options.startTime;
            var startTimeUndefined = !defined(startTime);

            var stopTime = options.stopTime;
            var stopTimeUndefined = !defined(stopTime);

            var currentTime = options.currentTime;
            var currentTimeUndefined = !defined(currentTime);

            if (startTimeUndefined && stopTimeUndefined && currentTimeUndefined) {
                currentTime = JulianDate.now();
                startTime = JulianDate.clone(currentTime);
                stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
            } else if (startTimeUndefined && stopTimeUndefined) {
                startTime = JulianDate.clone(currentTime);
                stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
            } else if (startTimeUndefined && currentTimeUndefined) {
                startTime = JulianDate.addDays(stopTime, -1.0, new JulianDate());
                currentTime = JulianDate.clone(startTime);
            } else if (currentTimeUndefined && stopTimeUndefined) {
                currentTime = JulianDate.clone(startTime);
                stopTime = JulianDate.addDays(startTime, 1.0, new JulianDate());
            } else if (currentTimeUndefined) {
                currentTime = JulianDate.clone(startTime);
            } else if (stopTimeUndefined) {
                stopTime = JulianDate.addDays(currentTime, 1.0, new JulianDate());
            } else if (startTimeUndefined) {
                startTime = JulianDate.clone(currentTime);
            }

            //>>includeStart('debug', pragmas.debug);
            if (JulianDate.greaterThan(startTime, stopTime)) {
                throw new DeveloperError('startTime must come before stopTime.');
            }
            //>>includeEnd('debug');

            /**
             * The start time of the clock.
             * @type {JulianDate}
             */
            this.startTime = startTime;

            /**
             * The stop time of the clock.
             * @type {JulianDate}
             */
            this.stopTime = stopTime;

            /**
             * The current time.
             * @type {JulianDate}
             */
            this.currentTime = currentTime;

            /**
             * Determines how much time advances when tick is called, negative values allow for advancing backwards.
             * If <code>clockStep</code> is set to ClockStep.TICK_DEPENDENT this is the number of seconds to advance.
             * If <code>clockStep</code> is set to ClockStep.SYSTEM_CLOCK_MULTIPLIER this value is multiplied by the
             * elapsed system time since the last call to tick.
             * @type {Number}
             * @default 1.0
             */
            this.multiplier = defaultValue(options.multiplier, 1.0);

            /**
             * Determines if calls to <code>tick</code> are frame dependent or system clock dependent.
             * @type ClockStep
             * @default {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}
             */
            this.clockStep = defaultValue(options.clockStep, ClockStep.SYSTEM_CLOCK_MULTIPLIER);

            /**
             * Determines how the clock should behave when <code>startTime</code> or <code>stopTime</code> is reached.
             * @type {ClockRange}
             * @default {@link ClockRange.UNBOUNDED}
             */
            this.clockRange = defaultValue(options.clockRange, ClockRange.UNBOUNDED);

            /**
             * Indicates whether tick can advance time.  This could be false if data is being buffered,
             * for example.  The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
             * @type {Boolean}
             * @default true
             */
            this.canAnimate = defaultValue(options.canAnimate, true);

            /**
             * Indicates whether tick should attempt to advance time.
             * The clock will only tick when both <code>canAnimate</code> and <code>shouldAnimate</code> are true.
             * @type {Boolean}
             * @default true
             */
            this.shouldAnimate = defaultValue(options.shouldAnimate, true);

            /**
             * An {@link Event} that is fired whenever <code>tick</code>.
             * @type {Event}
             */
            this.onTick = new Event();

            this._lastSystemTime = getTimestamp();
        }

        /**
         * Advances the clock from the currentTime based on the current configuration options.
         * tick should be called every frame, regardless of whether animation is taking place
         * or not.  To control animation, use the <code>shouldAnimate</code> property.
         *
         * @returns {JulianDate} The new value of the <code>currentTime</code> property.
         */
        Clock.prototype.tick = function () {
            var currentSystemTime = getTimestamp();
            var currentTime = JulianDate.clone(this.currentTime);
            var startTime = this.startTime;
            var stopTime = this.stopTime;
            var multiplier = this.multiplier;

            if (this.canAnimate && this.shouldAnimate) {
                if (this.clockStep === ClockStep.SYSTEM_CLOCK) {
                    currentTime = JulianDate.now(currentTime);
                } else {
                    if (this.clockStep === ClockStep.TICK_DEPENDENT) {
                        currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);
                    } else {
                        var milliseconds = currentSystemTime - this._lastSystemTime;
                        currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / 1000.0), currentTime);
                    }

                    if (this.clockRange === ClockRange.CLAMPED) {
                        if (JulianDate.lessThan(currentTime, startTime)) {
                            currentTime = JulianDate.clone(startTime, currentTime);
                        } else if (JulianDate.greaterThan(currentTime, stopTime)) {
                            currentTime = JulianDate.clone(stopTime, currentTime);
                        }
                    } else if (this.clockRange === ClockRange.LOOP_STOP) {
                        if (JulianDate.lessThan(currentTime, startTime)) {
                            currentTime = JulianDate.clone(startTime, currentTime);
                        }
                        while (JulianDate.greaterThan(currentTime, stopTime)) {
                            currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);
                        }
                    }
                }
            }

            this.currentTime = currentTime;
            this._lastSystemTime = currentSystemTime;
            this.onTick.raiseEvent(this);
            return currentTime;
        };

        return Clock;
    }).call(this, $__require('27'), $__require('2b'), $__require('2c'), $__require('23'), $__require('25'), $__require('26'), $__require('29'), $__require('2d'));
});
/*global define*/
$__System.registerDynamic('2b', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * Constants to determine how much time advances with each call
     * to {@link Clock#tick}.
     *
     * @exports ClockStep
     *
     * @see Clock
     * @see ClockRange
     */

    var ClockStep = {
      /**
       * {@link Clock#tick} advances the current time by a fixed step,
       * which is the number of seconds specified by {@link Clock#multiplier}.
       *
       * @type {Number}
       * @constant
       */
      TICK_DEPENDENT: 0,

      /**
       * {@link Clock#tick} advances the current time by the amount of system
       * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
       *
       * @type {Number}
       * @constant
       */
      SYSTEM_CLOCK_MULTIPLIER: 1,

      /**
       * {@link Clock#tick} sets the clock to the current system time;
       * ignoring all other settings.
       *
       * @type {Number}
       * @constant
       */
      SYSTEM_CLOCK: 2
    };

    return freezeObject(ClockStep);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('2e', ['2f', '23', '24', '25', '30', '31', '32'], false, function ($__require, $__exports, $__module) {
    return (function (createGuid, defined, defineProperties, DeveloperError, CesiumMath, Entity, EntityCollection) {
        'use strict';

        var entityOptionsScratch = {
            id: undefined
        };
        var entityIdScratch = new Array(2);

        function clean(entity) {
            var propertyNames = entity.propertyNames;
            var propertyNamesLength = propertyNames.length;
            for (var i = 0; i < propertyNamesLength; i++) {
                entity[propertyNames[i]] = undefined;
            }
        }

        function subscribeToEntity(that, eventHash, collectionId, entity) {
            entityIdScratch[0] = collectionId;
            entityIdScratch[1] = entity.id;
            eventHash[JSON.stringify(entityIdScratch)] = entity.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged, that);
        }

        function unsubscribeFromEntity(that, eventHash, collectionId, entity) {
            entityIdScratch[0] = collectionId;
            entityIdScratch[1] = entity.id;
            var id = JSON.stringify(entityIdScratch);
            eventHash[id]();
            eventHash[id] = undefined;
        }

        function recomposite(that) {
            that._shouldRecomposite = true;
            if (that._suspendCount !== 0) {
                return;
            }

            var collections = that._collections;
            var collectionsLength = collections.length;

            var collectionsCopy = that._collectionsCopy;
            var collectionsCopyLength = collectionsCopy.length;

            var i;
            var entity;
            var entities;
            var iEntities;
            var collection;
            var composite = that._composite;
            var newEntities = new EntityCollection(that);
            var eventHash = that._eventHash;
            var collectionId;

            for (i = 0; i < collectionsCopyLength; i++) {
                collection = collectionsCopy[i];
                collection.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);
                entities = collection.values;
                collectionId = collection.id;
                for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
                    entity = entities[iEntities];
                    unsubscribeFromEntity(that, eventHash, collectionId, entity);
                }
            }

            for (i = collectionsLength - 1; i >= 0; i--) {
                collection = collections[i];
                collection.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged, that);

                //Merge all of the existing entities.
                entities = collection.values;
                collectionId = collection.id;
                for (iEntities = entities.length - 1; iEntities > -1; iEntities--) {
                    entity = entities[iEntities];
                    subscribeToEntity(that, eventHash, collectionId, entity);

                    var compositeEntity = newEntities.getById(entity.id);
                    if (!defined(compositeEntity)) {
                        compositeEntity = composite.getById(entity.id);
                        if (!defined(compositeEntity)) {
                            entityOptionsScratch.id = entity.id;
                            compositeEntity = new Entity(entityOptionsScratch);
                        } else {
                            clean(compositeEntity);
                        }
                        newEntities.add(compositeEntity);
                    }
                    compositeEntity.merge(entity);
                }
            }
            that._collectionsCopy = collections.slice(0);

            composite.suspendEvents();
            composite.removeAll();
            var newEntitiesArray = newEntities.values;
            for (i = 0; i < newEntitiesArray.length; i++) {
                composite.add(newEntitiesArray[i]);
            }
            composite.resumeEvents();
        }

        /**
         * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.
         * If a Entity with the same ID exists in multiple collections, it is non-destructively
         * merged into a single new entity instance.  If an entity has the same property in multiple
         * collections, the property of the Entity in the last collection of the list it
         * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a
         * EntityCollection is used.
         *
         * @alias CompositeEntityCollection
         * @constructor
         *
         * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.
         * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.
         */
        function CompositeEntityCollection(collections, owner) {
            this._owner = owner;
            this._composite = new EntityCollection(this);
            this._suspendCount = 0;
            this._collections = defined(collections) ? collections.slice() : [];
            this._collectionsCopy = [];
            this._id = createGuid();
            this._eventHash = {};
            recomposite(this);
            this._shouldRecomposite = false;
        }

        defineProperties(CompositeEntityCollection.prototype, {
            /**
             * Gets the event that is fired when entities are added or removed from the collection.
             * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
             * @memberof CompositeEntityCollection.prototype
             * @readonly
             * @type {Event}
             */
            collectionChanged: {
                get: function () {
                    return this._composite._collectionChanged;
                }
            },
            /**
             * Gets a globally unique identifier for this collection.
             * @memberof CompositeEntityCollection.prototype
             * @readonly
             * @type {String}
             */
            id: {
                get: function () {
                    return this._id;
                }
            },
            /**
             * Gets the array of Entity instances in the collection.
             * This array should not be modified directly.
             * @memberof CompositeEntityCollection.prototype
             * @readonly
             * @type {Entity[]}
             */
            values: {
                get: function () {
                    return this._composite.values;
                }
            },
            /**
             * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.
             * @memberof CompositeEntityCollection.prototype
             * @readonly
             * @type {DataSource|CompositeEntityCollection}
             */
            owner: {
                get: function () {
                    return this._owner;
                }
            }
        });

        /**
         * Adds a collection to the composite.
         *
         * @param {EntityCollection} collection the collection to add.
         * @param {Number} [index] the index to add the collection at.  If omitted, the collection will
         *                         added on top of all existing collections.
         *
         * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.
         */
        CompositeEntityCollection.prototype.addCollection = function (collection, index) {
            var hasIndex = defined(index);
            //>>includeStart('debug', pragmas.debug);
            if (!defined(collection)) {
                throw new DeveloperError('collection is required.');
            }
            if (hasIndex) {
                if (index < 0) {
                    throw new DeveloperError('index must be greater than or equal to zero.');
                } else if (index > this._collections.length) {
                    throw new DeveloperError('index must be less than or equal to the number of collections.');
                }
            }
            //>>includeEnd('debug');

            if (!hasIndex) {
                index = this._collections.length;
                this._collections.push(collection);
            } else {
                this._collections.splice(index, 0, collection);
            }

            recomposite(this);
        };

        /**
         * Removes a collection from this composite, if present.
         *
         * @param {EntityCollection} collection The collection to remove.
         * @returns {Boolean} true if the collection was in the composite and was removed,
         *                    false if the collection was not in the composite.
         */
        CompositeEntityCollection.prototype.removeCollection = function (collection) {
            var index = this._collections.indexOf(collection);
            if (index !== -1) {
                this._collections.splice(index, 1);
                recomposite(this);
                return true;
            }
            return false;
        };

        /**
         * Removes all collections from this composite.
         */
        CompositeEntityCollection.prototype.removeAllCollections = function () {
            this._collections.length = 0;
            recomposite(this);
        };

        /**
         * Checks to see if the composite contains a given collection.
         *
         * @param {EntityCollection} collection the collection to check for.
         * @returns {Boolean} true if the composite contains the collection, false otherwise.
         */
        CompositeEntityCollection.prototype.containsCollection = function (collection) {
            return this._collections.indexOf(collection) !== -1;
        };

        /**
         * Returns true if the provided entity is in this collection, false otherwise.
         *
         * @param {Entity} entity The entity.
         * @returns {Boolean} true if the provided entity is in this collection, false otherwise.
         */
        CompositeEntityCollection.prototype.contains = function (entity) {
            return this._composite.contains(entity);
        };

        /**
         * Determines the index of a given collection in the composite.
         *
         * @param {EntityCollection} collection The collection to find the index of.
         * @returns {Number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.
         */
        CompositeEntityCollection.prototype.indexOfCollection = function (collection) {
            return this._collections.indexOf(collection);
        };

        /**
         * Gets a collection by index from the composite.
         *
         * @param {Number} index the index to retrieve.
         */
        CompositeEntityCollection.prototype.getCollection = function (index) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(index)) {
                throw new DeveloperError('index is required.', 'index');
            }
            //>>includeEnd('debug');

            return this._collections[index];
        };

        /**
         * Gets the number of collections in this composite.
         */
        CompositeEntityCollection.prototype.getCollectionsLength = function () {
            return this._collections.length;
        };

        function getCollectionIndex(collections, collection) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(collection)) {
                throw new DeveloperError('collection is required.');
            }
            //>>includeEnd('debug');

            var index = collections.indexOf(collection);

            //>>includeStart('debug', pragmas.debug);
            if (index === -1) {
                throw new DeveloperError('collection is not in this composite.');
            }
            //>>includeEnd('debug');

            return index;
        }

        function swapCollections(composite, i, j) {
            var arr = composite._collections;
            i = CesiumMath.clamp(i, 0, arr.length - 1);
            j = CesiumMath.clamp(j, 0, arr.length - 1);

            if (i === j) {
                return;
            }

            var temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;

            recomposite(composite);
        }

        /**
         * Raises a collection up one position in the composite.
         *
         * @param {EntityCollection} collection the collection to move.
         *
         * @exception {DeveloperError} collection is not in this composite.
         */
        CompositeEntityCollection.prototype.raiseCollection = function (collection) {
            var index = getCollectionIndex(this._collections, collection);
            swapCollections(this, index, index + 1);
        };

        /**
         * Lowers a collection down one position in the composite.
         *
         * @param {EntityCollection} collection the collection to move.
         *
         * @exception {DeveloperError} collection is not in this composite.
         */
        CompositeEntityCollection.prototype.lowerCollection = function (collection) {
            var index = getCollectionIndex(this._collections, collection);
            swapCollections(this, index, index - 1);
        };

        /**
         * Raises a collection to the top of the composite.
         *
         * @param {EntityCollection} collection the collection to move.
         *
         * @exception {DeveloperError} collection is not in this composite.
         */
        CompositeEntityCollection.prototype.raiseCollectionToTop = function (collection) {
            var index = getCollectionIndex(this._collections, collection);
            if (index === this._collections.length - 1) {
                return;
            }
            this._collections.splice(index, 1);
            this._collections.push(collection);

            recomposite(this);
        };

        /**
         * Lowers a collection to the bottom of the composite.
         *
         * @param {EntityCollection} collection the collection to move.
         *
         * @exception {DeveloperError} collection is not in this composite.
         */
        CompositeEntityCollection.prototype.lowerCollectionToBottom = function (collection) {
            var index = getCollectionIndex(this._collections, collection);
            if (index === 0) {
                return;
            }
            this._collections.splice(index, 1);
            this._collections.splice(0, 0, collection);

            recomposite(this);
        };

        /**
         * Prevents {@link EntityCollection#collectionChanged} events from being raised
         * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
         * point a single event will be raised that covers all suspended operations.
         * This allows for many items to be added and removed efficiently.
         * While events are suspended, recompositing of the collections will
         * also be suspended, as this can be a costly operation.
         * This function can be safely called multiple times as long as there
         * are corresponding calls to {@link EntityCollection#resumeEvents}.
         */
        CompositeEntityCollection.prototype.suspendEvents = function () {
            this._suspendCount++;
            this._composite.suspendEvents();
        };

        /**
         * Resumes raising {@link EntityCollection#collectionChanged} events immediately
         * when an item is added or removed.  Any modifications made while while events were suspended
         * will be triggered as a single event when this function is called.  This function also ensures
         * the collection is recomposited if events are also resumed.
         * This function is reference counted and can safely be called multiple times as long as there
         * are corresponding calls to {@link EntityCollection#resumeEvents}.
         *
         * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.
         */
        CompositeEntityCollection.prototype.resumeEvents = function () {
            //>>includeStart('debug', pragmas.debug);
            if (this._suspendCount === 0) {
                throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
            }
            //>>includeEnd('debug');

            this._suspendCount--;
            // recomposite before triggering events (but only if required for performance) that might depend on a composited collection
            if (this._shouldRecomposite && this._suspendCount === 0) {
                recomposite(this);
                this._shouldRecomposite = false;
            }

            this._composite.resumeEvents();
        };

        /**
         * Computes the maximum availability of the entities in the collection.
         * If the collection contains a mix of infinitely available data and non-infinite data,
         * It will return the interval pertaining to the non-infinite data only.  If all
         * data is infinite, an infinite interval will be returned.
         *
         * @returns {TimeInterval} The availability of entities in the collection.
         */
        CompositeEntityCollection.prototype.computeAvailability = function () {
            return this._composite.computeAvailability();
        };

        /**
         * Gets an entity with the specified id.
         *
         * @param {Object} id The id of the entity to retrieve.
         * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.
         */
        CompositeEntityCollection.prototype.getById = function (id) {
            return this._composite.getById(id);
        };

        CompositeEntityCollection.prototype._onCollectionChanged = function (collection, added, removed) {
            var collections = this._collectionsCopy;
            var collectionsLength = collections.length;
            var composite = this._composite;
            composite.suspendEvents();

            var i;
            var q;
            var entity;
            var compositeEntity;
            var removedLength = removed.length;
            var eventHash = this._eventHash;
            var collectionId = collection.id;
            for (i = 0; i < removedLength; i++) {
                var removedEntity = removed[i];
                unsubscribeFromEntity(this, eventHash, collectionId, removedEntity);

                var removedId = removedEntity.id;
                //Check if the removed entity exists in any of the remaining collections
                //If so, we clean and remerge it.
                for (q = collectionsLength - 1; q >= 0; q--) {
                    entity = collections[q].getById(removedId);
                    if (defined(entity)) {
                        if (!defined(compositeEntity)) {
                            compositeEntity = composite.getById(removedId);
                            clean(compositeEntity);
                        }
                        compositeEntity.merge(entity);
                    }
                }
                //We never retrieved the compositeEntity, which means it no longer
                //exists in any of the collections, remove it from the composite.
                if (!defined(compositeEntity)) {
                    composite.removeById(removedId);
                }
                compositeEntity = undefined;
            }

            var addedLength = added.length;
            for (i = 0; i < addedLength; i++) {
                var addedEntity = added[i];
                subscribeToEntity(this, eventHash, collectionId, addedEntity);

                var addedId = addedEntity.id;
                //We know the added entity exists in at least one collection,
                //but we need to check all collections and re-merge in order
                //to maintain the priority of properties.
                for (q = collectionsLength - 1; q >= 0; q--) {
                    entity = collections[q].getById(addedId);
                    if (defined(entity)) {
                        if (!defined(compositeEntity)) {
                            compositeEntity = composite.getById(addedId);
                            if (!defined(compositeEntity)) {
                                entityOptionsScratch.id = addedId;
                                compositeEntity = new Entity(entityOptionsScratch);
                                composite.add(compositeEntity);
                            } else {
                                clean(compositeEntity);
                            }
                        }
                        compositeEntity.merge(entity);
                    }
                }
                compositeEntity = undefined;
            }

            composite.resumeEvents();
        };

        CompositeEntityCollection.prototype._onDefinitionChanged = function (entity, propertyName, newValue, oldValue) {
            var collections = this._collections;
            var composite = this._composite;

            var collectionsLength = collections.length;
            var id = entity.id;
            var compositeEntity = composite.getById(id);
            var compositeProperty = compositeEntity[propertyName];
            var newProperty = !defined(compositeProperty);

            var firstTime = true;
            for (var q = collectionsLength - 1; q >= 0; q--) {
                var innerEntity = collections[q].getById(entity.id);
                if (defined(innerEntity)) {
                    var property = innerEntity[propertyName];
                    if (defined(property)) {
                        if (firstTime) {
                            firstTime = false;
                            //We only want to clone if the property is also mergeable.
                            //This ensures that leaf properties are referenced and not copied,
                            //which is the entire point of compositing.
                            if (defined(property.merge) && defined(property.clone)) {
                                compositeProperty = property.clone(compositeProperty);
                            } else {
                                compositeProperty = property;
                                break;
                            }
                        }
                        compositeProperty.merge(property);
                    }
                }
            }

            if (newProperty && compositeEntity.propertyNames.indexOf(propertyName) === -1) {
                compositeEntity.addProperty(propertyName);
            }

            compositeEntity[propertyName] = compositeProperty;
        };

        return CompositeEntityCollection;
    }).call(this, $__require('2f'), $__require('23'), $__require('24'), $__require('25'), $__require('30'), $__require('31'), $__require('32'));
});
/*global define*/
$__System.registerDynamic('33', ['23', '24', '25'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError) {
        'use strict';

        /**
         * A collection of key-value pairs that is stored as a hash for easy
         * lookup but also provides an array for fast iteration.
         * @alias AssociativeArray
         * @constructor
         */

        function AssociativeArray() {
            this._array = [];
            this._hash = {};
        }

        defineProperties(AssociativeArray.prototype, {
            /**
             * Gets the number of items in the collection.
             * @memberof AssociativeArray.prototype
             *
             * @type {Number}
             */
            length: {
                get: function () {
                    return this._array.length;
                }
            },
            /**
             * Gets an unordered array of all values in the collection.
             * This is a live array that will automatically reflect the values in the collection,
             * it should not be modified directly.
             * @memberof AssociativeArray.prototype
             *
             * @type {Array}
             */
            values: {
                get: function () {
                    return this._array;
                }
            }
        });

        /**
         * Determines if the provided key is in the array.
         *
         * @param {String|Number} key The key to check.
         * @returns {Boolean} <code>true</code> if the key is in the array, <code>false</code> otherwise.
         */
        AssociativeArray.prototype.contains = function (key) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof key !== 'string' && typeof key !== 'number') {
                throw new DeveloperError('key is required to be a string or number.');
            }
            //>>includeEnd('debug');
            return defined(this._hash[key]);
        };

        /**
         * Associates the provided key with the provided value.  If the key already
         * exists, it is overwritten with the new value.
         *
         * @param {String|Number} key A unique identifier.
         * @param {Object} value The value to associate with the provided key.
         */
        AssociativeArray.prototype.set = function (key, value) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof key !== 'string' && typeof key !== 'number') {
                throw new DeveloperError('key is required to be a string or number.');
            }
            //>>includeEnd('debug');

            var oldValue = this._hash[key];
            if (value !== oldValue) {
                this.remove(key);
                this._hash[key] = value;
                this._array.push(value);
            }
        };

        /**
         * Retrieves the value associated with the provided key.
         *
         * @param {String|Number} key The key whose value is to be retrieved.
         * @returns {Object} The associated value, or undefined if the key does not exist in the collection.
         */
        AssociativeArray.prototype.get = function (key) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof key !== 'string' && typeof key !== 'number') {
                throw new DeveloperError('key is required to be a string or number.');
            }
            //>>includeEnd('debug');
            return this._hash[key];
        };

        /**
         * Removes a key-value pair from the collection.
         *
         * @param {String|Number} key The key to be removed.
         * @returns {Boolean} True if it was removed, false if the key was not in the collection.
         */
        AssociativeArray.prototype.remove = function (key) {
            //>>includeStart('debug', pragmas.debug);
            if (defined(key) && typeof key !== 'string' && typeof key !== 'number') {
                throw new DeveloperError('key is required to be a string or number.');
            }
            //>>includeEnd('debug');

            var value = this._hash[key];
            var hasValue = defined(value);
            if (hasValue) {
                var array = this._array;
                array.splice(array.indexOf(value), 1);
                delete this._hash[key];
            }
            return hasValue;
        };

        /**
         * Clears the collection.
         */
        AssociativeArray.prototype.removeAll = function () {
            var array = this._array;
            if (array.length > 0) {
                this._hash = {};
                array.length = 0;
            }
        };

        return AssociativeArray;
    }).call(this, $__require('23'), $__require('24'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('2f', [], false, function ($__require, $__exports, $__module) {
    return (function () {
        'use strict';

        /**
         * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
         *
         * @exports createGuid
         *
         * @returns {String}
         *
         *
         * @example
         * this.guid = Cesium.createGuid();
         * 
         * @see {@link http://www.ietf.org/rfc/rfc4122.txt|RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace}
         */

        function createGuid() {
            // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0;
                var v = c === 'x' ? r : r & 0x3 | 0x8;
                return v.toString(16);
            });
        }

        return createGuid;
    }).call(this);
});
/*global define*/
$__System.registerDynamic('34', ['35', '2c', '23', '24', '25', '26', '36', '37'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Event, ReferenceFrame, PositionProperty) {
        'use strict';

        /**
         * A {@link PositionProperty} whose value does not change in respect to the
         * {@link ReferenceFrame} in which is it defined.
         *
         * @alias ConstantPositionProperty
         * @constructor
         *
         * @param {Cartesian3} [value] The property value.
         * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
         */

        function ConstantPositionProperty(value, referenceFrame) {
            this._definitionChanged = new Event();
            this._value = Cartesian3.clone(value);
            this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
        }

        defineProperties(ConstantPositionProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.  A property is considered
             * constant if getValue always returns the same result for the current definition.
             * @memberof ConstantPositionProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: function () {
                    return !defined(this._value) || this._referenceFrame === ReferenceFrame.FIXED;
                }
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is considered to have changed if a call to getValue would return
             * a different result for the same time.
             * @memberof ConstantPositionProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            },
            /**
             * Gets the reference frame in which the position is defined.
             * @memberof ConstantPositionProperty.prototype
             * @type {ReferenceFrame}
             * @default ReferenceFrame.FIXED;
             */
            referenceFrame: {
                get: function () {
                    return this._referenceFrame;
                }
            }
        });

        /**
         * Gets the value of the property at the provided time in the fixed frame.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        ConstantPositionProperty.prototype.getValue = function (time, result) {
            return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
        };

        /**
         * Sets the value of the property.
         *
         * @param {Cartesian3} value The property value.
         * @param {ReferenceFrame} [referenceFrame=this.referenceFrame] The reference frame in which the position is defined.
         */
        ConstantPositionProperty.prototype.setValue = function (value, referenceFrame) {
            var definitionChanged = false;
            if (!Cartesian3.equals(this._value, value)) {
                definitionChanged = true;
                this._value = Cartesian3.clone(value);
            }
            if (defined(referenceFrame) && this._referenceFrame !== referenceFrame) {
                definitionChanged = true;
                this._referenceFrame = referenceFrame;
            }
            if (definitionChanged) {
                this._definitionChanged.raiseEvent(this);
            }
        };

        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
         * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        ConstantPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(time)) {
                throw new DeveloperError('time is required.');
            }
            if (!defined(referenceFrame)) {
                throw new DeveloperError('referenceFrame is required.');
            }
            //>>includeEnd('debug');

            return PositionProperty.convertToReferenceFrame(time, this._value, this._referenceFrame, referenceFrame, result);
        };

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        ConstantPositionProperty.prototype.equals = function (other) {
            return this === other || other instanceof ConstantPositionProperty && Cartesian3.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame;
        };

        return ConstantPositionProperty;
    }).call(this, $__require('35'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('36'), $__require('37'));
});
/*global define*/
$__System.registerDynamic('38', ['2c', '23', '24', '25', '26'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, defineProperties, DeveloperError, Event) {
        'use strict';

        /**
         * A {@link Property} whose value does not change with respect to simulation time.
         *
         * @alias ConstantProperty
         * @constructor
         *
         * @param {Object} [value] The property value.
         *
         * @see ConstantPositionProperty
         *
         * @exception {DeveloperError} value.clone is a required function.
         * @exception {DeveloperError} value.equals is a required function.
         */

        function ConstantProperty(value) {
            this._value = undefined;
            this._hasClone = false;
            this._hasEquals = false;
            this._definitionChanged = new Event();
            this.setValue(value);
        }

        defineProperties(ConstantProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.
             * This property always returns <code>true</code>.
             * @memberof ConstantProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                value: true
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is changed whenever setValue is called with data different
             * than the current value.
             * @memberof ConstantProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            }
        });

        /**
         * Gets the value of the property.
         *
         * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        ConstantProperty.prototype.getValue = function (time, result) {
            return this._hasClone ? this._value.clone(result) : this._value;
        };

        /**
         * Sets the value of the property.
         *
         * @param {Object} value The property value.
         *
         * @exception {DeveloperError} value.clone is a required function.
         * @exception {DeveloperError} value.equals is a required function.
         */
        ConstantProperty.prototype.setValue = function (value) {
            var oldValue = this._value;
            if (oldValue !== value) {
                var isDefined = defined(value);
                var hasClone = isDefined && typeof value.clone === 'function';
                var hasEquals = isDefined && typeof value.equals === 'function';

                this._hasClone = hasClone;
                this._hasEquals = hasEquals;

                var changed = !hasEquals || !value.equals(oldValue);
                if (changed) {
                    this._value = !hasClone ? value : value.clone();
                    this._definitionChanged.raiseEvent(this);
                }
            }
        };

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        ConstantProperty.prototype.equals = function (other) {
            return this === other || //
            other instanceof ConstantProperty && ( //
            !this._hasEquals && this._value === other._value || //
            this._hasEquals && this._value.equals(other._value));
        };

        return ConstantProperty;
    }).call(this, $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('26'));
});
/*global define*/
$__System.registerDynamic('39', ['2c', '23', '38'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, ConstantProperty) {
        'use strict';

        function createProperty(name, privateName, subscriptionName, configurable, createPropertyCallback) {
            return {
                configurable: configurable,
                get: function () {
                    return this[privateName];
                },
                set: function (value) {
                    var oldValue = this[privateName];
                    var subscription = this[subscriptionName];
                    if (defined(subscription)) {
                        subscription();
                        this[subscriptionName] = undefined;
                    }

                    var hasValue = defined(value);
                    if (hasValue && !defined(value.getValue) && defined(createPropertyCallback)) {
                        value = createPropertyCallback(value);
                    }

                    if (oldValue !== value) {
                        this[privateName] = value;
                        this._definitionChanged.raiseEvent(this, name, value, oldValue);
                    }

                    if (defined(value) && defined(value.definitionChanged)) {
                        this[subscriptionName] = value.definitionChanged.addEventListener(function () {
                            this._definitionChanged.raiseEvent(this, name, value, value);
                        }, this);
                    }
                }
            };
        }

        function createConstantProperty(value) {
            return new ConstantProperty(value);
        }

        /**
         * Used to consistently define all DataSources graphics objects.
         * This is broken into two functions because the Chrome profiler does a better
         * job of optimizing lookups if it notices that the string is constant throughout the function.
         * @private
         */
        function createPropertyDescriptor(name, configurable, createPropertyCallback) {
            //Safari 8.0.3 has a JavaScript bug that causes it to confuse two variables and treat them as the same.
            //The two extra toString calls work around the issue.
            return createProperty(name, '_' + name.toString(), '_' + name.toString() + 'Subscription', defaultValue(configurable, false), defaultValue(createPropertyCallback, createConstantProperty));
        }

        return createPropertyDescriptor;
    }).call(this, $__require('2c'), $__require('23'), $__require('38'));
});
/*global define*/
$__System.registerDynamic('3a', ['39'], false, function ($__require, $__exports, $__module) {
    return (function (createPropertyDescriptor) {
        'use strict';

        function createRawProperty(value) {
            return value;
        }

        /**
         * @private
         */
        function createRawPropertyDescriptor(name, configurable) {
            return createPropertyDescriptor(name, configurable, createRawProperty);
        }

        return createRawPropertyDescriptor;
    }).call(this, $__require('39'));
});
/*global define*/
$__System.registerDynamic('31', ['35', '2f', '2c', '23', '24', '25', '26', '3b', '3c', '3d', '3e', '@empty', '@empty', '34', '@empty', '39', '3a', '@empty', '@empty', '@empty', '@empty', '@empty', '@empty', '@empty', '@empty', '@empty', '@empty', '3f', '@empty', '@empty'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, createGuid, defaultValue, defined, defineProperties, DeveloperError, Event, Matrix3, Matrix4, Quaternion, Transforms, BillboardGraphics, BoxGraphics, ConstantPositionProperty, CorridorGraphics, createPropertyDescriptor, createRawPropertyDescriptor, CylinderGraphics, EllipseGraphics, EllipsoidGraphics, LabelGraphics, ModelGraphics, PathGraphics, PointGraphics, PolygonGraphics, PolylineGraphics, PolylineVolumeGraphics, Property, RectangleGraphics, WallGraphics) {
        'use strict';

        function createConstantPositionProperty(value) {
            return new ConstantPositionProperty(value);
        }

        function createPositionPropertyDescriptor(name) {
            return createPropertyDescriptor(name, undefined, createConstantPositionProperty);
        }

        function createPropertyTypeDescriptor(name, Type) {
            return createPropertyDescriptor(name, undefined, function (value) {
                if (value instanceof Type) {
                    return value;
                }
                return new Type(value);
            });
        }

        /**
         * Entity instances aggregate multiple forms of visualization into a single high-level object.
         * They can be created manually and added to {@link Viewer#entities} or be produced by
         * data sources, such as {@link CzmlDataSource} and {@link GeoJsonDataSource}.
         * @alias Entity
         * @constructor
         *
         * @param {Object} [options] Object with the following properties:
         * @param {String} [options.id] A unique identifier for this object. If none is provided, a GUID is generated.
         * @param {String} [options.name] A human readable name to display to users. It does not have to be unique.
         * @param {TimeIntervalCollection} [options.availability] The availability, if any, associated with this object.
         * @param {Boolean} [options.show] A boolean value indicating if the entity and its children are displayed.
         * @param {Property} [options.description] A string Property specifying an HTML description for this entity.
         * @param {PositionProperty} [options.position] A Property specifying the entity position.
         * @param {Property} [options.orientation] A Property specifying the entity orientation.
         * @param {Property} [options.viewFrom] A suggested initial offset for viewing this object.
         * @param {Entity} [options.parent] A parent entity to associate with this entity.
         * @param {BillboardGraphics} [options.billboard] A billboard to associate with this entity.
         * @param {BoxGraphics} [options.box] A box to associate with this entity.
         * @param {CorridorGraphics} [options.corridor] A corridor to associate with this entity.
         * @param {CylinderGraphics} [options.cylinder] A cylinder to associate with this entity.
         * @param {EllipseGraphics} [options.ellipse] A ellipse to associate with this entity.
         * @param {EllipsoidGraphics} [options.ellipsoid] A ellipsoid to associate with this entity.
         * @param {LabelGraphics} [options.label] A options.label to associate with this entity.
         * @param {ModelGraphics} [options.model] A model to associate with this entity.
         * @param {PathGraphics} [options.path] A path to associate with this entity.
         * @param {PointGraphics} [options.point] A point to associate with this entity.
         * @param {PolygonGraphics} [options.polygon] A polygon to associate with this entity.
         * @param {PolylineGraphics} [options.polyline] A polyline to associate with this entity.
         * @param {PolylineVolumeGraphics} [options.polylineVolume] A polylineVolume to associate with this entity.
         * @param {RectangleGraphics} [options.rectangle] A rectangle to associate with this entity.
         * @param {WallGraphics} [options.wall] A wall to associate with this entity.
         *
         * @see {@link http://cesiumjs.org/2015/02/02/Visualizing-Spatial-Data/|Visualizing Spatial Data}
         */
        function Entity(options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);

            var id = options.id;
            if (!defined(id)) {
                id = createGuid();
            }

            this._availability = undefined;
            this._id = id;
            this._definitionChanged = new Event();
            this._name = options.name;
            this._show = defaultValue(options.show, true);
            this._parent = undefined;
            this._propertyNames = ['billboard', 'box', 'corridor', 'cylinder', 'description', 'ellipse', //
            'ellipsoid', 'label', 'model', 'orientation', 'path', 'point', 'polygon', //
            'polyline', 'polylineVolume', 'position', 'rectangle', 'viewFrom', 'wall'];

            this._billboard = undefined;
            this._billboardSubscription = undefined;
            this._box = undefined;
            this._boxSubscription = undefined;
            this._corridor = undefined;
            this._corridorSubscription = undefined;
            this._cylinder = undefined;
            this._cylinderSubscription = undefined;
            this._description = undefined;
            this._descriptionSubscription = undefined;
            this._ellipse = undefined;
            this._ellipseSubscription = undefined;
            this._ellipsoid = undefined;
            this._ellipsoidSubscription = undefined;
            this._label = undefined;
            this._labelSubscription = undefined;
            this._model = undefined;
            this._modelSubscription = undefined;
            this._orientation = undefined;
            this._orientationSubscription = undefined;
            this._path = undefined;
            this._pathSubscription = undefined;
            this._point = undefined;
            this._pointSubscription = undefined;
            this._polygon = undefined;
            this._polygonSubscription = undefined;
            this._polyline = undefined;
            this._polylineSubscription = undefined;
            this._polylineVolume = undefined;
            this._polylineVolumeSubscription = undefined;
            this._position = undefined;
            this._positionSubscription = undefined;
            this._rectangle = undefined;
            this._rectangleSubscription = undefined;
            this._viewFrom = undefined;
            this._viewFromSubscription = undefined;
            this._wall = undefined;
            this._wallSubscription = undefined;
            this._children = [];

            /**
             * Gets or sets the entity collection that this entity belongs to.
             * @type {EntityCollection}
             */
            this.entityCollection = undefined;

            this.parent = options.parent;
            this.merge(options);
        }

        function updateShow(entity, children, isShowing) {
            var length = children.length;
            for (var i = 0; i < length; i++) {
                var child = children[i];
                var childShow = child._show;
                var oldValue = !isShowing && childShow;
                var newValue = isShowing && childShow;
                if (oldValue !== newValue) {
                    updateShow(child, child._children, isShowing);
                }
            }
            entity._definitionChanged.raiseEvent(entity, 'isShowing', isShowing, !isShowing);
        }

        defineProperties(Entity.prototype, {
            /**
             * The availability, if any, associated with this object.
             * If availability is undefined, it is assumed that this object's
             * other properties will return valid data for any provided time.
             * If availability exists, the objects other properties will only
             * provide valid data if queried within the given interval.
             * @memberof Entity.prototype
             * @type {TimeIntervalCollection}
             */
            availability: createRawPropertyDescriptor('availability'),
            /**
             * Gets the unique ID associated with this object.
             * @memberof Entity.prototype
             * @type {String}
             */
            id: {
                get: function () {
                    return this._id;
                }
            },
            /**
             * Gets the event that is raised whenever a property or sub-property is changed or modified.
             * @memberof Entity.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            },
            /**
             * Gets or sets the name of the object.  The name is intended for end-user
             * consumption and does not need to be unique.
             * @memberof Entity.prototype
             * @type {String}
             */
            name: createRawPropertyDescriptor('name'),
            /**
             * Gets or sets whether this entity should be displayed. When set to true,
             * the entity is only displayed if the parent entity's show property is also true.
             * @memberof Entity.prototype
             * @type {Boolean}
             */
            show: {
                get: function () {
                    return this._show;
                },
                set: function (value) {
                    //>>includeStart('debug', pragmas.debug);
                    if (!defined(value)) {
                        throw new DeveloperError('value is required.');
                    }
                    //>>includeEnd('debug');

                    if (value === this._show) {
                        return;
                    }

                    var wasShowing = this.isShowing;
                    this._show = value;
                    var isShowing = this.isShowing;

                    if (wasShowing !== isShowing) {
                        updateShow(this, this._children, isShowing);
                    }

                    this._definitionChanged.raiseEvent(this, 'show', value, !value);
                }
            },
            /**
             * Gets whether this entity is being displayed, taking into account
             * the visibility of any ancestor entities.
             * @memberof Entity.prototype
             * @type {Boolean}
             */
            isShowing: {
                get: function () {
                    return this._show && (!defined(this.entityCollection) || this.entityCollection.show) && (!defined(this._parent) || this._parent.isShowing);
                }
            },
            /**
             * Gets or sets the parent object.
             * @memberof Entity.prototype
             * @type {Entity}
             */
            parent: {
                get: function () {
                    return this._parent;
                },
                set: function (value) {
                    var oldValue = this._parent;

                    if (oldValue === value) {
                        return;
                    }

                    var wasShowing = this.isShowing;
                    if (defined(oldValue)) {
                        var index = oldValue._children.indexOf(this);
                        oldValue._children.splice(index, 1);
                    }

                    this._parent = value;
                    if (defined(value)) {
                        value._children.push(this);
                    }

                    var isShowing = this.isShowing;

                    if (wasShowing !== isShowing) {
                        updateShow(this, this._children, isShowing);
                    }

                    this._definitionChanged.raiseEvent(this, 'parent', value, oldValue);
                }
            },
            /**
             * Gets the names of all properties registered on this instance.
             * @memberof Entity.prototype
             * @type {Array}
             */
            propertyNames: {
                get: function () {
                    return this._propertyNames;
                }
            },
            /**
             * Gets or sets the billboard.
             * @memberof Entity.prototype
             * @type {BillboardGraphics}
             */
            billboard: createPropertyTypeDescriptor('billboard', BillboardGraphics),
            /**
             * Gets or sets the box.
             * @memberof Entity.prototype
             * @type {BoxGraphics}
             */
            box: createPropertyTypeDescriptor('box', BoxGraphics),
            /**
             * Gets or sets the corridor.
             * @memberof Entity.prototype
             * @type {CorridorGraphics}
             */
            corridor: createPropertyTypeDescriptor('corridor', CorridorGraphics),
            /**
             * Gets or sets the cylinder.
             * @memberof Entity.prototype
             * @type {CylinderGraphics}
             */
            cylinder: createPropertyTypeDescriptor('cylinder', CylinderGraphics),
            /**
             * Gets or sets the description.
             * @memberof Entity.prototype
             * @type {Property}
             */
            description: createPropertyDescriptor('description'),
            /**
             * Gets or sets the ellipse.
             * @memberof Entity.prototype
             * @type {EllipseGraphics}
             */
            ellipse: createPropertyTypeDescriptor('ellipse', EllipseGraphics),
            /**
             * Gets or sets the ellipsoid.
             * @memberof Entity.prototype
             * @type {EllipsoidGraphics}
             */
            ellipsoid: createPropertyTypeDescriptor('ellipsoid', EllipsoidGraphics),
            /**
             * Gets or sets the label.
             * @memberof Entity.prototype
             * @type {LabelGraphics}
             */
            label: createPropertyTypeDescriptor('label', LabelGraphics),
            /**
             * Gets or sets the model.
             * @memberof Entity.prototype
             * @type {ModelGraphics}
             */
            model: createPropertyTypeDescriptor('model', ModelGraphics),
            /**
             * Gets or sets the orientation.
             * @memberof Entity.prototype
             * @type {Property}
             */
            orientation: createPropertyDescriptor('orientation'),
            /**
             * Gets or sets the path.
             * @memberof Entity.prototype
             * @type {PathGraphics}
             */
            path: createPropertyTypeDescriptor('path', PathGraphics),
            /**
             * Gets or sets the point graphic.
             * @memberof Entity.prototype
             * @type {PointGraphics}
             */
            point: createPropertyTypeDescriptor('point', PointGraphics),
            /**
             * Gets or sets the polygon.
             * @memberof Entity.prototype
             * @type {PolygonGraphics}
             */
            polygon: createPropertyTypeDescriptor('polygon', PolygonGraphics),
            /**
             * Gets or sets the polyline.
             * @memberof Entity.prototype
             * @type {PolylineGraphics}
             */
            polyline: createPropertyTypeDescriptor('polyline', PolylineGraphics),
            /**
             * Gets or sets the polyline volume.
             * @memberof Entity.prototype
             * @type {PolylineVolumeGraphics}
             */
            polylineVolume: createPropertyTypeDescriptor('polylineVolume', PolylineVolumeGraphics),
            /**
             * Gets or sets the position.
             * @memberof Entity.prototype
             * @type {PositionProperty}
             */
            position: createPositionPropertyDescriptor('position'),
            /**
             * Gets or sets the rectangle.
             * @memberof Entity.prototype
             * @type {RectangleGraphics}
             */
            rectangle: createPropertyTypeDescriptor('rectangle', RectangleGraphics),
            /**
             * Gets or sets the suggested initial offset for viewing this object
             * with the camera.  The offset is defined in the east-north-up reference frame.
             * @memberof Entity.prototype
             * @type {Property}
             */
            viewFrom: createPropertyDescriptor('viewFrom'),
            /**
             * Gets or sets the wall.
             * @memberof Entity.prototype
             * @type {WallGraphics}
             */
            wall: createPropertyTypeDescriptor('wall', WallGraphics)
        });

        /**
         * Given a time, returns true if this object should have data during that time.
         *
         * @param {JulianDate} time The time to check availability for.
         * @returns {Boolean} true if the object should have data during the provided time, false otherwise.
         */
        Entity.prototype.isAvailable = function (time) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(time)) {
                throw new DeveloperError('time is required.');
            }
            //>>includeEnd('debug');

            var availability = this._availability;
            return !defined(availability) || availability.contains(time);
        };

        /**
         * Adds a property to this object.  Once a property is added, it can be
         * observed with {@link Entity#definitionChanged} and composited
         * with {@link CompositeEntityCollection}
         *
         * @param {String} propertyName The name of the property to add.
         *
         * @exception {DeveloperError} "propertyName" is a reserved property name.
         * @exception {DeveloperError} "propertyName" is already a registered property.
         */
        Entity.prototype.addProperty = function (propertyName) {
            var propertyNames = this._propertyNames;

            //>>includeStart('debug', pragmas.debug);
            if (!defined(propertyName)) {
                throw new DeveloperError('propertyName is required.');
            }
            if (propertyNames.indexOf(propertyName) !== -1) {
                throw new DeveloperError(propertyName + ' is already a registered property.');
            }
            if (propertyName in this) {
                throw new DeveloperError(propertyName + ' is a reserved property name.');
            }
            //>>includeEnd('debug');

            propertyNames.push(propertyName);
            Object.defineProperty(this, propertyName, createRawPropertyDescriptor(propertyName, true));
        };

        /**
         * Removed a property previously added with addProperty.
         *
         * @param {String} propertyName The name of the property to remove.
         *
         * @exception {DeveloperError} "propertyName" is a reserved property name.
         * @exception {DeveloperError} "propertyName" is not a registered property.
         */
        Entity.prototype.removeProperty = function (propertyName) {
            var propertyNames = this._propertyNames;
            var index = propertyNames.indexOf(propertyName);

            //>>includeStart('debug', pragmas.debug);
            if (!defined(propertyName)) {
                throw new DeveloperError('propertyName is required.');
            }
            if (index === -1) {
                throw new DeveloperError(propertyName + ' is not a registered property.');
            }
            //>>includeEnd('debug');

            this._propertyNames.splice(index, 1);
            delete this[propertyName];
        };

        /**
         * Assigns each unassigned property on this object to the value
         * of the same property on the provided source object.
         *
         * @param {Entity} source The object to be merged into this object.
         */
        Entity.prototype.merge = function (source) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(source)) {
                throw new DeveloperError('source is required.');
            }
            //>>includeEnd('debug');

            //Name, show, and availability are not Property objects and are currently handled differently.
            //source.show is intentionally ignored because this.show always has a value.
            this.name = defaultValue(this.name, source.name);
            this.availability = defaultValue(source.availability, this.availability);

            var propertyNames = this._propertyNames;
            var sourcePropertyNames = defined(source._propertyNames) ? source._propertyNames : Object.keys(source);
            var propertyNamesLength = sourcePropertyNames.length;
            for (var i = 0; i < propertyNamesLength; i++) {
                var name = sourcePropertyNames[i];

                //Ignore parent when merging, this only happens at construction time.
                if (name === 'parent') {
                    continue;
                }

                var targetProperty = this[name];
                var sourceProperty = source[name];

                //Custom properties that are registered on the source entity must also
                //get registered on this entity.
                if (!defined(targetProperty) && propertyNames.indexOf(name) === -1) {
                    this.addProperty(name);
                }

                if (defined(sourceProperty)) {
                    if (defined(targetProperty)) {
                        if (defined(targetProperty.merge)) {
                            targetProperty.merge(sourceProperty);
                        }
                    } else if (defined(sourceProperty.merge) && defined(sourceProperty.clone)) {
                        this[name] = sourceProperty.clone();
                    } else {
                        this[name] = sourceProperty;
                    }
                }
            }
        };

        var matrix3Scratch = new Matrix3();
        var positionScratch = new Cartesian3();
        var orientationScratch = new Quaternion();

        /**
         * @private
         */
        Entity.prototype._getModelMatrix = function (time, result) {
            var position = Property.getValueOrUndefined(this._position, time, positionScratch);
            if (!defined(position)) {
                return undefined;
            }
            var orientation = Property.getValueOrUndefined(this._orientation, time, orientationScratch);
            if (!defined(orientation)) {
                result = Transforms.eastNorthUpToFixedFrame(position, undefined, result);
            } else {
                result = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, result);
            }
            return result;
        };

        return Entity;
    }).call(this, $__require('35'), $__require('2f'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('3b'), $__require('3c'), $__require('3d'), $__require('3e'), $__require('@empty'), $__require('@empty'), $__require('34'), $__require('@empty'), $__require('39'), $__require('3a'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('@empty'), $__require('3f'), $__require('@empty'), $__require('@empty'));
});
/*global define*/
$__System.registerDynamic('32', ['33', '2f', '23', '24', '25', '26', '40', '2d', '41', '42', '31'], false, function ($__require, $__exports, $__module) {
    return (function (AssociativeArray, createGuid, defined, defineProperties, DeveloperError, Event, Iso8601, JulianDate, RuntimeError, TimeInterval, Entity) {
        'use strict';

        var entityOptionsScratch = {
            id: undefined
        };

        function fireChangedEvent(collection) {
            if (collection._firing) {
                collection._refire = true;
                return;
            }

            if (collection._suspendCount === 0) {
                var added = collection._addedEntities;
                var removed = collection._removedEntities;
                var changed = collection._changedEntities;
                if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
                    collection._firing = true;
                    do {
                        collection._refire = false;
                        var addedArray = added.values.slice(0);
                        var removedArray = removed.values.slice(0);
                        var changedArray = changed.values.slice(0);

                        added.removeAll();
                        removed.removeAll();
                        changed.removeAll();
                        collection._collectionChanged.raiseEvent(collection, addedArray, removedArray, changedArray);
                    } while (collection._refire);
                    collection._firing = false;
                }
            }
        }

        /**
         * An observable collection of {@link Entity} instances where each entity has a unique id.
         * @alias EntityCollection
         * @constructor
         *
         * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.
         */
        function EntityCollection(owner) {
            this._owner = owner;
            this._entities = new AssociativeArray();
            this._addedEntities = new AssociativeArray();
            this._removedEntities = new AssociativeArray();
            this._changedEntities = new AssociativeArray();
            this._suspendCount = 0;
            this._collectionChanged = new Event();
            this._id = createGuid();
            this._show = true;
            this._firing = false;
            this._refire = false;
        }

        /**
         * Prevents {@link EntityCollection#collectionChanged} events from being raised
         * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
         * point a single event will be raised that covers all suspended operations.
         * This allows for many items to be added and removed efficiently.
         * This function can be safely called multiple times as long as there
         * are corresponding calls to {@link EntityCollection#resumeEvents}.
         */
        EntityCollection.prototype.suspendEvents = function () {
            this._suspendCount++;
        };

        /**
         * Resumes raising {@link EntityCollection#collectionChanged} events immediately
         * when an item is added or removed.  Any modifications made while while events were suspended
         * will be triggered as a single event when this function is called.
         * This function is reference counted and can safely be called multiple times as long as there
         * are corresponding calls to {@link EntityCollection#resumeEvents}.
         *
         * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.
         */
        EntityCollection.prototype.resumeEvents = function () {
            //>>includeStart('debug', pragmas.debug);
            if (this._suspendCount === 0) {
                throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
            }
            //>>includeEnd('debug');

            this._suspendCount--;
            fireChangedEvent(this);
        };

        /**
         * The signature of the event generated by {@link EntityCollection#collectionChanged}.
         * @function
         *
         * @param {EntityCollection} collection The collection that triggered the event.
         * @param {Entity[]} added The array of {@link Entity} instances that have been added to the collection.
         * @param {Entity[]} removed The array of {@link Entity} instances that have been removed from the collection.
         * @param {Entity[]} changed The array of {@link Entity} instances that have been modified.
         */
        EntityCollection.collectionChangedEventCallback = undefined;

        defineProperties(EntityCollection.prototype, {
            /**
             * Gets the event that is fired when entities are added or removed from the collection.
             * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
             * @memberof EntityCollection.prototype
             * @readonly
             * @type {Event}
             */
            collectionChanged: {
                get: function () {
                    return this._collectionChanged;
                }
            },
            /**
             * Gets a globally unique identifier for this collection.
             * @memberof EntityCollection.prototype
             * @readonly
             * @type {String}
             */
            id: {
                get: function () {
                    return this._id;
                }
            },
            /**
             * Gets the array of Entity instances in the collection.
             * This array should not be modified directly.
             * @memberof EntityCollection.prototype
             * @readonly
             * @type {Entity[]}
             */
            values: {
                get: function () {
                    return this._entities.values;
                }
            },
            /**
             * Gets whether or not this entity collection should be
             * displayed.  When true, each entity is only displayed if
             * its own show property is also true.
             * @memberof EntityCollection.prototype
             * @type {Boolean}
             */
            show: {
                get: function () {
                    return this._show;
                },
                set: function (value) {
                    //>>includeStart('debug', pragmas.debug);
                    if (!defined(value)) {
                        throw new DeveloperError('value is required.');
                    }
                    //>>includeEnd('debug');

                    if (value === this._show) {
                        return;
                    }

                    //Since entity.isShowing includes the EntityCollection.show state
                    //in its calculation, we need to loop over the entities array
                    //twice, once to get the old showing value and a second time
                    //to raise the changed event.
                    this.suspendEvents();

                    var i;
                    var oldShows = [];
                    var entities = this._entities.values;
                    var entitiesLength = entities.length;

                    for (i = 0; i < entitiesLength; i++) {
                        oldShows.push(entities[i].isShowing);
                    }

                    this._show = value;

                    for (i = 0; i < entitiesLength; i++) {
                        var oldShow = oldShows[i];
                        var entity = entities[i];
                        if (oldShow !== entity.isShowing) {
                            entity.definitionChanged.raiseEvent(entity, 'isShowing', entity.isShowing, oldShow);
                        }
                    }

                    this.resumeEvents();
                }
            },
            /**
             * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.
             * @memberof EntityCollection.prototype
             * @readonly
             * @type {DataSource|CompositeEntityCollection}
             */
            owner: {
                get: function () {
                    return this._owner;
                }
            }
        });

        /**
         * Computes the maximum availability of the entities in the collection.
         * If the collection contains a mix of infinitely available data and non-infinite data,
         * it will return the interval pertaining to the non-infinite data only.  If all
         * data is infinite, an infinite interval will be returned.
         *
         * @returns {TimeInterval} The availability of entities in the collection.
         */
        EntityCollection.prototype.computeAvailability = function () {
            var startTime = Iso8601.MAXIMUM_VALUE;
            var stopTime = Iso8601.MINIMUM_VALUE;
            var entities = this._entities.values;
            for (var i = 0, len = entities.length; i < len; i++) {
                var entity = entities[i];
                var availability = entity.availability;
                if (defined(availability)) {
                    var start = availability.start;
                    var stop = availability.stop;
                    if (JulianDate.lessThan(start, startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
                        startTime = start;
                    }
                    if (JulianDate.greaterThan(stop, stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
                        stopTime = stop;
                    }
                }
            }

            if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {
                startTime = Iso8601.MINIMUM_VALUE;
            }
            if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {
                stopTime = Iso8601.MAXIMUM_VALUE;
            }
            return new TimeInterval({
                start: startTime,
                stop: stopTime
            });
        };

        /**
         * Add an entity to the collection.
         *
         * @param {Entity} entity The entity to be added.
         * @returns {Entity} The entity that was added.
         * @exception {DeveloperError} An entity with <entity.id> already exists in this collection.
         */
        EntityCollection.prototype.add = function (entity) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(entity)) {
                throw new DeveloperError('entity is required.');
            }
            //>>includeEnd('debug');

            if (!(entity instanceof Entity)) {
                entity = new Entity(entity);
            }

            var id = entity.id;
            var entities = this._entities;
            if (entities.contains(id)) {
                throw new RuntimeError('An entity with id ' + id + ' already exists in this collection.');
            }

            entity.entityCollection = this;
            entities.set(id, entity);

            if (!this._removedEntities.remove(id)) {
                this._addedEntities.set(id, entity);
            }
            entity.definitionChanged.addEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);

            fireChangedEvent(this);
            return entity;
        };

        /**
         * Removes an entity from the collection.
         *
         * @param {Entity} entity The entity to be removed.
         * @returns {Boolean} true if the item was removed, false if it did not exist in the collection.
         */
        EntityCollection.prototype.remove = function (entity) {
            if (!defined(entity)) {
                return false;
            }
            return this.removeById(entity.id);
        };

        /**
         * Returns true if the provided entity is in this collection, false otherwise.
         *
         * @param {Entity} entity The entity.
         * @returns {Boolean} true if the provided entity is in this collection, false otherwise.
         */
        EntityCollection.prototype.contains = function (entity) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(entity)) {
                throw new DeveloperError('entity is required');
            }
            //>>includeEnd('debug');
            return this._entities.get(entity.id) === entity;
        };

        /**
         * Removes an entity with the provided id from the collection.
         *
         * @param {Object} id The id of the entity to remove.
         * @returns {Boolean} true if the item was removed, false if no item with the provided id existed in the collection.
         */
        EntityCollection.prototype.removeById = function (id) {
            if (!defined(id)) {
                return false;
            }

            var entities = this._entities;
            var entity = entities.get(id);
            if (!this._entities.remove(id)) {
                return false;
            }

            if (!this._addedEntities.remove(id)) {
                this._removedEntities.set(id, entity);
                this._changedEntities.remove(id);
            }
            this._entities.remove(id);
            entity.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
            fireChangedEvent(this);

            return true;
        };

        /**
         * Removes all Entities from the collection.
         */
        EntityCollection.prototype.removeAll = function () {
            //The event should only contain items added before events were suspended
            //and the contents of the collection.
            var entities = this._entities;
            var entitiesLength = entities.length;
            var array = entities.values;

            var addedEntities = this._addedEntities;
            var removed = this._removedEntities;

            for (var i = 0; i < entitiesLength; i++) {
                var existingItem = array[i];
                var existingItemId = existingItem.id;
                var addedItem = addedEntities.get(existingItemId);
                if (!defined(addedItem)) {
                    existingItem.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
                    removed.set(existingItemId, existingItem);
                }
            }

            entities.removeAll();
            addedEntities.removeAll();
            this._changedEntities.removeAll();
            fireChangedEvent(this);
        };

        /**
         * Gets an entity with the specified id.
         *
         * @param {Object} id The id of the entity to retrieve.
         * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.
         */
        EntityCollection.prototype.getById = function (id) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(id)) {
                throw new DeveloperError('id is required.');
            }
            //>>includeEnd('debug');

            return this._entities.get(id);
        };

        /**
         * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.
         *
         * @param {Object} id The id of the entity to retrieve or create.
         * @returns {Entity} The new or existing object.
         */
        EntityCollection.prototype.getOrCreateEntity = function (id) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(id)) {
                throw new DeveloperError('id is required.');
            }
            //>>includeEnd('debug');

            var entity = this._entities.get(id);
            if (!defined(entity)) {
                entityOptionsScratch.id = id;
                entity = new Entity(entityOptionsScratch);
                this.add(entity);
            }
            return entity;
        };

        EntityCollection.prototype._onEntityDefinitionChanged = function (entity) {
            var id = entity.id;
            if (!this._addedEntities.contains(id)) {
                this._changedEntities.set(id, entity);
            }
            fireChangedEvent(this);
        };

        return EntityCollection;
    }).call(this, $__require('33'), $__require('2f'), $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('40'), $__require('2d'), $__require('41'), $__require('42'), $__require('31'));
});
/*global define*/
$__System.registerDynamic('43', ['35', '44', '2c', '23', '24', '25', '45'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid) {
        'use strict';

        /**
         * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
         * them by the {@link Ellipsoid#maximumRadius}.  This projection
         * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
         * is also known as EPSG:4326.
         *
         * @alias GeographicProjection
         * @constructor
         *
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.
         *
         * @see WebMercatorProjection
         */

        function GeographicProjection(ellipsoid) {
            this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
            this._semimajorAxis = this._ellipsoid.maximumRadius;
            this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;
        }

        defineProperties(GeographicProjection.prototype, {
            /**
             * Gets the {@link Ellipsoid}.
             *
             * @memberof GeographicProjection.prototype
             *
             * @type {Ellipsoid}
             * @readonly
             */
            ellipsoid: {
                get: function () {
                    return this._ellipsoid;
                }
            }
        });

        /**
         * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
         * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
         * ellipsoid.  Z is the unmodified height.
         *
         * @param {Cartographic} cartographic The coordinates to project.
         * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is
         *        undefined, a new instance is created and returned.
         * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the
         *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
         *          created and returned.
         */
        GeographicProjection.prototype.project = function (cartographic, result) {
            // Actually this is the special case of equidistant cylindrical called the plate carree
            var semimajorAxis = this._semimajorAxis;
            var x = cartographic.longitude * semimajorAxis;
            var y = cartographic.latitude * semimajorAxis;
            var z = cartographic.height;

            if (!defined(result)) {
                return new Cartesian3(x, y, z);
            }

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
         * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
         * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
         *
         * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.
         * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is
         *        undefined, a new instance is created and returned.
         * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the
         *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
         *          created and returned.
         */
        GeographicProjection.prototype.unproject = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
            var longitude = cartesian.x * oneOverEarthSemimajorAxis;
            var latitude = cartesian.y * oneOverEarthSemimajorAxis;
            var height = cartesian.z;

            if (!defined(result)) {
                return new Cartographic(longitude, latitude, height);
            }

            result.longitude = longitude;
            result.latitude = latitude;
            result.height = height;
            return result;
        };

        return GeographicProjection;
    }).call(this, $__require('35'), $__require('44'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('45'));
});
/*global define*/
$__System.registerDynamic('46', ['2c', '23', '25', '30'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, DeveloperError, CesiumMath) {
        'use strict';

        var factorial = CesiumMath.factorial;

        function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
            var result = 0;
            var reserved;
            var i;
            var j;

            if (derivOrder > 0) {
                for (i = 0; i < termOrder; i++) {
                    reserved = false;
                    for (j = 0; j < reservedIndices.length && !reserved; j++) {
                        if (i === reservedIndices[j]) {
                            reserved = true;
                        }
                    }

                    if (!reserved) {
                        reservedIndices.push(i);
                        result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
                        reservedIndices.splice(reservedIndices.length - 1, 1);
                    }
                }

                return result;
            }

            result = 1;
            for (i = 0; i < termOrder; i++) {
                reserved = false;
                for (j = 0; j < reservedIndices.length && !reserved; j++) {
                    if (i === reservedIndices[j]) {
                        reserved = true;
                    }
                }

                if (!reserved) {
                    result *= x - xTable[zIndices[i]];
                }
            }

            return result;
        }

        /**
         * An {@link InterpolationAlgorithm} for performing Hermite interpolation.
         *
         * @exports HermitePolynomialApproximation
         */
        var HermitePolynomialApproximation = {
            type: 'Hermite'
        };

        /**
         * Given the desired degree, returns the number of data points required for interpolation.
         *
         * @param {Number} degree The desired degree of interpolation.
         * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
         * @returns {Number} The number of required data points needed for the desired degree of interpolation.
         * @exception {DeveloperError} degree must be 0 or greater.
         * @exception {DeveloperError} inputOrder must be 0 or greater.
         */
        HermitePolynomialApproximation.getRequiredDataPoints = function (degree, inputOrder) {
            inputOrder = defaultValue(inputOrder, 0);

            //>>includeStart('debug', pragmas.debug);
            if (!defined(degree)) {
                throw new DeveloperError('degree is required.');
            }
            if (degree < 0) {
                throw new DeveloperError('degree must be 0 or greater.');
            }
            if (inputOrder < 0) {
                throw new DeveloperError('inputOrder must be 0 or greater.');
            }
            //>>includeEnd('debug');

            return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);
        };

        /**
         * Interpolates values using Hermite Polynomial Approximation.
         *
         * @param {Number} x The independent variable for which the dependent variables will be interpolated.
         * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
         * in this array must be in increasing order and the same value must not occur twice in the array.
         * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
         * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param {Number} yStride The number of dependent variable values in yTable corresponding to
         * each independent variable value in xTable.
         * @param {Number[]} [result] An existing array into which to store the result.
         * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
         */
        HermitePolynomialApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {
            if (!defined(result)) {
                result = new Array(yStride);
            }

            var i;
            var j;
            var d;
            var s;
            var len;
            var index;
            var length = xTable.length;
            var coefficients = new Array(yStride);

            for (i = 0; i < yStride; i++) {
                result[i] = 0;

                var l = new Array(length);
                coefficients[i] = l;
                for (j = 0; j < length; j++) {
                    l[j] = [];
                }
            }

            var zIndicesLength = length,
                zIndices = new Array(zIndicesLength);

            for (i = 0; i < zIndicesLength; i++) {
                zIndices[i] = i;
            }

            var highestNonZeroCoef = length - 1;
            for (s = 0; s < yStride; s++) {
                for (j = 0; j < zIndicesLength; j++) {
                    index = zIndices[j] * yStride + s;
                    coefficients[s][0].push(yTable[index]);
                }

                for (i = 1; i < zIndicesLength; i++) {
                    var nonZeroCoefficients = false;
                    for (j = 0; j < zIndicesLength - i; j++) {
                        var zj = xTable[zIndices[j]];
                        var zn = xTable[zIndices[j + i]];

                        var numerator;
                        if (zn - zj <= 0) {
                            index = zIndices[j] * yStride + yStride * i + s;
                            numerator = yTable[index];
                            coefficients[s][i].push(numerator / factorial(i));
                        } else {
                            numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];
                            coefficients[s][i].push(numerator / (zn - zj));
                        }
                        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;
                    }

                    if (!nonZeroCoefficients) {
                        highestNonZeroCoef = i - 1;
                    }
                }
            }

            for (d = 0, len = 0; d <= len; d++) {
                for (i = d; i <= highestNonZeroCoef; i++) {
                    var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
                    for (s = 0; s < yStride; s++) {
                        var coeff = coefficients[s][i][0];
                        result[s + d * yStride] += coeff * tempTerm;
                    }
                }
            }

            return result;
        };

        var arrayScratch = [];

        /**
         * Interpolates values using Hermite Polynomial Approximation.
         *
         * @param {Number} x The independent variable for which the dependent variables will be interpolated.
         * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
         * in this array must be in increasing order and the same value must not occur twice in the array.
         * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
         * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param {Number} yStride The number of dependent variable values in yTable corresponding to
         * each independent variable value in xTable.
         * @param {Number} inputOrder The number of derivatives supplied for input.
         * @param {Number} outputOrder The number of derivatives desired for output.
         * @param {Number[]} [result] An existing array into which to store the result.
         *
         * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
         */
        HermitePolynomialApproximation.interpolate = function (x, xTable, yTable, yStride, inputOrder, outputOrder, result) {
            var resultLength = yStride * (outputOrder + 1);
            if (!defined(result)) {
                result = new Array(resultLength);
            }
            for (var r = 0; r < resultLength; r++) {
                result[r] = 0;
            }

            var length = xTable.length;
            // The zIndices array holds copies of the addresses of the xTable values
            // in the range we're looking at. Even though this just holds information already
            // available in xTable this is a much more convenient format.
            var zIndices = new Array(length * (inputOrder + 1));
            for (var i = 0; i < length; i++) {
                for (var j = 0; j < inputOrder + 1; j++) {
                    zIndices[i * (inputOrder + 1) + j] = i;
                }
            }

            var zIndiceslength = zIndices.length;
            var coefficients = arrayScratch;
            var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);
            var reservedIndices = [];

            var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
            var loopStop = Math.min(highestNonZeroCoef, outputOrder);
            for (var d = 0; d <= loopStop; d++) {
                for (i = d; i <= highestNonZeroCoef; i++) {
                    reservedIndices.length = 0;
                    var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);
                    var dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;

                    for (var s = 0; s < yStride; s++) {
                        var dimOne = Math.floor(s * tmp);
                        var coef = coefficients[dimOne + dimTwo];
                        result[s + d * yStride] += coef * tempTerm;
                    }
                }
            }

            return result;
        };

        function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {
            var j;
            var index;
            var highestNonZero = -1;
            var zIndiceslength = zIndices.length;
            var tmp = zIndiceslength * (zIndiceslength + 1) / 2;

            for (var s = 0; s < yStride; s++) {
                var dimOne = Math.floor(s * tmp);

                for (j = 0; j < zIndiceslength; j++) {
                    index = zIndices[j] * yStride * (inputOrder + 1) + s;
                    coefficients[dimOne + j] = yTable[index];
                }

                for (var i = 1; i < zIndiceslength; i++) {
                    var coefIndex = 0;
                    var dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;
                    var nonZeroCoefficients = false;

                    for (j = 0; j < zIndiceslength - i; j++) {
                        var zj = xTable[zIndices[j]];
                        var zn = xTable[zIndices[j + i]];

                        var numerator;
                        var coefficient;
                        if (zn - zj <= 0) {
                            index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;
                            numerator = yTable[index];
                            coefficient = numerator / CesiumMath.factorial(i);
                            coefficients[dimOne + dimTwo + coefIndex] = coefficient;
                            coefIndex++;
                        } else {
                            var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + zIndiceslength * (i - 1);
                            numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];
                            coefficient = numerator / (zn - zj);
                            coefficients[dimOne + dimTwo + coefIndex] = coefficient;
                            coefIndex++;
                        }
                        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;
                    }

                    if (nonZeroCoefficients) {
                        highestNonZero = Math.max(highestNonZero, i);
                    }
                }
            }

            return highestNonZero;
        }

        return HermitePolynomialApproximation;
    }).call(this, $__require('2c'), $__require('23'), $__require('25'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('47', ['23', '24', '25', '3b', '3d', '36', '3e'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError, Matrix3, Quaternion, ReferenceFrame, Transforms) {
        "use strict";

        /**
         * The interface for all {@link Property} objects that define a
         * orientation as a {@link Quaternion}.
         * This type defines an interface and cannot be instantiated directly.
         *
         * @alias OrientationProperty
         * @constructor
         */

        var OrientationProperty = function () {
            DeveloperError.throwInstantiationError();
        };

        defineProperties(OrientationProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.  A property is considered
             * constant if getValue always returns the same result for the current definition.
             * @memberof OrientationProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: DeveloperError.throwInstantiationError
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is considered to have changed if a call to getValue would return
             * a different result for the same time.
             * @memberof OrientationProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: DeveloperError.throwInstantiationError
            }
        });

        /**
         * Gets the value of the property at the provided time relative to the position's reference frame.
         * @function
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Quaternion} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Quaternion} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        OrientationProperty.prototype.getValue = DeveloperError.throwInstantiationError;

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        OrientationProperty.prototype.equals = DeveloperError.throwInstantiationError;

        function framesEqual(frame1, frame2) {
            return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
        }

        function frameParents(frame) {
            var frames = [];
            while (defined(frame)) {
                frames.unshift(frame);
                frame = frame.position && frame.position.referenceFrame;
            }
            return frames;
        }

        function lowestCommonAncestor(parents1, parents2) {
            if (!framesEqual(parents1[0], parents2[0])) {
                return -1;
            }

            var h = Math.min(parents1.length, parents2.length);
            for (var i = 0; i <= h; i++) {
                if (!framesEqual(parents1[i], parents2[i])) {
                    return i - 1;
                }
            }

            return -1;
        }

        var scratchIcrfToFixedMatrix3 = new Matrix3();
        var scratchIcrfToFixed = new Quaternion();

        function getIcrfToFixed(time) {
            var icrfToFixedRotation = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
            if (!defined(icrfToFixedRotation)) {
                icrfToFixedRotation = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
            }
            return Quaternion.fromRotationMatrix(icrfToFixedRotation, scratchIcrfToFixed);
        }

        var scratchQuaternion = new Quaternion();

        /**
         * @private
         */
        OrientationProperty.convertToReferenceFrame = function (time, value, inputFrame, outputFrame, result) {
            if (!defined(value)) {
                return value;
            }
            if (!defined(result)) {
                result = new Quaternion();
            }

            if (inputFrame === outputFrame) {
                return Quaternion.clone(value, result);
            }

            if (!defined(inputFrame) || !defined(outputFrame)) {
                return undefined;
            }

            var inputFrameParents = frameParents(inputFrame);
            var outputFrameParents = frameParents(outputFrame);
            var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
            var lcaFrame = inputFrameParents[lcaIndex];

            var inputOrientationAccumulator = function (accumulatedOrientationValue, frame) {
                if (!defined(accumulatedOrientationValue)) {
                    return accumulatedOrientationValue;
                }

                var frameOrientationProperty = frame.orientation;
                if (!defined(frameOrientationProperty)) {
                    return undefined;
                }

                var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
                if (!defined(frameOrientationValue)) {
                    return undefined;
                }

                return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
            };

            var outputOrientationAccumulator = function (accumulatedOrientationValue, frame) {
                if (!defined(accumulatedOrientationValue)) {
                    return accumulatedOrientationValue;
                }

                var frameOrientationProperty = frame.orientation;
                if (!defined(frameOrientationProperty)) {
                    return undefined;
                }

                var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
                if (!defined(frameOrientationValue)) {
                    return undefined;
                }

                Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
                return Quaternion.multiply(frameOrientationValue, accumulatedOrientationValue, accumulatedOrientationValue);
            };

            if (defined(lcaFrame)) {
                inputFrameParents = inputFrameParents.slice(lcaIndex + 1);
                outputFrameParents = outputFrameParents.slice(lcaIndex + 1);

                var lcaFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
                if (!defined(lcaFrameValue)) {
                    return undefined;
                }

                return outputFrameParents.reduce(outputOrientationAccumulator, lcaFrameValue);
            }

            var inputRootFrame = inputFrameParents.shift();
            var outputRootFrame = outputFrameParents.shift();
            var fixedFrameValue, inertialFrameValue;

            if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
                inertialFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
                if (!defined(inertialFrameValue)) {
                    return undefined;
                }

                fixedFrameValue = Quaternion.multiply(getIcrfToFixed(time), inertialFrameValue, result);
                return outputFrameParents.reduce(outputOrientationAccumulator, fixedFrameValue);
            }

            if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
                fixedFrameValue = inputFrameParents.reduceRight(inputOrientationAccumulator, Quaternion.clone(value, result));
                if (!defined(fixedFrameValue)) {
                    return undefined;
                }

                var fixedToIcrf = Quaternion.conjugate(getIcrfToFixed(time), scratchQuaternion);
                inertialFrameValue = Quaternion.multiply(fixedToIcrf, fixedFrameValue, result);
                return outputFrameParents.reduce(outputOrientationAccumulator, inertialFrameValue);
            }

            return undefined;
        };

        return OrientationProperty;
    }).call(this, $__require('23'), $__require('24'), $__require('25'), $__require('3b'), $__require('3d'), $__require('36'), $__require('3e'));
});
/*global define*/
$__System.registerDynamic('48', ['23', '24', '25', '49'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError, PerspectiveOffCenterFrustum) {
        'use strict';

        /**
         * The viewing frustum is defined by 6 planes.
         * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
         * define the unit vector normal to the plane, and the w component is the distance of the
         * plane from the origin/camera position.
         *
         * @alias PerspectiveFrustum
         * @constructor
         *
         *
         * @example
         * var frustum = new Cesium.PerspectiveFrustum();
         * frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
         * frustum.fov = Cesium.Math.PI_OVER_THREE;
         * frustum.near = 1.0;
         * frustum.far = 2.0;
         * 
         * @see PerspectiveOffCenterFrustum
         */

        function PerspectiveFrustum() {
            this._offCenterFrustum = new PerspectiveOffCenterFrustum();

            /**
             * The angle of the field of view (FOV), in radians.  This angle will be used
             * as the horizontal FOV if the width is greater than the height, otherwise
             * it will be the vertical FOV.
             * @type {Number}
             * @default undefined
             */
            this.fov = undefined;
            this._fov = undefined;
            this._fovy = undefined;

            this._sseDenominator = undefined;

            /**
             * The aspect ratio of the frustum's width to it's height.
             * @type {Number}
             * @default undefined
             */
            this.aspectRatio = undefined;
            this._aspectRatio = undefined;

            /**
             * The distance of the near plane.
             * @type {Number}
             * @default 1.0
             */
            this.near = 1.0;
            this._near = this.near;

            /**
             * The distance of the far plane.
             * @type {Number}
             * @default 500000000.0
             */
            this.far = 500000000.0;
            this._far = this.far;

            /**
             * Offsets the frustum in the x direction.
             * @type {Number}
             * @default 0.0
             */
            this.xOffset = 0.0;
            this._xOffset = this.xOffset;

            /**
             * Offsets the frustum in the y direction.
             * @type {Number}
             * @default 0.0
             */
            this.yOffset = 0.0;
            this._yOffset = this.yOffset;
        }

        function update(frustum) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {
                throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');
            }
            //>>includeEnd('debug');

            var f = frustum._offCenterFrustum;

            if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {
                //>>includeStart('debug', pragmas.debug);
                if (frustum.fov < 0 || frustum.fov >= Math.PI) {
                    throw new DeveloperError('fov must be in the range [0, PI).');
                }

                if (frustum.aspectRatio < 0) {
                    throw new DeveloperError('aspectRatio must be positive.');
                }

                if (frustum.near < 0 || frustum.near > frustum.far) {
                    throw new DeveloperError('near must be greater than zero and less than far.');
                }
                //>>includeEnd('debug');

                frustum._aspectRatio = frustum.aspectRatio;
                frustum._fov = frustum.fov;
                frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
                frustum._near = frustum.near;
                frustum._far = frustum.far;
                frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);
                frustum._xOffset = frustum.xOffset;
                frustum._yOffset = frustum.yOffset;

                f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
                f.bottom = -f.top;
                f.right = frustum.aspectRatio * f.top;
                f.left = -f.right;
                f.near = frustum.near;
                f.far = frustum.far;

                f.right += frustum.xOffset;
                f.left += frustum.xOffset;
                f.top += frustum.yOffset;
                f.bottom += frustum.yOffset;
            }
        }

        defineProperties(PerspectiveFrustum.prototype, {
            /**
             * Gets the perspective projection matrix computed from the view frustum.
             * @memberof PerspectiveFrustum.prototype
             * @type {Matrix4}
             * @readonly
             *
             * @see PerspectiveFrustum#infiniteProjectionMatrix
             */
            projectionMatrix: {
                get: function () {
                    update(this);
                    return this._offCenterFrustum.projectionMatrix;
                }
            },

            /**
             * The perspective projection matrix computed from the view frustum with an infinite far plane.
             * @memberof PerspectiveFrustum.prototype
             * @type {Matrix4}
             * @readonly
             *
             * @see PerspectiveFrustum#projectionMatrix
             */
            infiniteProjectionMatrix: {
                get: function () {
                    update(this);
                    return this._offCenterFrustum.infiniteProjectionMatrix;
                }
            },

            /**
             * Gets the angle of the vertical field of view, in radians.
             * @memberof PerspectiveFrustum.prototype
             * @type {Number}
             * @readonly
             * @default undefined
             */
            fovy: {
                get: function () {
                    update(this);
                    return this._fovy;
                }
            },

            /**
             * @readonly
             * @private
             */
            sseDenominator: {
                get: function () {
                    update(this);
                    return this._sseDenominator;
                }
            }
        });

        /**
         * Creates a culling volume for this frustum.
         *
         * @param {Cartesian3} position The eye position.
         * @param {Cartesian3} direction The view direction.
         * @param {Cartesian3} up The up direction.
         * @returns {CullingVolume} A culling volume at the given position and orientation.
         *
         * @example
         * // Check if a bounding volume intersects the frustum.
         * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
         * var intersect = cullingVolume.computeVisibility(boundingVolume);
         */
        PerspectiveFrustum.prototype.computeCullingVolume = function (position, direction, up) {
            update(this);
            return this._offCenterFrustum.computeCullingVolume(position, direction, up);
        };

        /**
         * Returns the pixel's width and height in meters.
         *
         * @param {Number} drawingBufferWidth The width of the drawing buffer.
         * @param {Number} drawingBufferHeight The height of the drawing buffer.
         * @param {Number} distance The distance to the near plane in meters.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
         *
         * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
         * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
         *
         * @example
         * // Example 1
         * // Get the width and height of a pixel.
         * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Cesium.Cartesian2());
         *
         * @example
         * // Example 2
         * // Get the width and height of a pixel if the near plane was set to 'distance'.
         * // For example, get the size of a pixel of an image on a billboard.
         * var position = camera.position;
         * var direction = camera.direction;
         * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
         * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
         * var distance = Cesium.Cartesian3.magnitude(toCenterProj);
         * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Cesium.Cartesian2());
         */
        PerspectiveFrustum.prototype.getPixelDimensions = function (drawingBufferWidth, drawingBufferHeight, distance, result) {
            update(this);
            return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result);
        };

        /**
         * Returns a duplicate of a PerspectiveFrustum instance.
         *
         * @param {PerspectiveFrustum} [result] The object onto which to store the result.
         * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
         */
        PerspectiveFrustum.prototype.clone = function (result) {
            if (!defined(result)) {
                result = new PerspectiveFrustum();
            }

            result.aspectRatio = this.aspectRatio;
            result.fov = this.fov;
            result.near = this.near;
            result.far = this.far;

            // force update of clone to compute matrices
            result._aspectRatio = undefined;
            result._fov = undefined;
            result._near = undefined;
            result._far = undefined;

            this._offCenterFrustum.clone(result._offCenterFrustum);

            return result;
        };

        /**
         * Compares the provided PerspectiveFrustum componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        PerspectiveFrustum.prototype.equals = function (other) {
            if (!defined(other)) {
                return false;
            }

            update(this);
            update(other);

            return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
        };

        return PerspectiveFrustum;
    }).call(this, $__require('23'), $__require('24'), $__require('25'), $__require('49'));
});
/*global define*/
$__System.registerDynamic('4a', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * This enumerated type is used in determining where, relative to the frustum, an
     * object is located. The object can either be fully contained within the frustum (INSIDE),
     * partially inside the frustum and partially outside (INTERSECTING), or somwhere entirely
     * outside of the frustum's 6 planes (OUTSIDE).
     *
     * @exports Intersect
     */

    var Intersect = {
      /**
       * Represents that an object is not contained within the frustum.
       *
       * @type {Number}
       * @constant
       */
      OUTSIDE: -1,

      /**
       * Represents that an object intersects one of the frustum's planes.
       *
       * @type {Number}
       * @constant
       */
      INTERSECTING: 0,

      /**
       * Represents that an object is fully within the frustum.
       *
       * @type {Number}
       * @constant
       */
      INSIDE: 1
    };

    return freezeObject(Intersect);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('4b', ['35', '4c', '2c', '23', '25', '4a', '4d'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartesian4, defaultValue, defined, DeveloperError, Intersect, Plane) {
        'use strict';

        /**
         * The culling volume defined by planes.
         *
         * @alias CullingVolume
         * @constructor
         *
         * @param {Cartesian4[]} [planes] An array of clipping planes.
         */

        function CullingVolume(planes) {
            /**
             * Each plane is represented by a Cartesian4 object, where the x, y, and z components
             * define the unit vector normal to the plane, and the w component is the distance of the
             * plane from the origin.
             * @type {Cartesian4[]}
             * @default []
             */
            this.planes = defaultValue(planes, []);
        }

        var faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];
        Cartesian3.clone(Cartesian3.UNIT_X, faces[0]);
        Cartesian3.clone(Cartesian3.UNIT_Y, faces[1]);
        Cartesian3.clone(Cartesian3.UNIT_Z, faces[2]);

        var scratchPlaneCenter = new Cartesian3();
        var scratchPlaneNormal = new Cartesian3();
        var scratchPlane = new Plane(new Cartesian3(), 0.0);

        /**
         * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
         * The planes are aligned to the x, y, and z axes in world coordinates.
         *
         * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.
         * @param {CullingVolume} [result] The object onto which to store the result.
         * @returns {CullingVolume} The culling volume created from the bounding sphere.
         */
        CullingVolume.fromBoundingSphere = function (boundingSphere, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(boundingSphere)) {
                throw new DeveloperError('boundingSphere is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new CullingVolume();
            }

            var length = faces.length;
            var planes = result.planes;
            planes.length = 2 * length;

            var center = boundingSphere.center;
            var radius = boundingSphere.radius;

            var planeIndex = 0;

            for (var i = 0; i < length; ++i) {
                var faceNormal = faces[i];

                var plane0 = planes[planeIndex];
                var plane1 = planes[planeIndex + 1];

                if (!defined(plane0)) {
                    plane0 = planes[planeIndex] = new Cartesian4();
                }
                if (!defined(plane1)) {
                    plane1 = planes[planeIndex + 1] = new Cartesian4();
                }

                Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);
                Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);

                plane0.x = faceNormal.x;
                plane0.y = faceNormal.y;
                plane0.z = faceNormal.z;
                plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);

                Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);
                Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);

                plane1.x = -faceNormal.x;
                plane1.y = -faceNormal.y;
                plane1.z = -faceNormal.z;
                plane1.w = -Cartesian3.dot(Cartesian3.negate(faceNormal, scratchPlaneNormal), scratchPlaneCenter);

                planeIndex += 2;
            }

            return result;
        };

        /**
         * Determines whether a bounding volume intersects the culling volume.
         *
         * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.
         * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.
         */
        CullingVolume.prototype.computeVisibility = function (boundingVolume) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(boundingVolume)) {
                throw new DeveloperError('boundingVolume is required.');
            }
            //>>includeEnd('debug');

            var planes = this.planes;
            var intersecting = false;
            for (var k = 0, len = planes.length; k < len; ++k) {
                var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));
                if (result === Intersect.OUTSIDE) {
                    return Intersect.OUTSIDE;
                } else if (result === Intersect.INTERSECTING) {
                    intersecting = true;
                }
            }

            return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
        };

        /**
         * Determines whether a bounding volume intersects the culling volume.
         *
         * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.
         * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
         *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
         *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]
         *                                 and that plane check can be skipped.
         * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).
         *
         * @private
         */
        CullingVolume.prototype.computeVisibilityWithPlaneMask = function (boundingVolume, parentPlaneMask) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(boundingVolume)) {
                throw new DeveloperError('boundingVolume is required.');
            }
            if (!defined(parentPlaneMask)) {
                throw new DeveloperError('parentPlaneMask is required.');
            }
            //>>includeEnd('debug');

            if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
                // parent is completely outside or completely inside, so this child is as well.
                return parentPlaneMask;
            }

            // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
            // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
            var mask = CullingVolume.MASK_INSIDE;

            var planes = this.planes;
            for (var k = 0, len = planes.length; k < len; ++k) {
                // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
                var flag = k < 31 ? 1 << k : 0;
                if (k < 31 && (parentPlaneMask & flag) === 0) {
                    // boundingVolume is known to be INSIDE this plane.
                    continue;
                }

                var result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));
                if (result === Intersect.OUTSIDE) {
                    return CullingVolume.MASK_OUTSIDE;
                } else if (result === Intersect.INTERSECTING) {
                    mask |= flag;
                }
            }

            return mask;
        };

        /**
         * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value
         * represents the case where the object bounding volume is entirely outside the culling volume.
         *
         * @type {Number}
         * @private
         */
        CullingVolume.MASK_OUTSIDE = 0xffffffff;

        /**
         * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value
         * represents the case where the object bounding volume is entirely inside the culling volume.
         *
         * @type {Number}
         * @private
         */
        CullingVolume.MASK_INSIDE = 0x00000000;

        /**
         * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value
         * represents the case where the object bounding volume (may) intersect all planes of the culling volume.
         *
         * @type {Number}
         * @private
         */
        CullingVolume.MASK_INDETERMINATE = 0x7fffffff;

        return CullingVolume;
    }).call(this, $__require('35'), $__require('4c'), $__require('2c'), $__require('23'), $__require('25'), $__require('4a'), $__require('4d'));
});
/*global define*/
$__System.registerDynamic('49', ['4e', '35', '4c', '2c', '23', '24', '25', '3c', '4b'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian2, Cartesian3, Cartesian4, defaultValue, defined, defineProperties, DeveloperError, Matrix4, CullingVolume) {
        'use strict';

        /**
         * The viewing frustum is defined by 6 planes.
         * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
         * define the unit vector normal to the plane, and the w component is the distance of the
         * plane from the origin/camera position.
         *
         * @alias PerspectiveOffCenterFrustum
         * @constructor
         *
         *
         * @example
         * var frustum = new Cesium.PerspectiveOffCenterFrustum();
         * frustum.right = 1.0;
         * frustum.left = -1.0;
         * frustum.top = 1.0;
         * frustum.bottom = -1.0;
         * frustum.near = 1.0;
         * frustum.far = 2.0;
         *
         * @see PerspectiveFrustum
         */

        function PerspectiveOffCenterFrustum() {
            /**
             * Defines the left clipping plane.
             * @type {Number}
             * @default undefined
             */
            this.left = undefined;
            this._left = undefined;

            /**
             * Defines the right clipping plane.
             * @type {Number}
             * @default undefined
             */
            this.right = undefined;
            this._right = undefined;

            /**
             * Defines the top clipping plane.
             * @type {Number}
             * @default undefined
             */
            this.top = undefined;
            this._top = undefined;

            /**
             * Defines the bottom clipping plane.
             * @type {Number}
             * @default undefined
             */
            this.bottom = undefined;
            this._bottom = undefined;

            /**
             * The distance of the near plane.
             * @type {Number}
             * @default 1.0
             */
            this.near = 1.0;
            this._near = this.near;

            /**
             * The distance of the far plane.
             * @type {Number}
             * @default 500000000.0
             */
            this.far = 500000000.0;
            this._far = this.far;

            this._cullingVolume = new CullingVolume();
            this._perspectiveMatrix = new Matrix4();
            this._infinitePerspective = new Matrix4();
        }

        function update(frustum) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
                throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
            }
            //>>includeEnd('debug');

            var t = frustum.top;
            var b = frustum.bottom;
            var r = frustum.right;
            var l = frustum.left;
            var n = frustum.near;
            var f = frustum.far;

            if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {

                //>>includeStart('debug', pragmas.debug);
                if (frustum.near <= 0 || frustum.near > frustum.far) {
                    throw new DeveloperError('near must be greater than zero and less than far.');
                }
                //>>includeEnd('debug');

                frustum._left = l;
                frustum._right = r;
                frustum._top = t;
                frustum._bottom = b;
                frustum._near = n;
                frustum._far = f;
                frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
                frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
            }
        }

        defineProperties(PerspectiveOffCenterFrustum.prototype, {
            /**
             * Gets the perspective projection matrix computed from the view frustum.
             * @memberof PerspectiveOffCenterFrustum.prototype
             * @type {Matrix4}
             * @readonly
             *
             * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix
             */
            projectionMatrix: {
                get: function () {
                    update(this);
                    return this._perspectiveMatrix;
                }
            },

            /**
             * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
             * @memberof PerspectiveOffCenterFrustum.prototype
             * @type {Matrix4}
             * @readonly
             *
             * @see PerspectiveOffCenterFrustum#projectionMatrix
             */
            infiniteProjectionMatrix: {
                get: function () {
                    update(this);
                    return this._infinitePerspective;
                }
            }
        });

        var getPlanesRight = new Cartesian3();
        var getPlanesNearCenter = new Cartesian3();
        var getPlanesFarCenter = new Cartesian3();
        var getPlanesNormal = new Cartesian3();
        /**
         * Creates a culling volume for this frustum.
         *
         * @param {Cartesian3} position The eye position.
         * @param {Cartesian3} direction The view direction.
         * @param {Cartesian3} up The up direction.
         * @returns {CullingVolume} A culling volume at the given position and orientation.
         *
         * @example
         * // Check if a bounding volume intersects the frustum.
         * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
         * var intersect = cullingVolume.computeVisibility(boundingVolume);
         */
        PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (position, direction, up) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(position)) {
                throw new DeveloperError('position is required.');
            }

            if (!defined(direction)) {
                throw new DeveloperError('direction is required.');
            }

            if (!defined(up)) {
                throw new DeveloperError('up is required.');
            }
            //>>includeEnd('debug');

            var planes = this._cullingVolume.planes;

            var t = this.top;
            var b = this.bottom;
            var r = this.right;
            var l = this.left;
            var n = this.near;
            var f = this.far;

            var right = Cartesian3.cross(direction, up, getPlanesRight);

            var nearCenter = getPlanesNearCenter;
            Cartesian3.multiplyByScalar(direction, n, nearCenter);
            Cartesian3.add(position, nearCenter, nearCenter);

            var farCenter = getPlanesFarCenter;
            Cartesian3.multiplyByScalar(direction, f, farCenter);
            Cartesian3.add(position, farCenter, farCenter);

            var normal = getPlanesNormal;

            //Left plane computation
            Cartesian3.multiplyByScalar(right, l, normal);
            Cartesian3.add(nearCenter, normal, normal);
            Cartesian3.subtract(normal, position, normal);
            Cartesian3.normalize(normal, normal);
            Cartesian3.cross(normal, up, normal);

            var plane = planes[0];
            if (!defined(plane)) {
                plane = planes[0] = new Cartesian4();
            }
            plane.x = normal.x;
            plane.y = normal.y;
            plane.z = normal.z;
            plane.w = -Cartesian3.dot(normal, position);

            //Right plane computation
            Cartesian3.multiplyByScalar(right, r, normal);
            Cartesian3.add(nearCenter, normal, normal);
            Cartesian3.subtract(normal, position, normal);
            Cartesian3.normalize(normal, normal);
            Cartesian3.cross(up, normal, normal);

            plane = planes[1];
            if (!defined(plane)) {
                plane = planes[1] = new Cartesian4();
            }
            plane.x = normal.x;
            plane.y = normal.y;
            plane.z = normal.z;
            plane.w = -Cartesian3.dot(normal, position);

            //Bottom plane computation
            Cartesian3.multiplyByScalar(up, b, normal);
            Cartesian3.add(nearCenter, normal, normal);
            Cartesian3.subtract(normal, position, normal);
            Cartesian3.normalize(normal, normal);
            Cartesian3.cross(right, normal, normal);

            plane = planes[2];
            if (!defined(plane)) {
                plane = planes[2] = new Cartesian4();
            }
            plane.x = normal.x;
            plane.y = normal.y;
            plane.z = normal.z;
            plane.w = -Cartesian3.dot(normal, position);

            //Top plane computation
            Cartesian3.multiplyByScalar(up, t, normal);
            Cartesian3.add(nearCenter, normal, normal);
            Cartesian3.subtract(normal, position, normal);
            Cartesian3.normalize(normal, normal);
            Cartesian3.cross(normal, right, normal);

            plane = planes[3];
            if (!defined(plane)) {
                plane = planes[3] = new Cartesian4();
            }
            plane.x = normal.x;
            plane.y = normal.y;
            plane.z = normal.z;
            plane.w = -Cartesian3.dot(normal, position);

            //Near plane computation
            plane = planes[4];
            if (!defined(plane)) {
                plane = planes[4] = new Cartesian4();
            }
            plane.x = direction.x;
            plane.y = direction.y;
            plane.z = direction.z;
            plane.w = -Cartesian3.dot(direction, nearCenter);

            //Far plane computation
            Cartesian3.negate(direction, normal);

            plane = planes[5];
            if (!defined(plane)) {
                plane = planes[5] = new Cartesian4();
            }
            plane.x = normal.x;
            plane.y = normal.y;
            plane.z = normal.z;
            plane.w = -Cartesian3.dot(normal, farCenter);

            return this._cullingVolume;
        };

        /**
         * Returns the pixel's width and height in meters.
         *
         * @param {Number} drawingBufferWidth The width of the drawing buffer.
         * @param {Number} drawingBufferHeight The height of the drawing buffer.
         * @param {Number} distance The distance to the near plane in meters.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
         *
         * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
         * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
         *
         * @example
         * // Example 1
         * // Get the width and height of a pixel.
         * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Cesium.Cartesian2());
         *
         * @example
         * // Example 2
         * // Get the width and height of a pixel if the near plane was set to 'distance'.
         * // For example, get the size of a pixel of an image on a billboard.
         * var position = camera.position;
         * var direction = camera.direction;
         * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
         * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
         * var distance = Cesium.Cartesian3.magnitude(toCenterProj);
         * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Cesium.Cartesian2());
         */
        PerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (drawingBufferWidth, drawingBufferHeight, distance, result) {
            update(this);

            //>>includeStart('debug', pragmas.debug);
            if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {
                throw new DeveloperError('Both drawingBufferWidth and drawingBufferHeight are required.');
            }
            if (drawingBufferWidth <= 0) {
                throw new DeveloperError('drawingBufferWidth must be greater than zero.');
            }
            if (drawingBufferHeight <= 0) {
                throw new DeveloperError('drawingBufferHeight must be greater than zero.');
            }
            if (!defined(distance)) {
                throw new DeveloperError('distance is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('A result object is required.');
            }
            //>>includeEnd('debug');

            var inverseNear = 1.0 / this.near;
            var tanTheta = this.top * inverseNear;
            var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;
            tanTheta = this.right * inverseNear;
            var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;

            result.x = pixelWidth;
            result.y = pixelHeight;
            return result;
        };

        /**
         * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
         *
         * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.
         * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
         */
        PerspectiveOffCenterFrustum.prototype.clone = function (result) {
            if (!defined(result)) {
                result = new PerspectiveOffCenterFrustum();
            }

            result.right = this.right;
            result.left = this.left;
            result.top = this.top;
            result.bottom = this.bottom;
            result.near = this.near;
            result.far = this.far;

            // force update of clone to compute matrices
            result._left = undefined;
            result._right = undefined;
            result._top = undefined;
            result._bottom = undefined;
            result._near = undefined;
            result._far = undefined;

            return result;
        };

        /**
         * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        PerspectiveOffCenterFrustum.prototype.equals = function (other) {
            return defined(other) && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
        };

        return PerspectiveOffCenterFrustum;
    }).call(this, $__require('4e'), $__require('35'), $__require('4c'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('3c'), $__require('4b'));
});
/*global define*/
$__System.registerDynamic('4f', ['23', '24', '25', '26', '3f'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError, Event, Property) {
        "use strict";

        function resolve(that) {
            var targetEntity = that._targetEntity;

            if (that._resolveEntity) {
                targetEntity = that._targetCollection.getById(that._targetId);

                if (defined(targetEntity)) {
                    that._targetEntity = targetEntity;
                    that._resolveEntity = false;
                }
            }
            return targetEntity;
        }

        /**
         * References an {@link Entity} in an {@link EntityCollection}.
         *
         * @alias ReferenceEntity
         * @constructor
         *
         * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.
         * @param {String} targetId The id of the entity which is being referenced.
         *
         */
        var ReferenceEntity = function (targetCollection, targetId) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(targetCollection)) {
                throw new DeveloperError('targetCollection is required.');
            }
            if (!defined(targetId) || targetId === '') {
                throw new DeveloperError('targetId is required.');
            }
            //>>includeEnd('debug');

            this._targetCollection = targetCollection;
            this._targetId = targetId;
            this._targetEntity = undefined;
            this._definitionChanged = new Event();
            this._resolveEntity = true;

            targetCollection.collectionChanged.addEventListener(ReferenceEntity.prototype._onCollectionChanged, this);
        };

        defineProperties(ReferenceEntity.prototype, {
            /**
             * Gets the event that is raised whenever the definition of this entity changes.
             * The definition is changed whenever the referenced property's definition is changed.
             * @memberof ReferenceEntity.prototype
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            },
            /**
             * Gets the id of the entity being referenced.
             * @memberof ReferenceEntity.prototype
             * @type {String}
             * @readonly
             */
            id: {
                get: function () {
                    return this._targetId;
                }
            },
            /**
             * Gets the position property of the entity being referenced.
             * @memberof ReferenceProperty.prototype
             * @type {PositionProperty}
             * @readonly
             */
            position: {
                get: function () {
                    var entity = resolve(this);
                    return defined(entity) ? entity.position : undefined;
                }
            },
            /**
             * Gets the orientation property of the entity being referenced.
             * @memberof ReferenceProperty.prototype
             * @type {Property}
             * @readonly
             */
            orientation: {
                get: function () {
                    var entity = resolve(this);
                    return defined(entity) ? entity.orientation : undefined;
                }
            },
            /**
             * Gets the id of the entity being referenced.
             * @memberof ReferenceEntity.prototype
             * @type {String}
             * @readonly
             */
            targetId: {
                get: function () {
                    return this._targetId;
                }
            },
            /**
             * Gets the collection containing the entity being referenced.
             * @memberof ReferenceEntity.prototype
             * @type {EntityCollection}
             * @readonly
             */
            targetCollection: {
                get: function () {
                    return this._targetCollection;
                }
            },
            /**
             * Gets the resolved instance of the underlying referenced entity.
             * @memberof ReferenceEntity.prototype
             * @type {Entity}
             * @readonly
             */
            resolvedEntity: {
                get: function () {
                    return resolve(this);
                }
            }
        });

        ReferenceEntity.prototype._onCollectionChanged = function (collection, added, removed) {
            var targetEntity = this._targetEntity;
            if (defined(targetEntity)) {
                if (removed.indexOf(targetEntity) !== -1) {
                    this._resolveEntity = true;
                } else if (this._resolveEntity) {
                    //If targetEntity is defined but resolveEntity is true, then the entity is detached
                    //and any change to the collection needs to incur an attempt to resolve in order to re-attach.
                    //without this if block, a reference that becomes re-attached will not signal definitionChanged
                    resolve(this);
                    if (!this._resolveEntity) {
                        this._definitionChanged.raiseEvent(this);
                    }
                }
            }
        };

        return ReferenceEntity;
    }).call(this, $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('3f'));
});
/*global define*/
$__System.registerDynamic('50', ['23', '24', '25', '26', '41', '3f'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError, Event, RuntimeError, Property) {
        'use strict';

        function resolveEntity(that) {
            var entityIsResolved = true;
            if (that._resolveEntity) {
                var targetEntity = that._targetCollection.getById(that._targetId);

                if (defined(targetEntity)) {
                    targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);
                    that._targetEntity = targetEntity;
                    that._resolveEntity = false;
                } else {
                    //The property has become detached.  It has a valid value but is not currently resolved to an entity in the collection
                    targetEntity = that._targetEntity;
                    entityIsResolved = false;
                }

                if (!defined(targetEntity)) {
                    throw new RuntimeError('target entity "' + that._targetId + '" could not be resolved.');
                }
            }
            return entityIsResolved;
        }

        function resolve(that) {
            var targetProperty = that._targetProperty;

            if (that._resolveProperty) {
                var entityIsResolved = resolveEntity(that);

                var names = that._targetPropertyNames;
                targetProperty = that._targetEntity;
                var length = names.length;
                for (var i = 0; i < length && defined(targetProperty); i++) {
                    targetProperty = targetProperty[names[i]];
                }

                if (defined(targetProperty)) {
                    that._targetProperty = targetProperty;
                    that._resolveProperty = !entityIsResolved;
                } else if (!defined(that._targetProperty)) {
                    throw new RuntimeError('targetProperty "' + that._targetId + '.' + names.join('.') + '" could not be resolved.');
                }
            }

            return targetProperty;
        }

        /**
         * A {@link Property} which transparently links to another property on a provided object.
         *
         * @alias ReferenceProperty
         * @constructor
         *
         * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.
         * @param {String} targetId The id of the entity which is being referenced.
         * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.
         *
         * @example
         * var collection = new Cesium.EntityCollection();
         *
         * //Create a new entity and assign a billboard scale.
         * var object1 = new Cesium.Entity({id:'object1'});
         * object1.billboard = new Cesium.BillboardGraphics();
         * object1.billboard.scale = new Cesium.ConstantProperty(2.0);
         * collection.add(object1);
         *
         * //Create a second entity and reference the scale from the first one.
         * var object2 = new Cesium.Entity({id:'object2'});
         * object2.model = new Cesium.ModelGraphics();
         * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);
         * collection.add(object2);
         *
         * //Create a third object, but use the fromString helper function.
         * var object3 = new Cesium.Entity({id:'object3'});
         * object3.billboard = new Cesium.BillboardGraphics();
         * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');
         * collection.add(object3);
         *
         * //You can refer to an entity with a # or . in id and property names by escaping them.
         * var object4 = new Cesium.Entity({id:'#object.4'});
         * object4.billboard = new Cesium.BillboardGraphics();
         * object4.billboard.scale = new Cesium.ConstantProperty(2.0);
         * collection.add(object4);
         *
         * var object5 = new Cesium.Entity({id:'object5'});
         * object5.billboard = new Cesium.BillboardGraphics();
         * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\#object\\.4#billboard.scale');
         * collection.add(object5);
         */
        function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(targetCollection)) {
                throw new DeveloperError('targetCollection is required.');
            }
            if (!defined(targetId) || targetId === '') {
                throw new DeveloperError('targetId is required.');
            }
            if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {
                throw new DeveloperError('targetPropertyNames is required.');
            }
            for (var i = 0; i < targetPropertyNames.length; i++) {
                var item = targetPropertyNames[i];
                if (!defined(item) || item === '') {
                    throw new DeveloperError('reference contains invalid properties.');
                }
            }
            //>>includeEnd('debug');

            this._targetCollection = targetCollection;
            this._targetId = targetId;
            this._targetPropertyNames = targetPropertyNames;
            this._targetProperty = undefined;
            this._targetEntity = undefined;
            this._definitionChanged = new Event();
            this._resolveEntity = true;
            this._resolveProperty = true;

            targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);
        }

        defineProperties(ReferenceProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.
             * @memberof ReferenceProperty.prototype
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: function () {
                    return Property.isConstant(resolve(this));
                }
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is changed whenever the referenced property's definition is changed.
             * @memberof ReferenceProperty.prototype
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            },
            /**
             * Gets the reference frame that the position is defined in.
             * This property is only valid if the referenced property is a {@link PositionProperty}.
             * @memberof ReferenceProperty.prototype
             * @type {ReferenceFrame}
             * @readonly
             */
            referenceFrame: {
                get: function () {
                    return resolve(this).referenceFrame;
                }
            },
            /**
             * Gets the id of the entity being referenced.
             * @memberof ReferenceProperty.prototype
             * @type {String}
             * @readonly
             */
            targetId: {
                get: function () {
                    return this._targetId;
                }
            },
            /**
             * Gets the collection containing the entity being referenced.
             * @memberof ReferenceProperty.prototype
             * @type {EntityCollection}
             * @readonly
             */
            targetCollection: {
                get: function () {
                    return this._targetCollection;
                }
            },
            /**
             * Gets the array of property names used to retrieve the referenced property.
             * @memberof ReferenceProperty.prototype
             * @type {String[]}
             * @readonly
             */
            targetPropertyNames: {
                get: function () {
                    return this._targetPropertyNames;
                }
            },
            /**
             * Gets the resolved instance of the underlying referenced property.
             * @memberof ReferenceProperty.prototype
             * @type {Property}
             * @readonly
             */
            resolvedProperty: {
                get: function () {
                    return resolve(this);
                }
            }
        });

        /**
         * Creates a new instance given the entity collection that will
         * be used to resolve it and a string indicating the target entity id and property.
         * The format of the string is "objectId#foo.bar", where # separates the id from
         * property path and . separates sub-properties.  If the reference identifier or
         * or any sub-properties contains a # . or \ they must be escaped.
         *
         * @param {EntityCollection} targetCollection
         * @param {String} referenceString
         * @returns {ReferenceProperty} A new instance of ReferenceProperty.
         *
         * @exception {DeveloperError} invalid referenceString.
         */
        ReferenceProperty.fromString = function (targetCollection, referenceString) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(targetCollection)) {
                throw new DeveloperError('targetCollection is required.');
            }
            if (!defined(referenceString)) {
                throw new DeveloperError('referenceString is required.');
            }
            //>>includeEnd('debug');

            var identifier;
            var values = [];

            var inIdentifier = true;
            var isEscaped = false;
            var token = '';
            for (var i = 0; i < referenceString.length; ++i) {
                var c = referenceString.charAt(i);

                if (isEscaped) {
                    token += c;
                    isEscaped = false;
                } else if (c === '\\') {
                    isEscaped = true;
                } else if (inIdentifier && c === '#') {
                    identifier = token;
                    inIdentifier = false;
                    token = '';
                } else if (!inIdentifier && c === '.') {
                    values.push(token);
                    token = '';
                } else {
                    token += c;
                }
            }
            values.push(token);

            return new ReferenceProperty(targetCollection, identifier, values);
        };

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        ReferenceProperty.prototype.getValue = function (time, result) {
            return resolve(this).getValue(time, result);
        };

        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * This method is only valid if the property being referenced is a {@link PositionProperty}.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
         * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        ReferenceProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
            return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);
        };

        /**
         * Gets the {@link Material} type at the provided time.
         * This method is only valid if the property being referenced is a {@link MaterialProperty}.
         *
         * @param {JulianDate} time The time for which to retrieve the type.
         * @returns {String} The type of material.
         */
        ReferenceProperty.prototype.getType = function (time) {
            return resolve(this).getType(time);
        };

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        ReferenceProperty.prototype.equals = function (other) {
            if (this === other) {
                return true;
            }

            var names = this._targetPropertyNames;
            var otherNames = other._targetPropertyNames;

            if (this._targetCollection !== other._targetCollection || //
            this._targetId !== other._targetId || //
            names.length !== otherNames.length) {
                return false;
            }

            var length = this._targetPropertyNames.length;
            for (var i = 0; i < length; i++) {
                if (names[i] !== otherNames[i]) {
                    return false;
                }
            }

            return true;
        };

        ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function (targetEntity, name, value, oldValue) {
            if (this._targetPropertyNames[0] === name) {
                this._resolveProperty = true;
                this._definitionChanged.raiseEvent(this);
            }
        };

        ReferenceProperty.prototype._onCollectionChanged = function (collection, added, removed) {
            var targetEntity = this._targetEntity;
            if (defined(targetEntity)) {
                if (removed.indexOf(targetEntity) !== -1) {
                    targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);
                    this._resolveEntity = true;
                    this._resolveProperty = true;
                } else if (this._resolveEntity) {
                    //If targetEntity is defined but resolveEntity is true, then the entity is detached
                    //and any change to the collection needs to incur an attempt to resolve in order to re-attach.
                    //without this if block, a reference that becomes re-attached will not signal definitionChanged
                    resolve(this);
                    if (!this._resolveEntity) {
                        this._definitionChanged.raiseEvent(this);
                    }
                }
            }
        };

        return ReferenceProperty;
    }).call(this, $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('41'), $__require('3f'));
});
/*global define*/
$__System.registerDynamic('36', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * Constants for identifying well-known reference frames.
     *
     * @exports ReferenceFrame
     */

    var ReferenceFrame = {
      /**
       * The fixed frame.
       *
       * @type {Number}
       * @constant
       */
      FIXED: 0,

      /**
       * The inertial frame.
       *
       * @type {Number}
       * @constant
       */
      INERTIAL: 1
    };

    return freezeObject(ReferenceFrame);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('37', ['35', '23', '24', '25', '3b', '3c', '3d', '36', '3e'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defined, defineProperties, DeveloperError, Matrix3, Matrix4, Quaternion, ReferenceFrame, Transforms) {
        'use strict';

        /**
         * The interface for all {@link Property} objects that define a world
         * location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
         * This type defines an interface and cannot be instantiated directly.
         *
         * @alias PositionProperty
         * @constructor
         *
         * @see CompositePositionProperty
         * @see ConstantPositionProperty
         * @see SampledPositionProperty
         * @see TimeIntervalCollectionPositionProperty
         */

        function PositionProperty() {
            DeveloperError.throwInstantiationError();
        }

        defineProperties(PositionProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.  A property is considered
             * constant if getValue always returns the same result for the current definition.
             * @memberof PositionProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: DeveloperError.throwInstantiationError
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is considered to have changed if a call to getValue would return
             * a different result for the same time.
             * @memberof PositionProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: DeveloperError.throwInstantiationError
            },
            /**
             * Gets the reference frame that the position is defined in.
             * @memberof PositionProperty.prototype
             * @type {ReferenceFrame}
             */
            referenceFrame: {
                get: DeveloperError.throwInstantiationError
            }
        });

        /**
         * Gets the value of the property at the provided time in the fixed frame.
         * @function
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        PositionProperty.prototype.getValue = DeveloperError.throwInstantiationError;

        /**
         * Gets the value of the property at the provided time and in the provided reference frame.
         * @function
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
         * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        PositionProperty.prototype.getValueInReferenceFrame = DeveloperError.throwInstantiationError;

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         * @function
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        PositionProperty.prototype.equals = DeveloperError.throwInstantiationError;

        function framesEqual(frame1, frame2) {
            return frame1 && frame1.id ? frame1.id === (frame2 && frame2.id) : frame1 === frame2;
        }

        function frameParents(frame) {
            var frames = [];
            while (defined(frame)) {
                frames.unshift(frame);
                frame = frame.position && frame.position.referenceFrame;
            }
            return frames;
        }

        function lowestCommonAncestor(parents1, parents2) {
            if (!framesEqual(parents1[0], parents2[0])) {
                return -1;
            }

            var h = Math.min(parents1.length, parents2.length);
            for (var i = 0; i <= h; i++) {
                if (!framesEqual(parents1[i], parents2[i])) {
                    return i - 1;
                }
            }

            return -1;
        }

        var scratchIcrfToFixedMatrix3 = new Matrix3();

        function getIcrfToFixed(time) {
            var icrfToFixed = Transforms.computeIcrfToFixedMatrix(time, scratchIcrfToFixedMatrix3);
            if (!defined(icrfToFixed)) {
                icrfToFixed = Transforms.computeTemeToPseudoFixedMatrix(time, scratchIcrfToFixedMatrix3);
            }
            return icrfToFixed;
        }

        var scratchMatrix3 = new Matrix3();
        var scratchCartesian3 = new Cartesian3();
        var scratchQuaternion = new Quaternion();

        /**
         * @private
         */
        PositionProperty.convertToReferenceFrame = function (time, value, inputFrame, outputFrame, result) {
            if (!defined(value)) {
                return value;
            }
            if (!defined(result)) {
                result = new Cartesian3();
            }

            if (inputFrame === outputFrame) {
                return Cartesian3.clone(value, result);
            }

            if (!defined(inputFrame) || !defined(outputFrame)) {
                return undefined;
            }

            var inputFrameParents = frameParents(inputFrame);
            var outputFrameParents = frameParents(outputFrame);
            var lcaIndex = lowestCommonAncestor(inputFrameParents, outputFrameParents);
            var lcaFrame = inputFrameParents[lcaIndex];

            var inputPositionAccumulator = function (accumulatedPositionValue, frame) {
                if (!defined(accumulatedPositionValue)) {
                    return accumulatedPositionValue;
                }

                var framePositionProperty = frame.position;
                if (!defined(framePositionProperty)) {
                    return undefined;
                }

                var frameReferenceFrame = framePositionProperty.referenceFrame;
                var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
                if (!defined(framePositionValue)) {
                    return undefined;
                }

                var frameOrientationProperty = frame.orientation;
                if (defined(frameOrientationProperty)) {
                    var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
                    if (!defined(frameOrientationValue)) {
                        return undefined;
                    }

                    Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
                    Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
                    return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
                }

                return Cartesian3.add(framePositionValue, accumulatedPositionValue, accumulatedPositionValue);
            };

            var outputPositionAccumulator = function (accumulatedPositionValue, frame) {
                if (!defined(accumulatedPositionValue)) {
                    return accumulatedPositionValue;
                }

                var framePositionProperty = frame.position;
                if (!defined(framePositionProperty)) {
                    return undefined;
                }

                var frameReferenceFrame = framePositionProperty.referenceFrame;
                var framePositionValue = framePositionProperty.getValueInReferenceFrame(time, frameReferenceFrame, scratchCartesian3);
                if (!defined(framePositionValue)) {
                    return undefined;
                }

                accumulatedPositionValue = Cartesian3.subtract(accumulatedPositionValue, framePositionValue, accumulatedPositionValue);

                var frameOrientationProperty = frame.orientation;
                if (defined(frameOrientationProperty)) {
                    var frameOrientationValue = frameOrientationProperty.getValue(time, scratchQuaternion);
                    if (!defined(frameOrientationValue)) {
                        return undefined;
                    }

                    Quaternion.conjugate(frameOrientationValue, frameOrientationValue);
                    Matrix3.fromQuaternion(frameOrientationValue, scratchMatrix3);
                    Matrix3.multiplyByVector(scratchMatrix3, accumulatedPositionValue, accumulatedPositionValue);
                }

                return accumulatedPositionValue;
            };

            if (defined(lcaFrame)) {
                inputFrameParents = inputFrameParents.slice(lcaIndex + 1);
                outputFrameParents = outputFrameParents.slice(lcaIndex + 1);

                var lcaFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
                if (!defined(lcaFrameValue)) {
                    return undefined;
                }

                return outputFrameParents.reduce(outputPositionAccumulator, lcaFrameValue);
            }

            var inputRootFrame = inputFrameParents.shift();
            var outputRootFrame = outputFrameParents.shift();
            var fixedFrameValue, inertialFrameValue;

            if (inputRootFrame === ReferenceFrame.INERTIAL && outputRootFrame === ReferenceFrame.FIXED) {
                inertialFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
                if (!defined(inertialFrameValue)) {
                    return undefined;
                }

                fixedFrameValue = Matrix3.multiplyByVector(getIcrfToFixed(time), inertialFrameValue, result);
                return outputFrameParents.reduce(outputPositionAccumulator, fixedFrameValue);
            }

            if (inputRootFrame === ReferenceFrame.FIXED && outputRootFrame === ReferenceFrame.INERTIAL) {
                fixedFrameValue = inputFrameParents.reduceRight(inputPositionAccumulator, Cartesian3.clone(value, result));
                if (!defined(fixedFrameValue)) {
                    return undefined;
                }

                var fixedToIcrf = Matrix3.transpose(getIcrfToFixed(time), scratchMatrix3);
                inertialFrameValue = Matrix3.multiplyByVector(fixedToIcrf, fixedFrameValue, result);
                return outputFrameParents.reduce(outputPositionAccumulator, inertialFrameValue);
            }

            return undefined;
        };

        return PositionProperty;
    }).call(this, $__require('35'), $__require('23'), $__require('24'), $__require('25'), $__require('3b'), $__require('3c'), $__require('3d'), $__require('36'), $__require('3e'));
});
/*global define*/
$__System.registerDynamic('42', ['2c', '23', '24', '25', '28', '2d'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, defineProperties, DeveloperError, freezeObject, JulianDate) {
        'use strict';

        /**
         * An interval defined by a start and a stop time; optionally including those times as part of the interval.
         * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
         *
         * @alias TimeInterval
         * @constructor
         *
         * @param {Object} [options] Object with the following properties:
         * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.
         * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.
         * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
         * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
         * @param {Object} [options.data] Arbitrary data associated with this interval.
         *
         * @example
         * // Create an instance that spans August 1st, 1980 and is associated
         * // with a Cartesian position.
         * var timeInterval = new Cesium.TimeInterval({
         *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),
         *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),
         *     isStartIncluded : true,
         *     isStopIncluded : false,
         *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)
         * });
         *
         * @example
         * // Create two instances from ISO 8601 intervals with associated numeric data
         * // then compute their intersection, summing the data they contain.
         * var left = Cesium.TimeInterval.fromIso8601({
         *     iso8601 : '2000/2010',
         *     data : 2
         * });
         *
         * var right = Cesium.TimeInterval.fromIso8601({
         *     iso8601 : '1995/2005',
         *     data : 3
         * });
         *
         * //The result of the below intersection will be an interval equivalent to
         * //var intersection = Cesium.TimeInterval.fromIso8601({
         * //  iso8601 : '2000/2005',
         * //  data : 5
         * //});
         * var intersection = new Cesium.TimeInterval();
         * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {
         *     return leftData + rightData;
         * });
         *
         * @example
         * // Check if an interval contains a specific time.
         * var dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');
         * var containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);
         */

        function TimeInterval(options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);
            /**
             * Gets or sets the start time of this interval.
             * @type {JulianDate}
             */
            this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();

            /**
             * Gets or sets the stop time of this interval.
             * @type {JulianDate}
             */
            this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();

            /**
             * Gets or sets the data associated with this interval.
             * @type {Object}
             */
            this.data = options.data;

            /**
             * Gets or sets whether or not the start time is included in this interval.
             * @type {Boolean}
             * @default true
             */
            this.isStartIncluded = defaultValue(options.isStartIncluded, true);

            /**
             * Gets or sets whether or not the stop time is included in this interval.
             * @type {Boolean}
             * @default true
             */
            this.isStopIncluded = defaultValue(options.isStopIncluded, true);
        }

        defineProperties(TimeInterval.prototype, {
            /**
             * Gets whether or not this interval is empty.
             * @memberof TimeInterval.prototype
             * @type {Boolean}
             * @readonly
             */
            isEmpty: {
                get: function () {
                    var stopComparedToStart = JulianDate.compare(this.stop, this.start);
                    return stopComparedToStart < 0 || stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded);
                }
            }
        });

        var scratchInterval = {
            start: undefined,
            stop: undefined,
            isStartIncluded: undefined,
            isStopIncluded: undefined,
            data: undefined
        };

        /**
         * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.
         *
         * @param {Object} options Object with the following properties:
         * @param {String} options.iso8601 An ISO 8601 interval.
         * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
         * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
         * @param {Object} [options.data] Arbitrary data associated with this interval.
         * @param {TimeInterval} [result] An existing instance to use for the result.
         * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
         */
        TimeInterval.fromIso8601 = function (options, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(options)) {
                throw new DeveloperError('options is required.');
            }
            if (!defined(options.iso8601)) {
                throw new DeveloperError('options.iso8601 is required.');
            }
            //>>includeEnd('debug');

            var dates = options.iso8601.split('/');
            var start = JulianDate.fromIso8601(dates[0]);
            var stop = JulianDate.fromIso8601(dates[1]);
            var isStartIncluded = defaultValue(options.isStartIncluded, true);
            var isStopIncluded = defaultValue(options.isStopIncluded, true);
            var data = options.data;

            if (!defined(result)) {
                scratchInterval.start = start;
                scratchInterval.stop = stop;
                scratchInterval.isStartIncluded = isStartIncluded;
                scratchInterval.isStopIncluded = isStopIncluded;
                scratchInterval.data = data;
                return new TimeInterval(scratchInterval);
            }

            result.start = start;
            result.stop = stop;
            result.isStartIncluded = isStartIncluded;
            result.isStopIncluded = isStopIncluded;
            result.data = data;
            return result;
        };

        /**
         * Creates an ISO8601 representation of the provided interval.
         *
         * @param {TimeInterval} timeInterval The interval to be converted.
         * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
         * @returns {String} The ISO8601 representation of the provided interval.
         */
        TimeInterval.toIso8601 = function (timeInterval, precision) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(timeInterval)) {
                throw new DeveloperError('timeInterval is required.');
            }
            //>>includeEnd('debug');

            return JulianDate.toIso8601(timeInterval.start, precision) + '/' + JulianDate.toIso8601(timeInterval.stop, precision);
        };

        /**
         * Duplicates the provided instance.
         *
         * @param {TimeInterval} [timeInterval] The instance to clone.
         * @param {TimeInterval} [result] An existing instance to use for the result.
         * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
         */
        TimeInterval.clone = function (timeInterval, result) {
            if (!defined(timeInterval)) {
                return undefined;
            }
            if (!defined(result)) {
                return new TimeInterval(timeInterval);
            }
            result.start = timeInterval.start;
            result.stop = timeInterval.stop;
            result.isStartIncluded = timeInterval.isStartIncluded;
            result.isStopIncluded = timeInterval.isStopIncluded;
            result.data = timeInterval.data;
            return result;
        };

        /**
         * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {TimeInterval} [left] The first instance.
         * @param {TimeInterval} [right] The second instance.
         * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
         * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
         */
        TimeInterval.equals = function (left, right, dataComparer) {
            return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equals(left.start, right.start) && JulianDate.equals(left.stop, right.stop) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));
        };

        /**
         * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
         * each other.  That is, in order for the dates to be considered equal (and for
         * this function to return <code>true</code>), the absolute value of the difference between them, in
         * seconds, must be less than <code>epsilon</code>.
         *
         * @param {TimeInterval} [left] The first instance.
         * @param {TimeInterval} [right] The second instance.
         * @param {Number} epsilon The maximum number of seconds that should separate the two instances.
         * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
         * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
         */
        TimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof epsilon !== 'number') {
                throw new DeveloperError('epsilon is required and must be a number.');
            }
            //>>includeEnd('debug');

            return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equalsEpsilon(left.start, right.start, epsilon) && JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));
        };

        /**
         * Computes the intersection of two intervals, optionally merging their data.
         *
         * @param {TimeInterval} left The first interval.
         * @param {TimeInterval} [right] The second interval.
         * @param {TimeInterval} result An existing instance to use for the result.
         * @param {TimeInterval~MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
         * @returns {TimeInterval} The modified result parameter.
         */
        TimeInterval.intersect = function (left, right, result, mergeCallback) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            if (!defined(right)) {
                return TimeInterval.clone(TimeInterval.EMPTY, result);
            }

            var leftStart = left.start;
            var leftStop = left.stop;

            var rightStart = right.start;
            var rightStop = right.stop;

            var intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);
            var intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);

            if (!intersectsStartRight && !intersectsStartLeft) {
                return TimeInterval.clone(TimeInterval.EMPTY, result);
            }

            var leftIsStartIncluded = left.isStartIncluded;
            var leftIsStopIncluded = left.isStopIncluded;
            var rightIsStartIncluded = right.isStartIncluded;
            var rightIsStopIncluded = right.isStopIncluded;
            var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);

            result.start = intersectsStartRight ? rightStart : leftStart;
            result.isStartIncluded = leftIsStartIncluded && rightIsStartIncluded || !JulianDate.equals(rightStart, leftStart) && (intersectsStartRight && rightIsStartIncluded || intersectsStartLeft && leftIsStartIncluded);
            result.stop = leftLessThanRight ? leftStop : rightStop;
            result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : leftIsStopIncluded && rightIsStopIncluded || !JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded;
            result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
            return result;
        };

        /**
         * Checks if the specified date is inside the provided interval.
         *
         * @param {TimeInterval} timeInterval The interval.
         * @param {JulianDate} julianDate The date to check.
         * @returns {Boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.
         */
        TimeInterval.contains = function (timeInterval, julianDate) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(timeInterval)) {
                throw new DeveloperError('timeInterval is required.');
            }
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            //>>includeEnd('debug');

            if (timeInterval.isEmpty) {
                return false;
            }

            var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);
            if (startComparedToDate === 0) {
                return timeInterval.isStartIncluded;
            }

            var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);
            if (dateComparedToStop === 0) {
                return timeInterval.isStopIncluded;
            }

            return startComparedToDate < 0 && dateComparedToStop < 0;
        };

        /**
         * Duplicates this instance.
         *
         * @param {TimeInterval} [result] An existing instance to use for the result.
         * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
         */
        TimeInterval.prototype.clone = function (result) {
            return TimeInterval.clone(this, result);
        };

        /**
         * Compares this instance against the provided instance componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {TimeInterval} [right] The right hand side interval.
         * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        TimeInterval.prototype.equals = function (right, dataComparer) {
            return TimeInterval.equals(this, right, dataComparer);
        };

        /**
         * Compares this instance against the provided instance componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {TimeInterval} [right] The right hand side interval.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @param {TimeInterval~DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
         * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
         */
        TimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {
            return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
        };

        /**
         * Creates a string representing this TimeInterval in ISO8601 format.
         *
         * @returns {String} A string representing this TimeInterval in ISO8601 format.
         */
        TimeInterval.prototype.toString = function () {
            return TimeInterval.toIso8601(this);
        };

        /**
         * An immutable empty interval.
         *
         * @type {TimeInterval}
         * @constant
         */
        TimeInterval.EMPTY = freezeObject(new TimeInterval({
            start: new JulianDate(),
            stop: new JulianDate(),
            isStartIncluded: false,
            isStopIncluded: false
        }));

        /**
         * Function interface for merging interval data.
         * @callback TimeInterval~MergeCallback
         *
         * @param {Object} leftData The first data instance.
         * @param {Object} rightData The second data instance.
         * @returns {Object} The result of merging the two data instances.
         */

        /**
         * Function interface for comparing interval data.
         * @callback TimeInterval~DataComparer
         * @param {Object} leftData The first data instance.
         * @param {Object} rightData The second data instance.
         * @returns {Boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.
         */

        return TimeInterval;
    }).call(this, $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('28'), $__require('2d'));
});
/*global define*/
$__System.registerDynamic('40', ['28', '2d', '42'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject, JulianDate, TimeInterval) {
    'use strict';

    var MINIMUM_VALUE = freezeObject(JulianDate.fromIso8601('0000-01-01T00:00:00Z'));
    var MAXIMUM_VALUE = freezeObject(JulianDate.fromIso8601('9999-12-31T24:00:00Z'));
    var MAXIMUM_INTERVAL = freezeObject(new TimeInterval({
      start: MINIMUM_VALUE,
      stop: MAXIMUM_VALUE
    }));

    /**
     * Constants related to ISO8601 support.
     *
     * @exports Iso8601
     *
     * @see {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601 on Wikipedia}
     * @see JulianDate
     * @see TimeInterval
     */
    var Iso8601 = {
      /**
       * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
       * This is equivalent to the date string '0000-01-01T00:00:00Z'
       */
      MINIMUM_VALUE: MINIMUM_VALUE,

      /**
       * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
       * This is equivalent to the date string '9999-12-31T24:00:00Z'
       */
      MAXIMUM_VALUE: MAXIMUM_VALUE,

      /**
       * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
       * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
       */
      MAXIMUM_INTERVAL: MAXIMUM_INTERVAL
    };

    return Iso8601;
  }).call(this, $__require('28'), $__require('2d'), $__require('42'));
});
/*global define*/
$__System.registerDynamic('3f', ['2c', '23', '24', '25', '40'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, defineProperties, DeveloperError, Iso8601) {
        'use strict';

        /**
         * The interface for all properties, which represent a value that can optionally vary over time.
         * This type defines an interface and cannot be instantiated directly.
         *
         * @alias Property
         * @constructor
         *
         * @see CompositeProperty
         * @see ConstantProperty
         * @see SampledProperty
         * @see TimeIntervalCollectionProperty
         * @see MaterialProperty
         * @see PositionProperty
         * @see ReferenceProperty
         */

        function Property() {
            DeveloperError.throwInstantiationError();
        }

        defineProperties(Property.prototype, {
            /**
             * Gets a value indicating if this property is constant.  A property is considered
             * constant if getValue always returns the same result for the current definition.
             * @memberof Property.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: DeveloperError.throwInstantiationError
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is considered to have changed if a call to getValue would return
             * a different result for the same time.
             * @memberof Property.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: DeveloperError.throwInstantiationError
            }
        });

        /**
         * Gets the value of the property at the provided time.
         * @function
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        Property.prototype.getValue = DeveloperError.throwInstantiationError;

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         * @function
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Property.prototype.equals = DeveloperError.throwInstantiationError;

        /**
         * @private
         */
        Property.equals = function (left, right) {
            return left === right || defined(left) && left.equals(right);
        };

        /**
         * @private
         */
        Property.arrayEquals = function (left, right) {
            if (left === right) {
                return true;
            }
            if (!defined(left) || !defined(right) || left.length !== right.length) {
                return false;
            }
            var length = left.length;
            for (var i = 0; i < length; i++) {
                if (!Property.equals(left[i], right[i])) {
                    return false;
                }
            }
            return true;
        };

        /**
         * @private
         */
        Property.isConstant = function (property) {
            return !defined(property) || property.isConstant;
        };

        /**
         * @private
         */
        Property.getValueOrUndefined = function (property, time, result) {
            return defined(property) ? property.getValue(time, result) : undefined;
        };

        /**
         * @private
         */
        Property.getValueOrDefault = function (property, time, valueDefault, result) {
            return defined(property) ? defaultValue(property.getValue(time, result), valueDefault) : valueDefault;
        };

        /**
         * @private
         */
        Property.getValueOrClonedDefault = function (property, time, valueDefault, result) {
            var value;
            if (defined(property)) {
                value = property.getValue(time, result);
            }
            if (!defined(value)) {
                value = valueDefault.clone(value);
            }
            return value;
        };

        return Property;
    }).call(this, $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('40'));
});
/*global define*/
$__System.registerDynamic('51', ['35', '2c', '23', '24', '25', '26', '36', '37', '3f', '52'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defaultValue, defined, defineProperties, DeveloperError, Event, ReferenceFrame, PositionProperty, Property, SampledProperty) {
        'use strict';

        /**
         * A {@link SampledProperty} which is also a {@link PositionProperty}.
         *
         * @alias SampledPositionProperty
         * @constructor
         *
         * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
         * @param {Number} [numberOfDerivatives=0] The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...
         */

        function SampledPositionProperty(referenceFrame, numberOfDerivatives) {
            numberOfDerivatives = defaultValue(numberOfDerivatives, 0);

            var derivativeTypes;
            if (numberOfDerivatives > 0) {
                derivativeTypes = new Array(numberOfDerivatives);
                for (var i = 0; i < numberOfDerivatives; i++) {
                    derivativeTypes[i] = Cartesian3;
                }
            }

            this._numberOfDerivatives = numberOfDerivatives;
            this._property = new SampledProperty(Cartesian3, derivativeTypes);
            this._definitionChanged = new Event();
            this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);

            this._property._definitionChanged.addEventListener(function () {
                this._definitionChanged.raiseEvent(this);
            }, this);
        }

        defineProperties(SampledPositionProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.  A property is considered
             * constant if getValue always returns the same result for the current definition.
             * @memberof SampledPositionProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: function () {
                    return this._property.isConstant;
                }
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is considered to have changed if a call to getValue would return
             * a different result for the same time.
             * @memberof SampledPositionProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            },
            /**
             * Gets the reference frame in which the position is defined.
             * @memberof SampledPositionProperty.prototype
             * @type {ReferenceFrame}
             * @default ReferenceFrame.FIXED;
             */
            referenceFrame: {
                get: function () {
                    return this._referenceFrame;
                }
            },
            /**
             * Gets the degree of interpolation to perform when retrieving a value.
             * @memberof SampledPositionProperty.prototype
             *
             * @type {Number}
             * @default 1
             */
            interpolationDegree: {
                get: function () {
                    return this._property.interpolationDegree;
                }
            },
            /**
             * Gets the interpolation algorithm to use when retrieving a value.
             * @memberof SampledPositionProperty.prototype
             *
             * @type {InterpolationAlgorithm}
             * @default LinearApproximation
             */
            interpolationAlgorithm: {
                get: function () {
                    return this._property.interpolationAlgorithm;
                }
            },
            /**
             * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
             * @memberof SampledPositionProperty.prototype
             *
             * @type {Boolean}
             * @default false
             */
            numberOfDerivatives: {
                get: function () {
                    return this._numberOfDerivatives;
                }
            },
            /**
             * Gets or sets the type of extrapolation to perform when a value
             * is requested at a time after any available samples.
             * @memberof SampledPositionProperty.prototype
             * @type {ExtrapolationType}
             * @default ExtrapolationType.NONE
             */
            forwardExtrapolationType: {
                get: function () {
                    return this._property.forwardExtrapolationType;
                },
                set: function (value) {
                    this._property.forwardExtrapolationType = value;
                }
            },
            /**
             * Gets or sets the amount of time to extrapolate forward before
             * the property becomes undefined.  A value of 0 will extrapolate forever.
             * @memberof SampledPositionProperty.prototype
             * @type {Number}
             * @default 0
             */
            forwardExtrapolationDuration: {
                get: function () {
                    return this._property.forwardExtrapolationDuration;
                },
                set: function (value) {
                    this._property.forwardExtrapolationDuration = value;
                }
            },
            /**
             * Gets or sets the type of extrapolation to perform when a value
             * is requested at a time before any available samples.
             * @memberof SampledPositionProperty.prototype
             * @type {ExtrapolationType}
             * @default ExtrapolationType.NONE
             */
            backwardExtrapolationType: {
                get: function () {
                    return this._property.backwardExtrapolationType;
                },
                set: function (value) {
                    this._property.backwardExtrapolationType = value;
                }
            },
            /**
             * Gets or sets the amount of time to extrapolate backward
             * before the property becomes undefined.  A value of 0 will extrapolate forever.
             * @memberof SampledPositionProperty.prototype
             * @type {Number}
             * @default 0
             */
            backwardExtrapolationDuration: {
                get: function () {
                    return this._property.backwardExtrapolationDuration;
                },
                set: function (value) {
                    this._property.backwardExtrapolationDuration = value;
                }
            }
        });

        /**
         * Gets the position at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        SampledPositionProperty.prototype.getValue = function (time, result) {
            return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
        };

        /**
         * Gets the position at the provided time and in the provided reference frame.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
         * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        SampledPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(time)) {
                throw new DeveloperError('time is required.');
            }
            if (!defined(referenceFrame)) {
                throw new DeveloperError('referenceFrame is required.');
            }
            //>>includeEnd('debug');

            result = this._property.getValue(time, result);
            if (defined(result)) {
                return PositionProperty.convertToReferenceFrame(time, result, this._referenceFrame, referenceFrame, result);
            }
            return undefined;
        };

        /**
         * Sets the algorithm and degree to use when interpolating a position.
         *
         * @param {Object} [options] Object with the following properties:
         * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.
         * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.
         */
        SampledPositionProperty.prototype.setInterpolationOptions = function (options) {
            this._property.setInterpolationOptions(options);
        };

        /**
         * Adds a new sample.
         *
         * @param {JulianDate} time The sample time.
         * @param {Cartesian3} position The position at the provided time.
         * @param {Cartesian3[]} [derivatives] The array of derivative values at the provided time.
         */
        SampledPositionProperty.prototype.addSample = function (time, position, derivatives) {
            var numberOfDerivatives = this._numberOfDerivatives;
            //>>includeStart('debug', pragmas.debug);
            if (numberOfDerivatives > 0 && (!defined(derivatives) || derivatives.length !== numberOfDerivatives)) {
                throw new DeveloperError('derivatives length must be equal to the number of derivatives.');
            }
            //>>includeEnd('debug');
            this._property.addSample(time, position, derivatives);
        };

        /**
         * Adds multiple samples via parallel arrays.
         *
         * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.
         * @param {Cartesian3[]} positions An array of Cartesian3 position instances, where each value corresponds to the provided time index.
         * @param {Array[]} [derivatives] An array where each value is another array containing derivatives for the corresponding time index.
         *
         * @exception {DeveloperError} All arrays must be the same length.
         */
        SampledPositionProperty.prototype.addSamples = function (times, positions, derivatives) {
            this._property.addSamples(times, positions, derivatives);
        };

        /**
         * Adds samples as a single packed array where each new sample is represented as a date,
         * followed by the packed representation of the corresponding value and derivatives.
         *
         * @param {Number[]} packedSamples The array of packed samples.
         * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
         */
        SampledPositionProperty.prototype.addSamplesPackedArray = function (data, epoch) {
            this._property.addSamplesPackedArray(data, epoch);
        };

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        SampledPositionProperty.prototype.equals = function (other) {
            return this === other || //
            other instanceof SampledPositionProperty && Property.equals(this._property, other._property) && //
            this._referenceFrame === other._referenceFrame;
        };

        return SampledPositionProperty;
    }).call(this, $__require('35'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('36'), $__require('37'), $__require('3f'), $__require('52'));
});
/*global define*/
$__System.registerDynamic('26', ['23', '24', '25'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties, DeveloperError) {
        'use strict';

        /**
         * A generic utility class for managing subscribers for a particular event.
         * This class is usually instantiated inside of a container class and
         * exposed as a property for others to subscribe to.
         *
         * @alias Event
         * @constructor
         *
         * @example
         * MyObject.prototype.myListener = function(arg1, arg2) {
         *     this.myArg1Copy = arg1;
         *     this.myArg2Copy = arg2;
         * }
         *
         * var myObjectInstance = new MyObject();
         * var evt = new Cesium.Event();
         * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
         * evt.raiseEvent('1', '2');
         * evt.removeEventListener(MyObject.prototype.myListener);
         */

        function Event() {
            this._listeners = [];
            this._scopes = [];
            this._toRemove = [];
            this._insideRaiseEvent = false;
        }

        defineProperties(Event.prototype, {
            /**
             * The number of listeners currently subscribed to the event.
             * @memberof Event.prototype
             * @type {Number}
             * @readonly
             */
            numberOfListeners: {
                get: function () {
                    return this._listeners.length - this._toRemove.length;
                }
            }
        });

        /**
         * Registers a callback function to be executed whenever the event is raised.
         * An optional scope can be provided to serve as the <code>this</code> pointer
         * in which the function will execute.
         *
         * @param {Function} listener The function to be executed when the event is raised.
         * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
         *        pointer in which the listener function will execute.
         * @returns {Event~RemoveCallback} A function that will remove this event listener when invoked.
         *
         * @see Event#raiseEvent
         * @see Event#removeEventListener
         */
        Event.prototype.addEventListener = function (listener, scope) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof listener !== 'function') {
                throw new DeveloperError('listener is required and must be a function.');
            }
            //>>includeEnd('debug');

            this._listeners.push(listener);
            this._scopes.push(scope);

            var event = this;
            return function () {
                event.removeEventListener(listener, scope);
            };
        };

        /**
         * Unregisters a previously registered callback.
         *
         * @param {Function} listener The function to be unregistered.
         * @param {Object} [scope] The scope that was originally passed to addEventListener.
         * @returns {Boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.
         *
         * @see Event#addEventListener
         * @see Event#raiseEvent
         */
        Event.prototype.removeEventListener = function (listener, scope) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof listener !== 'function') {
                throw new DeveloperError('listener is required and must be a function.');
            }
            //>>includeEnd('debug');

            var listeners = this._listeners;
            var scopes = this._scopes;

            var index = -1;
            for (var i = 0; i < listeners.length; i++) {
                if (listeners[i] === listener && scopes[i] === scope) {
                    index = i;
                    break;
                }
            }

            if (index !== -1) {
                if (this._insideRaiseEvent) {
                    //In order to allow removing an event subscription from within
                    //a callback, we don't actually remove the items here.  Instead
                    //remember the index they are at and undefined their value.
                    this._toRemove.push(index);
                    listeners[index] = undefined;
                    scopes[index] = undefined;
                } else {
                    listeners.splice(index, 1);
                    scopes.splice(index, 1);
                }
                return true;
            }

            return false;
        };

        /**
         * Raises the event by calling each registered listener with all supplied arguments.
         *
         * @param {*} arguments This method takes any number of parameters and passes them through to the listener functions.
         *
         * @see Event#addEventListener
         * @see Event#removeEventListener
         */
        Event.prototype.raiseEvent = function () {
            this._insideRaiseEvent = true;

            var i;
            var listeners = this._listeners;
            var scopes = this._scopes;
            var length = listeners.length;

            for (i = 0; i < length; i++) {
                var listener = listeners[i];
                if (defined(listener)) {
                    listeners[i].apply(scopes[i], arguments);
                }
            }

            //Actually remove items removed in removeEventListener.
            var toRemove = this._toRemove;
            length = toRemove.length;
            for (i = 0; i < length; i++) {
                var index = toRemove[i];
                listeners.splice(index, 1);
                scopes.splice(index, 1);
            }
            toRemove.length = 0;

            this._insideRaiseEvent = false;
        };

        /**
         * A function that removes a listener.
         * @callback Event~RemoveCallback
         */

        return Event;
    }).call(this, $__require('23'), $__require('24'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('53', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * Constants to determine how an interpolated value is extrapolated
     * when querying outside the bounds of available data.
     * 
     * @exports ExtrapolationType
     *
     * @see SampledProperty
     */

    var ExtrapolationType = {
      /**
       * No extrapolation occurs.
       *
       * @type {Number}
       * @constant
       */
      NONE: 0,

      /**
       * The first or last value is used when outside the range of sample data.
       *
       * @type {Number}
       * @constant
       */
      HOLD: 1,

      /**
       * The value is extrapolated.
       *
       * @type {Number}
       * @constant
       */
      EXTRAPOLATE: 2
    };

    return freezeObject(ExtrapolationType);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('54', ['23', '25'], false, function ($__require, $__exports, $__module) {
    return (function (defined, DeveloperError) {
        'use strict';

        /**
         * An {@link InterpolationAlgorithm} for performing linear interpolation.
         *
         * @exports LinearApproximation
         */

        var LinearApproximation = {
            type: 'Linear'
        };

        /**
         * Given the desired degree, returns the number of data points required for interpolation.
         * Since linear interpolation can only generate a first degree polynomial, this function
         * always returns 2.
         * @param {Number} degree The desired degree of interpolation.
         * @returns {Number} This function always returns 2.
         *
         */
        LinearApproximation.getRequiredDataPoints = function (degree) {
            return 2;
        };

        /**
         * Interpolates values using linear approximation.
         *
         * @param {Number} x The independent variable for which the dependent variables will be interpolated.
         * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
         * in this array must be in increasing order and the same value must not occur twice in the array.
         * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
         * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
         * @param {Number} yStride The number of dependent variable values in yTable corresponding to
         * each independent variable value in xTable.
         * @param {Number[]} [result] An existing array into which to store the result.
         * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
         */
        LinearApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {
            //>>includeStart('debug', pragmas.debug);
            if (xTable.length !== 2) {
                throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
            } else if (yStride <= 0) {
                throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Array(yStride);
            }

            var i;
            var y0;
            var y1;
            var x0 = xTable[0];
            var x1 = xTable[1];

            //>>includeStart('debug', pragmas.debug);
            if (x0 === x1) {
                throw new DeveloperError('Divide by zero error: xTable[0] and xTable[1] are equal');
            }
            //>>includeEnd('debug');

            for (i = 0; i < yStride; i++) {
                y0 = yTable[i];
                y1 = yTable[i + yStride];
                result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);
            }

            return result;
        };

        return LinearApproximation;
    }).call(this, $__require('23'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('52', ['55', '2c', '23', '24', '25', '26', '53', '2d', '54'], false, function ($__require, $__exports, $__module) {
    return (function (binarySearch, defaultValue, defined, defineProperties, DeveloperError, Event, ExtrapolationType, JulianDate, LinearApproximation) {
        'use strict';

        var PackableNumber = {
            packedLength: 1,
            pack: function (value, array, startingIndex) {
                startingIndex = defaultValue(startingIndex, 0);
                array[startingIndex] = value;
            },
            unpack: function (array, startingIndex, result) {
                startingIndex = defaultValue(startingIndex, 0);
                return array[startingIndex];
            }
        };

        //We can't use splice for inserting new elements because function apply can't handle
        //a huge number of arguments.  See https://code.google.com/p/chromium/issues/detail?id=56588
        function arrayInsert(array, startIndex, items) {
            var i;
            var arrayLength = array.length;
            var itemsLength = items.length;
            var newLength = arrayLength + itemsLength;

            array.length = newLength;
            if (arrayLength !== startIndex) {
                var q = arrayLength - 1;
                for (i = newLength - 1; i >= startIndex; i--) {
                    array[i] = array[q--];
                }
            }

            for (i = 0; i < itemsLength; i++) {
                array[startIndex++] = items[i];
            }
        }

        function convertDate(date, epoch) {
            if (date instanceof JulianDate) {
                return date;
            }
            if (typeof date === 'string') {
                return JulianDate.fromIso8601(date);
            }
            return JulianDate.addSeconds(epoch, date, new JulianDate());
        }

        var timesSpliceArgs = [];
        var valuesSpliceArgs = [];

        function mergeNewSamples(epoch, times, values, newData, packedLength) {
            var newDataIndex = 0;
            var i;
            var prevItem;
            var timesInsertionPoint;
            var valuesInsertionPoint;
            var currentTime;
            var nextTime;

            while (newDataIndex < newData.length) {
                currentTime = convertDate(newData[newDataIndex], epoch);
                timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);
                var timesSpliceArgsCount = 0;
                var valuesSpliceArgsCount = 0;

                if (timesInsertionPoint < 0) {
                    //Doesn't exist, insert as many additional values as we can.
                    timesInsertionPoint = ~timesInsertionPoint;

                    valuesInsertionPoint = timesInsertionPoint * packedLength;
                    prevItem = undefined;
                    nextTime = times[timesInsertionPoint];
                    while (newDataIndex < newData.length) {
                        currentTime = convertDate(newData[newDataIndex], epoch);
                        if (defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0 || defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0) {
                            break;
                        }
                        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
                        newDataIndex = newDataIndex + 1;
                        for (i = 0; i < packedLength; i++) {
                            valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
                            newDataIndex = newDataIndex + 1;
                        }
                        prevItem = currentTime;
                    }

                    if (timesSpliceArgsCount > 0) {
                        valuesSpliceArgs.length = valuesSpliceArgsCount;
                        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);

                        timesSpliceArgs.length = timesSpliceArgsCount;
                        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
                    }
                } else {
                    //Found an exact match
                    for (i = 0; i < packedLength; i++) {
                        newDataIndex++;
                        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];
                    }
                    newDataIndex++;
                }
            }
        }

        /**
         * A {@link Property} whose value is interpolated for a given time from the
         * provided set of samples and specified interpolation algorithm and degree.
         * @alias SampledProperty
         * @constructor
         *
         * @param {Number|Packable} type The type of property.
         * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.
         *
         *
         * @example
         * //Create a linearly interpolated Cartesian2
         * var property = new Cesium.SampledProperty(Cesium.Cartesian2);
         *
         * //Populate it with data
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:00:00.00Z`), new Cesium.Cartesian2(0, 0));
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-02T00:00:00.00Z`), new Cesium.Cartesian2(4, 7));
         *
         * //Retrieve an interpolated value
         * var result = property.getValue(Cesium.JulianDate.fromIso8601(`2012-08-01T12:00:00.00Z`));
         *
         * @example
         * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation
         * var property = new Cesium.SampledProperty(Number);
         * property.setInterpolationOptions({
         *     interpolationDegree : 3,
         *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation
         * });
         *
         * //Populate it with data
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:00:00.00Z`), 1.0);
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:01:00.00Z`), 6.0);
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:02:00.00Z`), 12.0);
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:03:30.00Z`), 5.0);
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:06:30.00Z`), 2.0);
         *
         * //Samples can be added in any order.
         * property.addSample(Cesium.JulianDate.fromIso8601(`2012-08-01T00:00:30.00Z`), 6.2);
         *
         * //Retrieve an interpolated value
         * var result = property.getValue(Cesium.JulianDate.fromIso8601(`2012-08-01T00:02:34.00Z`));
         * 
         * @see SampledPositionProperty
         */
        function SampledProperty(type, derivativeTypes) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(type)) {
                throw new DeveloperError('type is required.');
            }
            //>>includeEnd('debug');

            var innerType = type;
            if (innerType === Number) {
                innerType = PackableNumber;
            }
            var packedLength = innerType.packedLength;
            var packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);

            var inputOrder = 0;
            var innerDerivativeTypes;
            if (defined(derivativeTypes)) {
                var length = derivativeTypes.length;
                innerDerivativeTypes = new Array(length);
                for (var i = 0; i < length; i++) {
                    var derivativeType = derivativeTypes[i];
                    if (derivativeType === Number) {
                        derivativeType = PackableNumber;
                    }
                    var derivativePackedLength = derivativeType.packedLength;
                    packedLength += derivativePackedLength;
                    packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);
                    innerDerivativeTypes[i] = derivativeType;
                }
                inputOrder = length;
            }

            this._type = type;
            this._innerType = innerType;
            this._interpolationDegree = 1;
            this._interpolationAlgorithm = LinearApproximation;
            this._numberOfPoints = 0;
            this._times = [];
            this._values = [];
            this._xTable = [];
            this._yTable = [];
            this._packedLength = packedLength;
            this._packedInterpolationLength = packedInterpolationLength;
            this._updateTableLength = true;
            this._interpolationResult = new Array(packedInterpolationLength);
            this._definitionChanged = new Event();
            this._derivativeTypes = derivativeTypes;
            this._innerDerivativeTypes = innerDerivativeTypes;
            this._inputOrder = inputOrder;
            this._forwardExtrapolationType = ExtrapolationType.NONE;
            this._forwardExtrapolationDuration = 0;
            this._backwardExtrapolationType = ExtrapolationType.NONE;
            this._backwardExtrapolationDuration = 0;
        }

        defineProperties(SampledProperty.prototype, {
            /**
             * Gets a value indicating if this property is constant.  A property is considered
             * constant if getValue always returns the same result for the current definition.
             * @memberof SampledProperty.prototype
             *
             * @type {Boolean}
             * @readonly
             */
            isConstant: {
                get: function () {
                    return this._values.length === 0;
                }
            },
            /**
             * Gets the event that is raised whenever the definition of this property changes.
             * The definition is considered to have changed if a call to getValue would return
             * a different result for the same time.
             * @memberof SampledProperty.prototype
             *
             * @type {Event}
             * @readonly
             */
            definitionChanged: {
                get: function () {
                    return this._definitionChanged;
                }
            },
            /**
             * Gets the type of property.
             * @memberof SampledProperty.prototype
             * @type {Object}
             */
            type: {
                get: function () {
                    return this._type;
                }
            },
            /**
             * Gets the derivative types used by this property.
             * @memberof SampledProperty.prototype
             * @type {Packable[]}
             */
            derivativeTypes: {
                get: function () {
                    return this._derivativeTypes;
                }
            },
            /**
             * Gets the degree of interpolation to perform when retrieving a value.
             * @memberof SampledProperty.prototype
             * @type {Number}
             * @default 1
             */
            interpolationDegree: {
                get: function () {
                    return this._interpolationDegree;
                }
            },
            /**
             * Gets the interpolation algorithm to use when retrieving a value.
             * @memberof SampledProperty.prototype
             * @type {InterpolationAlgorithm}
             * @default LinearApproximation
             */
            interpolationAlgorithm: {
                get: function () {
                    return this._interpolationAlgorithm;
                }
            },
            /**
             * Gets or sets the type of extrapolation to perform when a value
             * is requested at a time after any available samples.
             * @memberof SampledProperty.prototype
             * @type {ExtrapolationType}
             * @default ExtrapolationType.NONE
             */
            forwardExtrapolationType: {
                get: function () {
                    return this._forwardExtrapolationType;
                },
                set: function (value) {
                    if (this._forwardExtrapolationType !== value) {
                        this._forwardExtrapolationType = value;
                        this._definitionChanged.raiseEvent(this);
                    }
                }
            },
            /**
             * Gets or sets the amount of time to extrapolate forward before
             * the property becomes undefined.  A value of 0 will extrapolate forever.
             * @memberof SampledProperty.prototype
             * @type {Number}
             * @default 0
             */
            forwardExtrapolationDuration: {
                get: function () {
                    return this._forwardExtrapolationDuration;
                },
                set: function (value) {
                    if (this._forwardExtrapolationDuration !== value) {
                        this._forwardExtrapolationDuration = value;
                        this._definitionChanged.raiseEvent(this);
                    }
                }
            },
            /**
             * Gets or sets the type of extrapolation to perform when a value
             * is requested at a time before any available samples.
             * @memberof SampledProperty.prototype
             * @type {ExtrapolationType}
             * @default ExtrapolationType.NONE
             */
            backwardExtrapolationType: {
                get: function () {
                    return this._backwardExtrapolationType;
                },
                set: function (value) {
                    if (this._backwardExtrapolationType !== value) {
                        this._backwardExtrapolationType = value;
                        this._definitionChanged.raiseEvent(this);
                    }
                }
            },
            /**
             * Gets or sets the amount of time to extrapolate backward
             * before the property becomes undefined.  A value of 0 will extrapolate forever.
             * @memberof SampledProperty.prototype
             * @type {Number}
             * @default 0
             */
            backwardExtrapolationDuration: {
                get: function () {
                    return this._backwardExtrapolationDuration;
                },
                set: function (value) {
                    if (this._backwardExtrapolationDuration !== value) {
                        this._backwardExtrapolationDuration = value;
                        this._definitionChanged.raiseEvent(this);
                    }
                }
            }
        });

        /**
         * Gets the value of the property at the provided time.
         *
         * @param {JulianDate} time The time for which to retrieve the value.
         * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
         * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
         */
        SampledProperty.prototype.getValue = function (time, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(time)) {
                throw new DeveloperError('time is required.');
            }
            //>>includeEnd('debug');

            var times = this._times;
            var timesLength = times.length;
            if (timesLength === 0) {
                return undefined;
            }

            var timeout;
            var innerType = this._innerType;
            var values = this._values;
            var index = binarySearch(times, time, JulianDate.compare);

            if (index < 0) {
                index = ~index;

                if (index === 0) {
                    var startTime = times[index];
                    timeout = this._backwardExtrapolationDuration;
                    if (this._backwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout) {
                        return undefined;
                    }
                    if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {
                        return innerType.unpack(values, 0, result);
                    }
                }

                if (index >= timesLength) {
                    index = timesLength - 1;
                    var endTime = times[index];
                    timeout = this._forwardExtrapolationDuration;
                    if (this._forwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout) {
                        return undefined;
                    }
                    if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {
                        index = timesLength - 1;
                        return innerType.unpack(values, index * innerType.packedLength, result);
                    }
                }

                var xTable = this._xTable;
                var yTable = this._yTable;
                var interpolationAlgorithm = this._interpolationAlgorithm;
                var packedInterpolationLength = this._packedInterpolationLength;
                var inputOrder = this._inputOrder;

                if (this._updateTableLength) {
                    this._updateTableLength = false;
                    var numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), timesLength);
                    if (numberOfPoints !== this._numberOfPoints) {
                        this._numberOfPoints = numberOfPoints;
                        xTable.length = numberOfPoints;
                        yTable.length = numberOfPoints * packedInterpolationLength;
                    }
                }

                var degree = this._numberOfPoints - 1;
                if (degree < 1) {
                    return undefined;
                }

                var firstIndex = 0;
                var lastIndex = timesLength - 1;
                var pointsInCollection = lastIndex - firstIndex + 1;

                if (pointsInCollection >= degree + 1) {
                    var computedFirstIndex = index - (degree / 2 | 0) - 1;
                    if (computedFirstIndex < firstIndex) {
                        computedFirstIndex = firstIndex;
                    }
                    var computedLastIndex = computedFirstIndex + degree;
                    if (computedLastIndex > lastIndex) {
                        computedLastIndex = lastIndex;
                        computedFirstIndex = computedLastIndex - degree;
                        if (computedFirstIndex < firstIndex) {
                            computedFirstIndex = firstIndex;
                        }
                    }

                    firstIndex = computedFirstIndex;
                    lastIndex = computedLastIndex;
                }
                var length = lastIndex - firstIndex + 1;

                // Build the tables
                for (var i = 0; i < length; ++i) {
                    xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);
                }

                if (!defined(innerType.convertPackedArrayForInterpolation)) {
                    var destinationIndex = 0;
                    var packedLength = this._packedLength;
                    var sourceIndex = firstIndex * packedLength;
                    var stop = (lastIndex + 1) * packedLength;

                    while (sourceIndex < stop) {
                        yTable[destinationIndex] = values[sourceIndex];
                        sourceIndex++;
                        destinationIndex++;
                    }
                } else {
                    innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);
                }

                // Interpolate!
                var x = JulianDate.secondsDifference(time, times[lastIndex]);
                var interpolationResult;
                if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {
                    interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);
                } else {
                    var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
                    interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);
                }

                if (!defined(innerType.unpackInterpolationResult)) {
                    return innerType.unpack(interpolationResult, 0, result);
                }
                return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);
            }
            return innerType.unpack(values, index * this._packedLength, result);
        };

        /**
         * Sets the algorithm and degree to use when interpolating a value.
         *
         * @param {Object} [options] Object with the following properties:
         * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.
         * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.
         */
        SampledProperty.prototype.setInterpolationOptions = function (options) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(options)) {
                throw new DeveloperError('options is required.');
            }
            //>>includeEnd('debug');

            var valuesChanged = false;

            var interpolationAlgorithm = options.interpolationAlgorithm;
            var interpolationDegree = options.interpolationDegree;

            if (this._interpolationAlgorithm !== interpolationAlgorithm) {
                this._interpolationAlgorithm = interpolationAlgorithm;
                valuesChanged = true;
            }

            if (this._interpolationDegree !== interpolationDegree) {
                this._interpolationDegree = interpolationDegree;
                valuesChanged = true;
            }

            if (valuesChanged) {
                this._updateTableLength = true;
                this._definitionChanged.raiseEvent(this);
            }
        };

        /**
         * Adds a new sample
         *
         * @param {JulianDate} time The sample time.
         * @param {Packable} value The value at the provided time.
         * @param {Packable[]} [derivatives] The array of derivatives at the provided time.
         */
        SampledProperty.prototype.addSample = function (time, value, derivatives) {
            var innerDerivativeTypes = this._innerDerivativeTypes;
            var hasDerivatives = defined(innerDerivativeTypes);

            //>>includeStart('debug', pragmas.debug);
            if (!defined(time)) {
                throw new DeveloperError('time is required.');
            }
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (hasDerivatives && !defined(derivatives)) {
                throw new DeveloperError('derivatives is required.');
            }
            //>>includeEnd('debug');

            var innerType = this._innerType;
            var data = [];
            data.push(time);
            innerType.pack(value, data, data.length);

            if (hasDerivatives) {
                var derivativesLength = innerDerivativeTypes.length;
                for (var x = 0; x < derivativesLength; x++) {
                    innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
                }
            }
            mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
            this._updateTableLength = true;
            this._definitionChanged.raiseEvent(this);
        };

        /**
         * Adds an array of samples
         *
         * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.
         * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.
         * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.
         *
         * @exception {DeveloperError} times and values must be the same length.
         * @exception {DeveloperError} times and derivativeValues must be the same length.
         */
        SampledProperty.prototype.addSamples = function (times, values, derivativeValues) {
            var innerDerivativeTypes = this._innerDerivativeTypes;
            var hasDerivatives = defined(innerDerivativeTypes);

            //>>includeStart('debug', pragmas.debug);
            if (!defined(times)) {
                throw new DeveloperError('times is required.');
            }
            if (!defined(values)) {
                throw new DeveloperError('values is required.');
            }
            if (times.length !== values.length) {
                throw new DeveloperError('times and values must be the same length.');
            }
            if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {
                throw new DeveloperError('times and derivativeValues must be the same length.');
            }
            //>>includeEnd('debug');

            var innerType = this._innerType;
            var length = times.length;
            var data = [];
            for (var i = 0; i < length; i++) {
                data.push(times[i]);
                innerType.pack(values[i], data, data.length);

                if (hasDerivatives) {
                    var derivatives = derivativeValues[i];
                    var derivativesLength = innerDerivativeTypes.length;
                    for (var x = 0; x < derivativesLength; x++) {
                        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
                    }
                }
            }
            mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
            this._updateTableLength = true;
            this._definitionChanged.raiseEvent(this);
        };

        /**
         * Adds samples as a single packed array where each new sample is represented as a date,
         * followed by the packed representation of the corresponding value and derivatives.
         *
         * @param {Number[]} packedSamples The array of packed samples.
         * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
         */
        SampledProperty.prototype.addSamplesPackedArray = function (packedSamples, epoch) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(packedSamples)) {
                throw new DeveloperError('packedSamples is required.');
            }
            //>>includeEnd('debug');

            mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);
            this._updateTableLength = true;
            this._definitionChanged.raiseEvent(this);
        };

        /**
         * Compares this property to the provided property and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Property} [other] The other property.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        SampledProperty.prototype.equals = function (other) {
            if (this === other) {
                return true;
            }
            if (!defined(other)) {
                return false;
            }

            if (this._type !== other._type || //
            this._interpolationDegree !== other._interpolationDegree || //
            this._interpolationAlgorithm !== other._interpolationAlgorithm) {
                return false;
            }

            var derivativeTypes = this._derivativeTypes;
            var hasDerivatives = defined(derivativeTypes);
            var otherDerivativeTypes = other._derivativeTypes;
            var otherHasDerivatives = defined(otherDerivativeTypes);
            if (hasDerivatives !== otherHasDerivatives) {
                return false;
            }

            var i;
            var length;
            if (hasDerivatives) {
                length = derivativeTypes.length;
                if (length !== otherDerivativeTypes.length) {
                    return false;
                }

                for (i = 0; i < length; i++) {
                    if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
                        return false;
                    }
                }
            }

            var times = this._times;
            var otherTimes = other._times;
            length = times.length;

            if (length !== otherTimes.length) {
                return false;
            }

            for (i = 0; i < length; i++) {
                if (!JulianDate.equals(times[i], otherTimes[i])) {
                    return false;
                }
            }

            var values = this._values;
            var otherValues = other._values;
            for (i = 0; i < length; i++) {
                if (values[i] !== otherValues[i]) {
                    return false;
                }
            }

            return true;
        };

        //Exposed for testing.
        SampledProperty._mergeNewSamples = mergeNewSamples;

        return SampledProperty;
    }).call(this, $__require('55'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('26'), $__require('53'), $__require('2d'), $__require('54'));
});
/*global define*/
$__System.registerDynamic('4e', ['2c', '23', '25', '28', '30'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
        'use strict';

        /**
         * A 2D Cartesian point.
         * @alias Cartesian2
         * @constructor
         *
         * @param {Number} [x=0.0] The X component.
         * @param {Number} [y=0.0] The Y component.
         *
         * @see Cartesian3
         * @see Cartesian4
         * @see Packable
         */

        function Cartesian2(x, y) {
            /**
             * The X component.
             * @type {Number}
             * @default 0.0
             */
            this.x = defaultValue(x, 0.0);

            /**
             * The Y component.
             * @type {Number}
             * @default 0.0
             */
            this.y = defaultValue(y, 0.0);
        }

        /**
         * Creates a Cartesian2 instance from x and y coordinates.
         *
         * @param {Number} x The x coordinate.
         * @param {Number} y The y coordinate.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
         */
        Cartesian2.fromElements = function (x, y, result) {
            if (!defined(result)) {
                return new Cartesian2(x, y);
            }

            result.x = x;
            result.y = y;
            return result;
        };

        /**
         * Duplicates a Cartesian2 instance.
         *
         * @param {Cartesian2} cartesian The Cartesian to duplicate.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)
         */
        Cartesian2.clone = function (cartesian, result) {
            if (!defined(cartesian)) {
                return undefined;
            }
            if (!defined(result)) {
                return new Cartesian2(cartesian.x, cartesian.y);
            }

            result.x = cartesian.x;
            result.y = cartesian.y;
            return result;
        };

        /**
         * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
         * x and y properties of the Cartesian3 and drops z.
         * @function
         *
         * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
         */
        Cartesian2.fromCartesian3 = Cartesian2.clone;

        /**
         * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
         * x and y properties of the Cartesian4 and drops z and w.
         * @function
         *
         * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
         */
        Cartesian2.fromCartesian4 = Cartesian2.clone;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Cartesian2.packedLength = 2;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Cartesian2} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Cartesian2.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            array[startingIndex++] = value.x;
            array[startingIndex] = value.y;
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Cartesian2} [result] The object into which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
         */
        Cartesian2.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Cartesian2();
            }
            result.x = array[startingIndex++];
            result.y = array[startingIndex];
            return result;
        };

        /**
         * Flattens an array of Cartesian2s into and array of components.
         *
         * @param {Cartesian2[]} array The array of cartesians to pack.
         * @param {Number[]} result The array onto which to store the result.
         * @returns {Number[]} The packed array.
         */
        Cartesian2.packArray = function (array, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            var length = array.length;
            if (!defined(result)) {
                result = new Array(length * 2);
            } else {
                result.length = length * 2;
            }

            for (var i = 0; i < length; ++i) {
                Cartesian2.pack(array[i], result, i * 2);
            }
            return result;
        };

        /**
         * Unpacks an array of cartesian components into and array of Cartesian2s.
         *
         * @param {Number[]} array The array of components to unpack.
         * @param {Cartesian2[]} result The array onto which to store the result.
         * @returns {Cartesian2[]} The unpacked array.
         */
        Cartesian2.unpackArray = function (array, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            var length = array.length;
            if (!defined(result)) {
                result = new Array(length / 2);
            } else {
                result.length = length / 2;
            }

            for (var i = 0; i < length; i += 2) {
                var index = i / 2;
                result[index] = Cartesian2.unpack(array, i, result[index]);
            }
            return result;
        };

        /**
         * Creates a Cartesian2 from two consecutive elements in an array.
         * @function
         *
         * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.
         * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
         *
         * @example
         * // Create a Cartesian2 with (1.0, 2.0)
         * var v = [1.0, 2.0];
         * var p = Cesium.Cartesian2.fromArray(v);
         *
         * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
         * var v2 = [0.0, 0.0, 1.0, 2.0];
         * var p2 = Cesium.Cartesian2.fromArray(v2, 2);
         */
        Cartesian2.fromArray = Cartesian2.unpack;

        /**
         * Computes the value of the maximum component for the supplied Cartesian.
         *
         * @param {Cartesian2} cartesian The cartesian to use.
         * @returns {Number} The value of the maximum component.
         */
        Cartesian2.maximumComponent = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return Math.max(cartesian.x, cartesian.y);
        };

        /**
         * Computes the value of the minimum component for the supplied Cartesian.
         *
         * @param {Cartesian2} cartesian The cartesian to use.
         * @returns {Number} The value of the minimum component.
         */
        Cartesian2.minimumComponent = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return Math.min(cartesian.x, cartesian.y);
        };

        /**
         * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
         *
         * @param {Cartesian2} first A cartesian to compare.
         * @param {Cartesian2} second A cartesian to compare.
         * @param {Cartesian2} result The object into which to store the result.
         * @returns {Cartesian2} A cartesian with the minimum components.
         */
        Cartesian2.minimumByComponent = function (first, second, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required.');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');


            result.x = Math.min(first.x, second.x);
            result.y = Math.min(first.y, second.y);

            return result;
        };

        /**
         * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
         *
         * @param {Cartesian2} first A cartesian to compare.
         * @param {Cartesian2} second A cartesian to compare.
         * @param {Cartesian2} result The object into which to store the result.
         * @returns {Cartesian2} A cartesian with the maximum components.
         */
        Cartesian2.maximumByComponent = function (first, second, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required.');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            result.x = Math.max(first.x, second.x);
            result.y = Math.max(first.y, second.y);
            return result;
        };

        /**
         * Computes the provided Cartesian's squared magnitude.
         *
         * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.
         * @returns {Number} The squared magnitude.
         */
        Cartesian2.magnitudeSquared = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
        };

        /**
         * Computes the Cartesian's magnitude (length).
         *
         * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
         * @returns {Number} The magnitude.
         */
        Cartesian2.magnitude = function (cartesian) {
            return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
        };

        var distanceScratch = new Cartesian2();

        /**
         * Computes the distance between two points.
         *
         * @param {Cartesian2} left The first point to compute the distance from.
         * @param {Cartesian2} right The second point to compute the distance to.
         * @returns {Number} The distance between two points.
         *
         * @example
         * // Returns 1.0
         * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));
         */
        Cartesian2.distance = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left) || !defined(right)) {
                throw new DeveloperError('left and right are required.');
            }
            //>>includeEnd('debug');

            Cartesian2.subtract(left, right, distanceScratch);
            return Cartesian2.magnitude(distanceScratch);
        };

        /**
         * Computes the squared distance between two points.  Comparing squared distances
         * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
         *
         * @param {Cartesian2} left The first point to compute the distance from.
         * @param {Cartesian2} right The second point to compute the distance to.
         * @returns {Number} The distance between two points.
         *
         * @example
         * // Returns 4.0, not 2.0
         * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));
         */
        Cartesian2.distanceSquared = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left) || !defined(right)) {
                throw new DeveloperError('left and right are required.');
            }
            //>>includeEnd('debug');

            Cartesian2.subtract(left, right, distanceScratch);
            return Cartesian2.magnitudeSquared(distanceScratch);
        };

        /**
         * Computes the normalized form of the supplied Cartesian.
         *
         * @param {Cartesian2} cartesian The Cartesian to be normalized.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.normalize = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var magnitude = Cartesian2.magnitude(cartesian);

            result.x = cartesian.x / magnitude;
            result.y = cartesian.y / magnitude;
            return result;
        };

        /**
         * Computes the dot (scalar) product of two Cartesians.
         *
         * @param {Cartesian2} left The first Cartesian.
         * @param {Cartesian2} right The second Cartesian.
         * @returns {Number} The dot product.
         */
        Cartesian2.dot = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            //>>includeEnd('debug');

            return left.x * right.x + left.y * right.y;
        };

        /**
         * Computes the componentwise product of two Cartesians.
         *
         * @param {Cartesian2} left The first Cartesian.
         * @param {Cartesian2} right The second Cartesian.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.multiplyComponents = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x * right.x;
            result.y = left.y * right.y;
            return result;
        };

        /**
         * Computes the componentwise sum of two Cartesians.
         *
         * @param {Cartesian2} left The first Cartesian.
         * @param {Cartesian2} right The second Cartesian.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.add = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x + right.x;
            result.y = left.y + right.y;
            return result;
        };

        /**
         * Computes the componentwise difference of two Cartesians.
         *
         * @param {Cartesian2} left The first Cartesian.
         * @param {Cartesian2} right The second Cartesian.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.subtract = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x - right.x;
            result.y = left.y - right.y;
            return result;
        };

        /**
         * Multiplies the provided Cartesian componentwise by the provided scalar.
         *
         * @param {Cartesian2} cartesian The Cartesian to be scaled.
         * @param {Number} scalar The scalar to multiply with.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.multiplyByScalar = function (cartesian, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = cartesian.x * scalar;
            result.y = cartesian.y * scalar;
            return result;
        };

        /**
         * Divides the provided Cartesian componentwise by the provided scalar.
         *
         * @param {Cartesian2} cartesian The Cartesian to be divided.
         * @param {Number} scalar The scalar to divide by.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.divideByScalar = function (cartesian, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = cartesian.x / scalar;
            result.y = cartesian.y / scalar;
            return result;
        };

        /**
         * Negates the provided Cartesian.
         *
         * @param {Cartesian2} cartesian The Cartesian to be negated.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.negate = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = -cartesian.x;
            result.y = -cartesian.y;
            return result;
        };

        /**
         * Computes the absolute value of the provided Cartesian.
         *
         * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.abs = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = Math.abs(cartesian.x);
            result.y = Math.abs(cartesian.y);
            return result;
        };

        var lerpScratch = new Cartesian2();
        /**
         * Computes the linear interpolation or extrapolation at t using the provided cartesians.
         *
         * @param {Cartesian2} start The value corresponding to t at 0.0.
         * @param {Cartesian2} end The value corresponding to t at 1.0.
         * @param {Number} t The point along t at which to interpolate.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter.
         */
        Cartesian2.lerp = function (start, end, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start is required.');
            }
            if (!defined(end)) {
                throw new DeveloperError('end is required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            Cartesian2.multiplyByScalar(end, t, lerpScratch);
            result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
            return Cartesian2.add(lerpScratch, result, result);
        };

        var angleBetweenScratch = new Cartesian2();
        var angleBetweenScratch2 = new Cartesian2();
        /**
         * Returns the angle, in radians, between the provided Cartesians.
         *
         * @param {Cartesian2} left The first Cartesian.
         * @param {Cartesian2} right The second Cartesian.
         * @returns {Number} The angle between the Cartesians.
         */
        Cartesian2.angleBetween = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            //>>includeEnd('debug');

            Cartesian2.normalize(left, angleBetweenScratch);
            Cartesian2.normalize(right, angleBetweenScratch2);
            return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
        };

        var mostOrthogonalAxisScratch = new Cartesian2();
        /**
         * Returns the axis that is most orthogonal to the provided Cartesian.
         *
         * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.
         * @param {Cartesian2} result The object onto which to store the result.
         * @returns {Cartesian2} The most orthogonal axis.
         */
        Cartesian2.mostOrthogonalAxis = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
            Cartesian2.abs(f, f);

            if (f.x <= f.y) {
                result = Cartesian2.clone(Cartesian2.UNIT_X, result);
            } else {
                result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
            }

            return result;
        };

        /**
         * Compares the provided Cartesians componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartesian2} [left] The first Cartesian.
         * @param {Cartesian2} [right] The second Cartesian.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Cartesian2.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y;
        };

        /**
         * @private
         */
        Cartesian2.equalsArray = function (cartesian, array, offset) {
            return cartesian.x === array[offset] && cartesian.y === array[offset + 1];
        };

        /**
         * Compares the provided Cartesians componentwise and returns
         * <code>true</code> if they pass an absolute or relative tolerance test,
         * <code>false</code> otherwise.
         *
         * @param {Cartesian2} [left] The first Cartesian.
         * @param {Cartesian2} [right] The second Cartesian.
         * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
         * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartesian2.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
            return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon);
        };

        /**
         * An immutable Cartesian2 instance initialized to (0.0, 0.0).
         *
         * @type {Cartesian2}
         * @constant
         */
        Cartesian2.ZERO = freezeObject(new Cartesian2(0.0, 0.0));

        /**
         * An immutable Cartesian2 instance initialized to (1.0, 0.0).
         *
         * @type {Cartesian2}
         * @constant
         */
        Cartesian2.UNIT_X = freezeObject(new Cartesian2(1.0, 0.0));

        /**
         * An immutable Cartesian2 instance initialized to (0.0, 1.0).
         *
         * @type {Cartesian2}
         * @constant
         */
        Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0.0, 1.0));

        /**
         * Duplicates this Cartesian2 instance.
         *
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
         */
        Cartesian2.prototype.clone = function (result) {
            return Cartesian2.clone(this, result);
        };

        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartesian2} [right] The right hand side Cartesian.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        Cartesian2.prototype.equals = function (right) {
            return Cartesian2.equals(this, right);
        };

        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
         * <code>true</code> if they pass an absolute or relative tolerance test,
         * <code>false</code> otherwise.
         *
         * @param {Cartesian2} [right] The right hand side Cartesian.
         * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
         * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
         * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartesian2.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
            return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
        };

        /**
         * Creates a string representing this Cartesian in the format '(x, y)'.
         *
         * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.
         */
        Cartesian2.prototype.toString = function () {
            return '(' + this.x + ', ' + this.y + ')';
        };

        return Cartesian2;
    }).call(this, $__require('2c'), $__require('23'), $__require('25'), $__require('28'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('56', ['57', '55', '2c', '23', '58', '28', '2d', '59', '5a', '41', '5b', '5c'], false, function ($__require, $__exports, $__module) {
    return (function (when, binarySearch, defaultValue, defined, EarthOrientationParametersSample, freezeObject, JulianDate, LeapSecond, loadJson, RuntimeError, TimeConstants, TimeStandard) {
        'use strict';

        /**
         * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.
         * These Earth Orientation Parameters (EOP) are primarily used in the transformation from
         * the International Celestial Reference Frame (ICRF) to the International Terrestrial
         * Reference Frame (ITRF).
         *
         * @alias EarthOrientationParameters
         * @constructor
         *
         * @param {Object} [options] Object with the following properties:
         * @param {String} [options.url] The URL from which to obtain EOP data.  If neither this
         *                 parameter nor options.data is specified, all EOP values are assumed
         *                 to be 0.0.  If options.data is specified, this parameter is
         *                 ignored.
         * @param {Object} [options.data] The actual EOP data.  If neither this
         *                 parameter nor options.data is specified, all EOP values are assumed
         *                 to be 0.0.
         * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that
         *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}
         *                  should be added to {@link JulianDate.leapSeconds}.  False if
         *                  new leap seconds should be handled correctly in the context
         *                  of the EOP data but otherwise ignored.
         *
         * @example
         * // An example EOP data file, EOP.json:
         * {
         *   "columnNames" : ["dateIso8601","modifiedJulianDateUtc","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],
         *   "samples" : [
         *      "2011-07-01T00:00:00Z",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,
         *      "2011-07-02T00:00:00Z",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,
         *      "2011-07-03T00:00:00Z",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0
         *   ]
         * }
         *
         * @example
         * // Loading the EOP data
         * var eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });
         * Cesium.Transforms.earthOrientationParameters = eop;
         *
         * @private
         */

        function EarthOrientationParameters(options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);

            this._dates = undefined;
            this._samples = undefined;

            this._dateColumn = -1;
            this._xPoleWanderRadiansColumn = -1;
            this._yPoleWanderRadiansColumn = -1;
            this._ut1MinusUtcSecondsColumn = -1;
            this._xCelestialPoleOffsetRadiansColumn = -1;
            this._yCelestialPoleOffsetRadiansColumn = -1;
            this._taiMinusUtcSecondsColumn = -1;

            this._columnCount = 0;
            this._lastIndex = -1;

            this._downloadPromise = undefined;
            this._dataError = undefined;

            this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);

            if (defined(options.data)) {
                // Use supplied EOP data.
                onDataReady(this, options.data);
            } else if (defined(options.url)) {
                // Download EOP data.
                var that = this;
                this._downloadPromise = when(loadJson(options.url), function (eopData) {
                    onDataReady(that, eopData);
                }, function () {
                    that._dataError = 'An error occurred while retrieving the EOP data from the URL ' + options.url + '.';
                });
            } else {
                // Use all zeros for EOP data.
                onDataReady(this, {
                    'columnNames': ['dateIso8601', 'modifiedJulianDateUtc', 'xPoleWanderRadians', 'yPoleWanderRadians', 'ut1MinusUtcSeconds', 'lengthOfDayCorrectionSeconds', 'xCelestialPoleOffsetRadians', 'yCelestialPoleOffsetRadians', 'taiMinusUtcSeconds'],
                    'samples': []
                });
            }
        }

        /**
         * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.
         */
        EarthOrientationParameters.NONE = freezeObject({
            getPromiseToLoad: function () {
                return when();
            },
            compute: function (date, result) {
                if (!defined(result)) {
                    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
                } else {
                    result.xPoleWander = 0.0;
                    result.yPoleWander = 0.0;
                    result.xPoleOffset = 0.0;
                    result.yPoleOffset = 0.0;
                    result.ut1MinusUtc = 0.0;
                }
                return result;
            }
        });

        /**
         * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is
         * ready to use.
         *
         * @returns {Promise.<undefined>} The promise.
         *
         * @see when
         */
        EarthOrientationParameters.prototype.getPromiseToLoad = function () {
            return when(this._downloadPromise);
        };

        /**
         * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.
         * If the EOP data has not yet been download, this method returns undefined.
         *
         * @param {JulianDate} date The date for each to evaluate the EOP.
         * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.
         *        If this parameter is undefined, a new instance is created and returned.
         * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or
         *          undefined if the data necessary to evaluate EOP at the date has not yet been
         *          downloaded.
         *
         * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.
         *
         * @see EarthOrientationParameters#getPromiseToLoad
         */
        EarthOrientationParameters.prototype.compute = function (date, result) {
            // We cannot compute until the samples are available.
            if (!defined(this._samples)) {
                if (defined(this._dataError)) {
                    throw new RuntimeError(this._dataError);
                }

                return undefined;
            }

            if (!defined(result)) {
                result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);
            }

            if (this._samples.length === 0) {
                result.xPoleWander = 0.0;
                result.yPoleWander = 0.0;
                result.xPoleOffset = 0.0;
                result.yPoleOffset = 0.0;
                result.ut1MinusUtc = 0.0;
                return result;
            }

            var dates = this._dates;
            var lastIndex = this._lastIndex;

            var before = 0;
            var after = 0;
            if (defined(lastIndex)) {
                var previousIndexDate = dates[lastIndex];
                var nextIndexDate = dates[lastIndex + 1];
                var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);
                var isAfterLastSample = !defined(nextIndexDate);
                var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);

                if (isAfterPrevious && isBeforeNext) {
                    before = lastIndex;

                    if (!isAfterLastSample && nextIndexDate.equals(date)) {
                        ++before;
                    }
                    after = before + 1;

                    interpolate(this, dates, this._samples, date, before, after, result);
                    return result;
                }
            }

            var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);
            if (index >= 0) {
                // If the next entry is the same date, use the later entry.  This way, if two entries
                // describe the same moment, one before a leap second and the other after, then we will use
                // the post-leap second data.
                if (index < dates.length - 1 && dates[index + 1].equals(date)) {
                    ++index;
                }
                before = index;
                after = index;
            } else {
                after = ~index;
                before = after - 1;

                // Use the first entry if the date requested is before the beginning of the data.
                if (before < 0) {
                    before = 0;
                }
            }

            this._lastIndex = before;

            interpolate(this, dates, this._samples, date, before, after, result);
            return result;
        };

        function compareLeapSecondDates(leapSecond, dateToFind) {
            return JulianDate.compare(leapSecond.julianDate, dateToFind);
        }

        function onDataReady(eop, eopData) {
            if (!defined(eopData.columnNames)) {
                eop._dataError = 'Error in loaded EOP data: The columnNames property is required.';
                return;
            }

            if (!defined(eopData.samples)) {
                eop._dataError = 'Error in loaded EOP data: The samples property is required.';
                return;
            }

            var dateColumn = eopData.columnNames.indexOf('modifiedJulianDateUtc');
            var xPoleWanderRadiansColumn = eopData.columnNames.indexOf('xPoleWanderRadians');
            var yPoleWanderRadiansColumn = eopData.columnNames.indexOf('yPoleWanderRadians');
            var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf('ut1MinusUtcSeconds');
            var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('xCelestialPoleOffsetRadians');
            var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('yCelestialPoleOffsetRadians');
            var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf('taiMinusUtcSeconds');

            if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {
                eop._dataError = 'Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns';
                return;
            }

            var samples = eop._samples = eopData.samples;
            var dates = eop._dates = [];

            eop._dateColumn = dateColumn;
            eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
            eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
            eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
            eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
            eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
            eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;

            eop._columnCount = eopData.columnNames.length;
            eop._lastIndex = undefined;

            var lastTaiMinusUtc;

            var addNewLeapSeconds = eop._addNewLeapSeconds;

            // Convert the ISO8601 dates to JulianDates.
            for (var i = 0, len = samples.length; i < len; i += eop._columnCount) {
                var mjd = samples[i + dateColumn];
                var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
                var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;
                var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);
                dates.push(date);

                if (addNewLeapSeconds) {
                    if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {
                        // We crossed a leap second boundary, so add the leap second
                        // if it does not already exist.
                        var leapSeconds = JulianDate.leapSeconds;
                        var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);
                        if (leapSecondIndex < 0) {
                            var leapSecond = new LeapSecond(date, taiMinusUtc);
                            leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
                        }
                    }
                    lastTaiMinusUtc = taiMinusUtc;
                }
            }
        }

        function fillResultFromIndex(eop, samples, index, columnCount, result) {
            var start = index * columnCount;
            result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
            result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
            result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
            result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
            result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
        }

        function linearInterp(dx, y1, y2) {
            return y1 + dx * (y2 - y1);
        }

        function interpolate(eop, dates, samples, date, before, after, result) {
            var columnCount = eop._columnCount;

            // First check the bounds on the EOP data
            // If we are after the bounds of the data, return zeros.
            // The 'before' index should never be less than zero.
            if (after > dates.length - 1) {
                result.xPoleWander = 0;
                result.yPoleWander = 0;
                result.xPoleOffset = 0;
                result.yPoleOffset = 0;
                result.ut1MinusUtc = 0;
                return result;
            }

            var beforeDate = dates[before];
            var afterDate = dates[after];
            if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
                fillResultFromIndex(eop, samples, before, columnCount, result);
                return result;
            } else if (date.equals(afterDate)) {
                fillResultFromIndex(eop, samples, after, columnCount, result);
                return result;
            }

            var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);

            var startBefore = before * columnCount;
            var startAfter = after * columnCount;

            // Handle UT1 leap second edge case
            var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
            var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];

            var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
            if (offsetDifference > 0.5 || offsetDifference < -0.5) {
                // The absolute difference between the values is more than 0.5, so we may have
                // crossed a leap second.  Check if this is the case and, if so, adjust the
                // afterValue to account for the leap second.  This way, our interpolation will
                // produce reasonable results.
                var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];
                var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];
                if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
                    if (afterDate.equals(date)) {
                        // If we are at the end of the leap second interval, take the second value
                        // Otherwise, the interpolation below will yield the wrong side of the
                        // discontinuity
                        // At the end of the leap second, we need to start accounting for the jump
                        beforeUt1MinusUtc = afterUt1MinusUtc;
                    } else {
                        // Otherwise, remove the leap second so that the interpolation is correct
                        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
                    }
                }
            }

            result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);
            result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);
            result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);
            result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);
            result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);
            return result;
        }

        return EarthOrientationParameters;
    }).call(this, $__require('57'), $__require('55'), $__require('2c'), $__require('23'), $__require('58'), $__require('28'), $__require('2d'), $__require('59'), $__require('5a'), $__require('41'), $__require('5b'), $__require('5c'));
});
/*global define*/
$__System.registerDynamic('58', [], false, function ($__require, $__exports, $__module) {
  return (function () {
    'use strict';

    /**
     * A set of Earth Orientation Parameters (EOP) sampled at a time.
     *
     * @alias EarthOrientationParametersSample
     * @constructor
     *
     * @param {Number} xPoleWander The pole wander about the X axis, in radians.
     * @param {Number} yPoleWander The pole wander about the Y axis, in radians.
     * @param {Number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.
     * @param {Number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.
     * @param {Number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.
     *
     * @private
     */

    function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {
      /**
       * The pole wander about the X axis, in radians.
       * @type {Number}
       */
      this.xPoleWander = xPoleWander;

      /**
       * The pole wander about the Y axis, in radians.
       * @type {Number}
       */
      this.yPoleWander = yPoleWander;

      /**
       * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.
       * @type {Number}
       */
      this.xPoleOffset = xPoleOffset;

      /**
       * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.
       * @type {Number}
       */
      this.yPoleOffset = yPoleOffset;

      /**
       * The difference in time standards, UT1 - UTC, in seconds.
       * @type {Number}
       */
      this.ut1MinusUtc = ut1MinusUtc;
    }

    return EarthOrientationParametersSample;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('5d', ['5e', '2c', '23', '25'], false, function ($__require, $__exports, $__module) {
    return (function (Uri, defaultValue, defined, DeveloperError) {
        'use strict';

        /**
         * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.
         * @exports getAbsoluteUri
         *
         * @param {String} relative The relative Uri.
         * @param {String} [base] The base Uri.
         * @returns {String} The absolute Uri of the given relative Uri.
         *
         * @example
         * //absolute Uri will be "https://test.com/awesome.png";
         * var absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');
         */

        function getAbsoluteUri(relative, base) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(relative)) {
                throw new DeveloperError('relative uri is required.');
            }
            //>>includeEnd('debug');
            base = defaultValue(base, document.location.href);
            var baseUri = new Uri(base);
            var relativeUri = new Uri(relative);
            return relativeUri.resolve(baseUri).toString();
        }

        return getAbsoluteUri;
    }).call(this, $__require('5e'), $__require('2c'), $__require('23'), $__require('25'));
});
/**
 * @license
 *
 * Grauw URI utilities
 *
 * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js
 *
 * @author Laurens Holst (http://www.grauw.nl/)
 *
 *   Copyright 2012 Laurens Holst
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */
/*global define*/
$__System.registerDynamic('5e', [], false, function ($__require, $__exports, $__module) {
	return (function () {

		/**
   * Constructs a URI object.
   * @constructor
   * @class Implementation of URI parsing and base URI resolving algorithm in RFC 3986.
   * @param {string|URI} uri A string or URI object to create the object from.
   */
		function URI(uri) {
			if (uri instanceof URI) {
				// copy constructor
				this.scheme = uri.scheme;
				this.authority = uri.authority;
				this.path = uri.path;
				this.query = uri.query;
				this.fragment = uri.fragment;
			} else if (uri) {
				// uri is URI string or cast to string
				var c = parseRegex.exec(uri);
				this.scheme = c[1];
				this.authority = c[2];
				this.path = c[3];
				this.query = c[4];
				this.fragment = c[5];
			}
		}
		// Initial values on the prototype
		URI.prototype.scheme = null;
		URI.prototype.authority = null;
		URI.prototype.path = '';
		URI.prototype.query = null;
		URI.prototype.fragment = null;

		// Regular expression from RFC 3986 appendix B
		var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');

		/**
   * Returns the scheme part of the URI.
   * In "http://example.com:80/a/b?x#y" this is "http".
   */
		URI.prototype.getScheme = function () {
			return this.scheme;
		};

		/**
   * Returns the authority part of the URI.
   * In "http://example.com:80/a/b?x#y" this is "example.com:80".
   */
		URI.prototype.getAuthority = function () {
			return this.authority;
		};

		/**
   * Returns the path part of the URI.
   * In "http://example.com:80/a/b?x#y" this is "/a/b".
   * In "mailto:mike@example.com" this is "mike@example.com".
   */
		URI.prototype.getPath = function () {
			return this.path;
		};

		/**
   * Returns the query part of the URI.
   * In "http://example.com:80/a/b?x#y" this is "x".
   */
		URI.prototype.getQuery = function () {
			return this.query;
		};

		/**
   * Returns the fragment part of the URI.
   * In "http://example.com:80/a/b?x#y" this is "y".
   */
		URI.prototype.getFragment = function () {
			return this.fragment;
		};

		/**
   * Tests whether the URI is an absolute URI.
   * See RFC 3986 section 4.3.
   */
		URI.prototype.isAbsolute = function () {
			return !!this.scheme && !this.fragment;
		};

		///**
		//* Extensive validation of the URI against the ABNF in RFC 3986
		//*/
		//URI.prototype.validate

		/**
   * Tests whether the URI is a same-document reference.
   * See RFC 3986 section 4.4.
   *
   * To perform more thorough comparison, you can normalise the URI objects.
   */
		URI.prototype.isSameDocumentAs = function (uri) {
			return uri.scheme == this.scheme && uri.authority == this.authority && uri.path == this.path && uri.query == this.query;
		};

		/**
   * Simple String Comparison of two URIs.
   * See RFC 3986 section 6.2.1.
   *
   * To perform more thorough comparison, you can normalise the URI objects.
   */
		URI.prototype.equals = function (uri) {
			return this.isSameDocumentAs(uri) && uri.fragment == this.fragment;
		};

		/**
   * Normalizes the URI using syntax-based normalization.
   * This includes case normalization, percent-encoding normalization and path segment normalization.
   * XXX: Percent-encoding normalization does not escape characters that need to be escaped.
   *      (Although that would not be a valid URI in the first place. See validate().)
   * See RFC 3986 section 6.2.2.
   */
		URI.prototype.normalize = function () {
			this.removeDotSegments();
			if (this.scheme) this.scheme = this.scheme.toLowerCase();
			if (this.authority) this.authority = this.authority.replace(authorityRegex, replaceAuthority).replace(caseRegex, replaceCase);
			if (this.path) this.path = this.path.replace(caseRegex, replaceCase);
			if (this.query) this.query = this.query.replace(caseRegex, replaceCase);
			if (this.fragment) this.fragment = this.fragment.replace(caseRegex, replaceCase);
		};

		var caseRegex = /%[0-9a-z]{2}/gi;
		var percentRegex = /[a-zA-Z0-9\-\._~]/;
		var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;

		function replaceCase(str) {
			var dec = unescape(str);
			return percentRegex.test(dec) ? dec : str.toUpperCase();
		}

		function replaceAuthority(str, p1, p2, p3) {
			return (p1 || '') + p2.toLowerCase() + (p3 || '');
		}

		/**
   * Resolve a relative URI (this) against a base URI.
   * The base URI must be an absolute URI.
   * See RFC 3986 section 5.2
   */
		URI.prototype.resolve = function (baseURI) {
			var uri = new URI();
			if (this.scheme) {
				uri.scheme = this.scheme;
				uri.authority = this.authority;
				uri.path = this.path;
				uri.query = this.query;
			} else {
				uri.scheme = baseURI.scheme;
				if (this.authority) {
					uri.authority = this.authority;
					uri.path = this.path;
					uri.query = this.query;
				} else {
					uri.authority = baseURI.authority;
					if (this.path == '') {
						uri.path = baseURI.path;
						uri.query = this.query || baseURI.query;
					} else {
						if (this.path.charAt(0) == '/') {
							uri.path = this.path;
							uri.removeDotSegments();
						} else {
							if (baseURI.authority && baseURI.path == '') {
								uri.path = '/' + this.path;
							} else {
								uri.path = baseURI.path.substring(0, baseURI.path.lastIndexOf('/') + 1) + this.path;
							}
							uri.removeDotSegments();
						}
						uri.query = this.query;
					}
				}
			}
			uri.fragment = this.fragment;
			return uri;
		};

		/**
   * Remove dot segments from path.
   * See RFC 3986 section 5.2.4
   * @private
   */
		URI.prototype.removeDotSegments = function () {
			var input = this.path.split('/'),
			    output = [],
			    segment,
			    absPath = input[0] == '';
			if (absPath) input.shift();
			var sFirst = input[0] == '' ? input.shift() : null;
			while (input.length) {
				segment = input.shift();
				if (segment == '..') {
					output.pop();
				} else if (segment != '.') {
					output.push(segment);
				}
			}
			if (segment == '.' || segment == '..') output.push('');
			if (absPath) output.unshift('');
			this.path = output.join('/');
		};

		// We don't like this function because it builds up a cache that is never cleared.
		//	/**
		//	 * Resolves a relative URI against an absolute base URI.
		//	 * Convenience method.
		//	 * @param {String} uri the relative URI to resolve
		//	 * @param {String} baseURI the base URI (must be absolute) to resolve against
		//	 */
		//	URI.resolve = function(sURI, sBaseURI) {
		//		var uri = cache[sURI] || (cache[sURI] = new URI(sURI));
		//		var baseURI = cache[sBaseURI] || (cache[sBaseURI] = new URI(sBaseURI));
		//		return uri.resolve(baseURI).toString();
		//	};

		//	var cache = {};

		/**
   * Serialises the URI to a string.
   */
		URI.prototype.toString = function () {
			var result = '';
			if (this.scheme) result += this.scheme + ':';
			if (this.authority) result += '//' + this.authority;
			result += this.path;
			if (this.query) result += '?' + this.query;
			if (this.fragment) result += '#' + this.fragment;
			return result;
		};

		return URI;
	}).call(this);
});
/*global define*/
$__System.registerDynamic('5f', ['5e', '2c', '23', '25'], false, function ($__require, $__exports, $__module) {
    return (function (Uri, defaultValue, defined, DeveloperError) {
        'use strict';

        /**
         * Function for joining URLs in a manner that is aware of query strings and fragments.
         * This is useful when the base URL has a query string that needs to be maintained
         * (e.g. a presigned base URL).
         * @param {String|Uri} first The base URL.
         * @param {String|Uri} second The URL path to join to the base URL.  If this URL is absolute, it is returned unmodified.
         * @param {Boolean} [appendSlash=true] The boolean determining whether there should be a forward slash between first and second.
         * @private
         */

        function joinUrls(first, second, appendSlash) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required');
            }
            //>>includeEnd('debug');

            appendSlash = defaultValue(appendSlash, true);

            if (!(first instanceof Uri)) {
                first = new Uri(first);
            }

            if (!(second instanceof Uri)) {
                second = new Uri(second);
            }

            // Uri.isAbsolute returns false for a URL like '//foo.com'.  So if we have an authority but
            // not a scheme, add a scheme matching the page's scheme.
            if (defined(second.authority) && !defined(second.scheme)) {
                if (typeof document !== 'undefined' && defined(document.location) && defined(document.location.href)) {
                    second.scheme = new Uri(document.location.href).scheme;
                } else {
                    // Not in a browser?  Use the first URL's scheme instead.
                    second.scheme = first.scheme;
                }
            }

            // If the second URL is absolute, use it for the scheme, authority, and path.
            var baseUri = first;
            if (second.isAbsolute()) {
                baseUri = second;
            }

            var url = '';
            if (defined(baseUri.scheme)) {
                url += baseUri.scheme + ':';
            }
            if (defined(baseUri.authority)) {
                url += '//' + baseUri.authority;

                if (baseUri.path !== '' && baseUri.path !== '/') {
                    url = url.replace(/\/?$/, '/');
                    baseUri.path = baseUri.path.replace(/^\/?/g, '');
                }
            }

            // Combine the paths (only if second is relative).
            if (baseUri === first) {
                if (appendSlash) {
                    url += first.path.replace(/\/?$/, '/') + second.path.replace(/^\/?/g, '');
                } else {
                    url += first.path + second.path;
                }
            } else {
                url += second.path;
            }

            // Combine the queries and fragments.
            var hasFirstQuery = defined(first.query);
            var hasSecondQuery = defined(second.query);
            if (hasFirstQuery && hasSecondQuery) {
                url += '?' + first.query + '&' + second.query;
            } else if (hasFirstQuery && !hasSecondQuery) {
                url += '?' + first.query;
            } else if (!hasFirstQuery && hasSecondQuery) {
                url += '?' + second.query;
            }

            var hasSecondFragment = defined(second.fragment);
            if (defined(first.fragment) && !hasSecondFragment) {
                url += '#' + first.fragment;
            } else if (hasSecondFragment) {
                url += '#' + second.fragment;
            }

            return url;
        }

        return joinUrls;
    }).call(this, $__require('5e'), $__require('2c'), $__require('23'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('60', ['5e', '23', '25', '5d', '5f'], false, function ($__require, $__exports, $__module) {
    return (function (Uri, defined, DeveloperError, getAbsoluteUri, joinUrls, _dereq_) {
        'use strict';
        /*global CESIUM_BASE_URL*/

        var cesiumScriptRegex = /((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i;
        function getBaseUrlFromCesiumScript() {
            var scripts = document.getElementsByTagName('script');
            for (var i = 0, len = scripts.length; i < len; ++i) {
                var src = scripts[i].getAttribute('src');
                var result = cesiumScriptRegex.exec(src);
                if (result !== null) {
                    return result[1];
                }
            }
            return undefined;
        }

        var baseUrl;
        function getCesiumBaseUrl() {
            if (defined(baseUrl)) {
                return baseUrl;
            }

            var baseUrlString;
            if (typeof CESIUM_BASE_URL !== 'undefined') {
                baseUrlString = CESIUM_BASE_URL;
            } else {
                baseUrlString = getBaseUrlFromCesiumScript();
            }

            if (!defined(baseUrlString)) {
                throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');
            }

            baseUrl = new Uri(getAbsoluteUri(baseUrlString));

            return baseUrl;
        }

        function buildModuleUrlFromRequireToUrl(moduleID) {
            //moduleID will be non-relative, so require it relative to this module, in Core.
            return _dereq_.toUrl('../' + moduleID);
        }

        function buildModuleUrlFromBaseUrl(moduleID) {
            return joinUrls(getCesiumBaseUrl(), moduleID);
        }

        var implementation;
        var a;

        /**
         * Given a non-relative moduleID, returns an absolute URL to the file represented by that module ID,
         * using, in order of preference, require.toUrl, the value of a global CESIUM_BASE_URL, or
         * the base URL of the Cesium.js script.
         *
         * @private
         */
        function buildModuleUrl(moduleID) {
            if (!defined(implementation)) {
                //select implementation
                if (defined(_dereq_.toUrl)) {
                    implementation = buildModuleUrlFromRequireToUrl;
                } else {
                    implementation = buildModuleUrlFromBaseUrl;
                }
            }

            if (!defined(a)) {
                a = document.createElement('a');
            }

            var url = implementation(moduleID);

            a.href = url;
            a.href = a.href; // IE only absolutizes href on get, not set

            return a.href;
        }

        // exposed for testing
        buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;

        /**
         * Sets the base URL for resolving modules.
         * @param {String} value The new base URL.
         */
        buildModuleUrl.setBaseUrl = function (value) {
            baseUrl = new Uri(value).resolve(new Uri(document.location.href));
        };

        return buildModuleUrl;
    }).call(this, $__require('5e'), $__require('23'), $__require('25'), $__require('5d'), $__require('5f'), $__require);
});
/*global define*/
$__System.registerDynamic('61', ['2c'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue) {
        'use strict';

        /**
         * Clones an object, returning a new object containing the same properties.
         *
         * @exports clone
         *
         * @param {Object} object The object to clone.
         * @param {Boolean} [deep=false] If true, all properties will be deep cloned recursively.
         * @returns {Object} The cloned object.
         */

        function clone(object, deep) {
            if (object === null || typeof object !== 'object') {
                return object;
            }

            deep = defaultValue(deep, false);

            var result = new object.constructor();
            for (var propertyName in object) {
                if (object.hasOwnProperty(propertyName)) {
                    var value = object[propertyName];
                    if (deep) {
                        value = clone(value, deep);
                    }
                    result[propertyName] = value;
                }
            }

            return result;
        }

        return clone;
    }).call(this, $__require('2c'));
});
/**
  @license
  when.js - https://github.com/cujojs/when

  MIT License (c) copyright B Cavalier & J Hann

 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.7.1
 */

(function (define) {
	'use strict';

	define(function () {
		var reduceArray, slice, undef;

		//
		// Public API
		//

		when.defer = defer; // Create a deferred
		when.resolve = resolve; // Create a resolved promise
		when.reject = reject; // Create a rejected promise

		when.join = join; // Join 2 or more promises

		when.all = all; // Resolve a list of promises
		when.map = map; // Array.map() for promises
		when.reduce = reduce; // Array.reduce() for promises

		when.any = any; // One-winner race
		when.some = some; // Multi-winner race

		when.chain = chain; // Make a promise trigger another resolver

		when.isPromise = isPromise; // Determine if a thing is a promise

		/**
   * Register an observer for a promise or immediate value.
   *
   * @param {*} promiseOrValue
   * @param {function?} [onFulfilled] callback to be called when promiseOrValue is
   *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
   *   will be invoked immediately.
   * @param {function?} [onRejected] callback to be called when promiseOrValue is
   *   rejected.
   * @param {function?} [onProgress] callback to be called when progress updates
   *   are issued for promiseOrValue.
   * @returns {Promise} a new {@link Promise} that will complete with the return
   *   value of callback or errback or the completion value of promiseOrValue if
   *   callback and/or errback is not supplied.
   */
		function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
			// Get a trusted promise for the input promiseOrValue, and then
			// register promise handlers
			return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
		}

		/**
   * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
   * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}
   * whose value is promiseOrValue if promiseOrValue is an immediate value.
   *
   * @param {*} promiseOrValue
   * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
   *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
   *   whose resolution value is:
   *   * the resolution value of promiseOrValue if it's a foreign promise, or
   *   * promiseOrValue if it's a value
   */
		function resolve(promiseOrValue) {
			var promise, deferred;

			if (promiseOrValue instanceof Promise) {
				// It's a when.js promise, so we trust it
				promise = promiseOrValue;
			} else {
				// It's not a when.js promise. See if it's a foreign promise or a value.
				if (isPromise(promiseOrValue)) {
					// It's a thenable, but we don't know where it came from, so don't trust
					// its implementation entirely.  Introduce a trusted middleman when.js promise
					deferred = defer();

					// IMPORTANT: This is the only place when.js should ever call .then() on an
					// untrusted promise. Don't expose the return value to the untrusted promise
					promiseOrValue.then(function (value) {
						deferred.resolve(value);
					}, function (reason) {
						deferred.reject(reason);
					}, function (update) {
						deferred.progress(update);
					});

					promise = deferred.promise;
				} else {
					// It's a value, not a promise.  Create a resolved promise for it.
					promise = fulfilled(promiseOrValue);
				}
			}

			return promise;
		}

		/**
   * Returns a rejected promise for the supplied promiseOrValue.  The returned
   * promise will be rejected with:
   * - promiseOrValue, if it is a value, or
   * - if promiseOrValue is a promise
   *   - promiseOrValue's value after it is fulfilled
   *   - promiseOrValue's reason after it is rejected
   * @param {*} promiseOrValue the rejected value of the returned {@link Promise}
   * @returns {Promise} rejected {@link Promise}
   */
		function reject(promiseOrValue) {
			return when(promiseOrValue, rejected);
		}

		/**
   * Trusted Promise constructor.  A Promise created from this constructor is
   * a trusted when.js promise.  Any other duck-typed promise is considered
   * untrusted.
   * @constructor
   * @name Promise
   */
		function Promise(then) {
			this.then = then;
		}

		Promise.prototype = {
			/**
    * Register a callback that will be called when a promise is
    * fulfilled or rejected.  Optionally also register a progress handler.
    * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)
    * @param {function?} [onFulfilledOrRejected]
    * @param {function?} [onProgress]
    * @returns {Promise}
    */
			always: function (onFulfilledOrRejected, onProgress) {
				return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
			},

			/**
    * Register a rejection handler.  Shortcut for .then(undefined, onRejected)
    * @param {function?} onRejected
    * @returns {Promise}
    */
			otherwise: function (onRejected) {
				return this.then(undef, onRejected);
			},

			/**
    * Shortcut for .then(function() { return value; })
    * @param  {*} value
    * @returns {Promise} a promise that:
    *  - is fulfilled if value is not a promise, or
    *  - if value is a promise, will fulfill with its value, or reject
    *    with its reason.
    */
			yield: function (value) {
				return this.then(function () {
					return value;
				});
			},

			/**
    * Assumes that this promise will fulfill with an array, and arranges
    * for the onFulfilled to be called with the array as its argument list
    * i.e. onFulfilled.spread(undefined, array).
    * @param {function} onFulfilled function to receive spread arguments
    * @returns {Promise}
    */
			spread: function (onFulfilled) {
				return this.then(function (array) {
					// array may contain promises, so resolve its contents.
					return all(array, function (array) {
						return onFulfilled.apply(undef, array);
					});
				});
			}
		};

		/**
   * Create an already-resolved promise for the supplied value
   * @private
   *
   * @param {*} value
   * @returns {Promise} fulfilled promise
   */
		function fulfilled(value) {
			var p = new Promise(function (onFulfilled) {
				// TODO: Promises/A+ check typeof onFulfilled
				try {
					return resolve(onFulfilled ? onFulfilled(value) : value);
				} catch (e) {
					return rejected(e);
				}
			});

			return p;
		}

		/**
   * Create an already-rejected {@link Promise} with the supplied
   * rejection reason.
   * @private
   *
   * @param {*} reason
   * @returns {Promise} rejected promise
   */
		function rejected(reason) {
			var p = new Promise(function (_, onRejected) {
				// TODO: Promises/A+ check typeof onRejected
				try {
					return onRejected ? resolve(onRejected(reason)) : rejected(reason);
				} catch (e) {
					return rejected(e);
				}
			});

			return p;
		}

		/**
   * Creates a new, Deferred with fully isolated resolver and promise parts,
   * either or both of which may be given out safely to consumers.
   * The Deferred itself has the full API: resolve, reject, progress, and
   * then. The resolver has resolve, reject, and progress.  The promise
   * only has then.
   *
   * @returns {Deferred}
   */
		function defer() {
			var deferred, promise, handlers, progressHandlers, _then, _progress, _resolve;

			/**
    * The promise for the new deferred
    * @type {Promise}
    */
			promise = new Promise(then);

			/**
    * The full Deferred object, with {@link Promise} and {@link Resolver} parts
    * @class Deferred
    * @name Deferred
    */
			deferred = {
				then: then, // DEPRECATED: use deferred.promise.then
				resolve: promiseResolve,
				reject: promiseReject,
				// TODO: Consider renaming progress() to notify()
				progress: promiseProgress,

				promise: promise,

				resolver: {
					resolve: promiseResolve,
					reject: promiseReject,
					progress: promiseProgress
				}
			};

			handlers = [];
			progressHandlers = [];

			/**
    * Pre-resolution then() that adds the supplied callback, errback, and progback
    * functions to the registered listeners
    * @private
    *
    * @param {function?} [onFulfilled] resolution handler
    * @param {function?} [onRejected] rejection handler
    * @param {function?} [onProgress] progress handler
    */
			_then = function (onFulfilled, onRejected, onProgress) {
				// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
				var deferred, progressHandler;

				deferred = defer();

				progressHandler = typeof onProgress === 'function' ? function (update) {
					try {
						// Allow progress handler to transform progress event
						deferred.progress(onProgress(update));
					} catch (e) {
						// Use caught value as progress
						deferred.progress(e);
					}
				} : function (update) {
					deferred.progress(update);
				};

				handlers.push(function (promise) {
					promise.then(onFulfilled, onRejected).then(deferred.resolve, deferred.reject, progressHandler);
				});

				progressHandlers.push(progressHandler);

				return deferred.promise;
			};

			/**
    * Issue a progress event, notifying all progress listeners
    * @private
    * @param {*} update progress event payload to pass to all listeners
    */
			_progress = function (update) {
				processQueue(progressHandlers, update);
				return update;
			};

			/**
    * Transition from pre-resolution state to post-resolution state, notifying
    * all listeners of the resolution or rejection
    * @private
    * @param {*} value the value of this deferred
    */
			_resolve = function (value) {
				value = resolve(value);

				// Replace _then with one that directly notifies with the result.
				_then = value.then;
				// Replace _resolve so that this Deferred can only be resolved once
				_resolve = resolve;
				// Make _progress a noop, to disallow progress for the resolved promise.
				_progress = noop;

				// Notify handlers
				processQueue(handlers, value);

				// Free progressHandlers array since we'll never issue progress events
				progressHandlers = handlers = undef;

				return value;
			};

			return deferred;

			/**
    * Wrapper to allow _then to be replaced safely
    * @param {function?} [onFulfilled] resolution handler
    * @param {function?} [onRejected] rejection handler
    * @param {function?} [onProgress] progress handler
    * @returns {Promise} new promise
    */
			function then(onFulfilled, onRejected, onProgress) {
				// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
				return _then(onFulfilled, onRejected, onProgress);
			}

			/**
    * Wrapper to allow _resolve to be replaced
    */
			function promiseResolve(val) {
				return _resolve(val);
			}

			/**
    * Wrapper to allow _reject to be replaced
    */
			function promiseReject(err) {
				return _resolve(rejected(err));
			}

			/**
    * Wrapper to allow _progress to be replaced
    */
			function promiseProgress(update) {
				return _progress(update);
			}
		}

		/**
   * Determines if promiseOrValue is a promise or not.  Uses the feature
   * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
   * promiseOrValue is a promise.
   *
   * @param {*} promiseOrValue anything
   * @returns {boolean} true if promiseOrValue is a {@link Promise}
   */
		function isPromise(promiseOrValue) {
			return promiseOrValue && typeof promiseOrValue.then === 'function';
		}

		/**
   * Initiates a competitive race, returning a promise that will resolve when
   * howMany of the supplied promisesOrValues have resolved, or will reject when
   * it becomes impossible for howMany to resolve, for example, when
   * (promisesOrValues.length - howMany) + 1 input promises reject.
   *
   * @param {Array} promisesOrValues array of anything, may contain a mix
   *      of promises and values
   * @param howMany {number} number of promisesOrValues to resolve
   * @param {function?} [onFulfilled] resolution handler
   * @param {function?} [onRejected] rejection handler
   * @param {function?} [onProgress] progress handler
   * @returns {Promise} promise that will resolve to an array of howMany values that
   * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1
   * rejection reasons.
   */
		function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {

			checkCallbacks(2, arguments);

			return when(promisesOrValues, function (promisesOrValues) {

				var toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;

				len = promisesOrValues.length >>> 0;

				toResolve = Math.max(0, Math.min(howMany, len));
				values = [];

				toReject = len - toResolve + 1;
				reasons = [];

				deferred = defer();

				// No items in the input, resolve immediately
				if (!toResolve) {
					deferred.resolve(values);
				} else {
					progress = deferred.progress;

					rejectOne = function (reason) {
						reasons.push(reason);
						if (! --toReject) {
							fulfillOne = rejectOne = noop;
							deferred.reject(reasons);
						}
					};

					fulfillOne = function (val) {
						// This orders the values based on promise resolution order
						// Another strategy would be to use the original position of
						// the corresponding promise.
						values.push(val);

						if (! --toResolve) {
							fulfillOne = rejectOne = noop;
							deferred.resolve(values);
						}
					};

					for (i = 0; i < len; ++i) {
						if (i in promisesOrValues) {
							when(promisesOrValues[i], fulfiller, rejecter, progress);
						}
					}
				}

				return deferred.then(onFulfilled, onRejected, onProgress);

				function rejecter(reason) {
					rejectOne(reason);
				}

				function fulfiller(val) {
					fulfillOne(val);
				}
			});
		}

		/**
   * Initiates a competitive race, returning a promise that will resolve when
   * any one of the supplied promisesOrValues has resolved or will reject when
   * *all* promisesOrValues have rejected.
   *
   * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
   *      of {@link Promise}s and values
   * @param {function?} [onFulfilled] resolution handler
   * @param {function?} [onRejected] rejection handler
   * @param {function?} [onProgress] progress handler
   * @returns {Promise} promise that will resolve to the value that resolved first, or
   * will reject with an array of all rejected inputs.
   */
		function any(promisesOrValues, onFulfilled, onRejected, onProgress) {

			function unwrapSingleResult(val) {
				return onFulfilled ? onFulfilled(val[0]) : val[0];
			}

			return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
		}

		/**
   * Return a promise that will resolve only once all the supplied promisesOrValues
   * have resolved. The resolution value of the returned promise will be an array
   * containing the resolution values of each of the promisesOrValues.
   * @memberOf when
   *
   * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
   *      of {@link Promise}s and values
   * @param {function?} [onFulfilled] resolution handler
   * @param {function?} [onRejected] rejection handler
   * @param {function?} [onProgress] progress handler
   * @returns {Promise}
   */
		function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
			checkCallbacks(1, arguments);
			return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
		}

		/**
   * Joins multiple promises into a single returned promise.
   * @returns {Promise} a promise that will fulfill when *all* the input promises
   * have fulfilled, or will reject when *any one* of the input promises rejects.
   */
		function join() /* ...promises */{
			return map(arguments, identity);
		}

		/**
   * Traditional map function, similar to `Array.prototype.map()`, but allows
   * input to contain {@link Promise}s and/or values, and mapFunc may return
   * either a value or a {@link Promise}
   *
   * @param {Array|Promise} promise array of anything, may contain a mix
   *      of {@link Promise}s and values
   * @param {function} mapFunc mapping function mapFunc(value) which may return
   *      either a {@link Promise} or value
   * @returns {Promise} a {@link Promise} that will resolve to an array containing
   *      the mapped output values.
   */
		function map(promise, mapFunc) {
			return when(promise, function (array) {
				var results, len, toResolve, resolve, i, d;

				// Since we know the resulting length, we can preallocate the results
				// array to avoid array expansions.
				toResolve = len = array.length >>> 0;
				results = [];
				d = defer();

				if (!toResolve) {
					d.resolve(results);
				} else {

					resolve = function resolveOne(item, i) {
						when(item, mapFunc).then(function (mapped) {
							results[i] = mapped;

							if (! --toResolve) {
								d.resolve(results);
							}
						}, d.reject);
					};

					// Since mapFunc may be async, get all invocations of it into flight
					for (i = 0; i < len; i++) {
						if (i in array) {
							resolve(array[i], i);
						} else {
							--toResolve;
						}
					}
				}

				return d.promise;
			});
		}

		/**
   * Traditional reduce function, similar to `Array.prototype.reduce()`, but
   * input may contain promises and/or values, and reduceFunc
   * may return either a value or a promise, *and* initialValue may
   * be a promise for the starting value.
   *
   * @param {Array|Promise} promise array or promise for an array of anything,
   *      may contain a mix of promises and values.
   * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),
   *      where total is the total number of items being reduced, and will be the same
   *      in each call to reduceFunc.
   * @returns {Promise} that will resolve to the final reduced value
   */
		function reduce(promise, reduceFunc /*, initialValue */) {
			var args = slice.call(arguments, 1);

			return when(promise, function (array) {
				var total;

				total = array.length;

				// Wrap the supplied reduceFunc with one that handles promises and then
				// delegates to the supplied.
				args[0] = function (current, val, i) {
					return when(current, function (c) {
						return when(val, function (value) {
							return reduceFunc(c, value, i, total);
						});
					});
				};

				return reduceArray.apply(array, args);
			});
		}

		/**
   * Ensure that resolution of promiseOrValue will trigger resolver with the
   * value or reason of promiseOrValue, or instead with resolveValue if it is provided.
   *
   * @param promiseOrValue
   * @param {Object} resolver
   * @param {function} resolver.resolve
   * @param {function} resolver.reject
   * @param {*} [resolveValue]
   * @returns {Promise}
   */
		function chain(promiseOrValue, resolver, resolveValue) {
			var useResolveValue = arguments.length > 2;

			return when(promiseOrValue, function (val) {
				val = useResolveValue ? resolveValue : val;
				resolver.resolve(val);
				return val;
			}, function (reason) {
				resolver.reject(reason);
				return rejected(reason);
			}, resolver.progress);
		}

		//
		// Utility functions
		//

		/**
   * Apply all functions in queue to value
   * @param {Array} queue array of functions to execute
   * @param {*} value argument passed to each function
   */
		function processQueue(queue, value) {
			var handler,
			    i = 0;

			while (handler = queue[i++]) {
				handler(value);
			}
		}

		/**
   * Helper that checks arrayOfCallbacks to ensure that each element is either
   * a function, or null or undefined.
   * @private
   * @param {number} start index at which to start checking items in arrayOfCallbacks
   * @param {Array} arrayOfCallbacks array to check
   * @throws {Error} if any element of arrayOfCallbacks is something other than
   * a functions, null, or undefined.
   */
		function checkCallbacks(start, arrayOfCallbacks) {
			// TODO: Promises/A+ update type checking and docs
			var arg,
			    i = arrayOfCallbacks.length;

			while (i > start) {
				arg = arrayOfCallbacks[--i];

				if (arg != null && typeof arg != 'function') {
					throw new Error('arg ' + i + ' must be a function');
				}
			}
		}

		/**
   * No-Op function used in method replacement
   * @private
   */
		function noop() {}

		slice = [].slice;

		// ES5 reduce implementation if native not available
		// See: http://es5.github.com/#x15.4.4.21 as there are many
		// specifics and edge cases.
		reduceArray = [].reduce || function (reduceFunc /*, initialValue */) {
			/*jshint maxcomplexity: 7*/

			// ES5 dictates that reduce.length === 1

			// This implementation deviates from ES5 spec in the following ways:
			// 1. It does not check if reduceFunc is a Callable

			var arr, args, reduced, len, i;

			i = 0;
			// This generates a jshint warning, despite being valid
			// "Missing 'new' prefix when invoking a constructor."
			// See https://github.com/jshint/jshint/issues/392
			arr = Object(this);
			len = arr.length >>> 0;
			args = arguments;

			// If no initialValue, use first item of array (we know length !== 0 here)
			// and adjust i to start at second item
			if (args.length <= 1) {
				// Skip to the first real element in the array
				for (;;) {
					if (i in arr) {
						reduced = arr[i++];
						break;
					}

					// If we reached the end of the array without finding any real
					// elements, it's a TypeError
					if (++i >= len) {
						throw new TypeError();
					}
				}
			} else {
				// If initialValue provided, use it
				reduced = args[1];
			}

			// Do the actual reduce
			for (; i < len; ++i) {
				// Skip holes
				if (i in arr) {
					reduced = reduceFunc(reduced, arr[i], i, arr);
				}
			}

			return reduced;
		};

		function identity(x) {
			return x;
		}

		return when;
	});
})('function' == 'function' && true ? define : function (factory) {
	typeof exports === 'object' ? module.exports = factory() : this.when = factory();
}
// Boilerplate for AMD, Node, and browser global
);
/*global define*/
$__System.registerDynamic('62', [], false, function ($__require, $__exports, $__module) {
  return (function () {
    'use strict';

    /**
     * Parses the result of XMLHttpRequest's getAllResponseHeaders() method into
     * a dictionary.
     *
     * @exports parseResponseHeaders
     *
     * @param {String} headerString The header string returned by getAllResponseHeaders().  The format is
     *                 described here: http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
     * @returns {Object} A dictionary of key/value pairs, where each key is the name of a header and the corresponding value
     *                   is that header's value.
     * 
     * @private
     */

    function parseResponseHeaders(headerString) {
      var headers = {};

      if (!headerString) {
        return headers;
      }

      var headerPairs = headerString.split('\u000d\u000a');

      for (var i = 0; i < headerPairs.length; ++i) {
        var headerPair = headerPairs[i];
        // Can't use split() here because it does the wrong thing
        // if the header value has the string ": " in it.
        var index = headerPair.indexOf('\u003a\u0020');
        if (index > 0) {
          var key = headerPair.substring(0, index);
          var val = headerPair.substring(index + 2);
          headers[key] = val;
        }
      }

      return headers;
    }

    return parseResponseHeaders;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('63', ['23', '62'], false, function ($__require, $__exports, $__module) {
    return (function (defined, parseResponseHeaders) {
        'use strict';

        /**
         * An event that is raised when a request encounters an error.
         *
         * @constructor
         * @alias RequestErrorEvent
         *
         * @param {Number} [statusCode] The HTTP error status code, such as 404.
         * @param {Object} [response] The response included along with the error.
         * @param {String|Object} [responseHeaders] The response headers, represented either as an object literal or as a
         *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
         */

        function RequestErrorEvent(statusCode, response, responseHeaders) {
            /**
             * The HTTP error status code, such as 404.  If the error does not have a particular
             * HTTP code, this property will be undefined.
             *
             * @type {Number}
             */
            this.statusCode = statusCode;

            /**
             * The response included along with the error.  If the error does not include a response,
             * this property will be undefined.
             *
             * @type {Object}
             */
            this.response = response;

            /**
             * The headers included in the response, represented as an object literal of key/value pairs.
             * If the error does not include any headers, this property will be undefined.
             *
             * @type {Object}
             */
            this.responseHeaders = responseHeaders;

            if (typeof this.responseHeaders === 'string') {
                this.responseHeaders = parseResponseHeaders(this.responseHeaders);
            }
        }

        /**
         * Creates a string representing this RequestErrorEvent.
         * @memberof RequestErrorEvent
         *
         * @returns {String} A string representing the provided RequestErrorEvent.
         */
        RequestErrorEvent.prototype.toString = function () {
            var str = 'Request has failed.';
            if (defined(this.statusCode)) {
                str += ' Status Code: ' + this.statusCode;
            }
            return str;
        };

        return RequestErrorEvent;
    }).call(this, $__require('23'), $__require('62'));
});
/*global define*/
$__System.registerDynamic('64', ['57', '2c', '23', '25', '63', '41'], false, function ($__require, $__exports, $__module) {
    return (function (when, defaultValue, defined, DeveloperError, RequestErrorEvent, RuntimeError) {
        'use strict';

        /**
         * Asynchronously loads the given URL.  Returns a promise that will resolve to
         * the result once loaded, or reject if the URL failed to load.  The data is loaded
         * using XMLHttpRequest, which means that in order to make requests to another origin,
         * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
         *
         * @exports loadWithXhr
         *
         * @param {Object} options Object with the following properties:
         * @param {String|Promise.<String>} options.url The URL of the data, or a promise for the URL.
         * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
         * @param {String} [options.method='GET'] The HTTP method to use.
         * @param {String} [options.data] The data to send with the request, if any.
         * @param {Object} [options.headers] HTTP headers to send with the request, if any.
         * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
         * @returns {Promise.<Object>} a promise that will resolve to the requested data when loaded.
         *
         *
         * @example
         * // Load a single URL asynchronously. In real code, you should use loadBlob instead.
         * Cesium.loadWithXhr({
         *     url : 'some/url',
         *     responseType : 'blob'
         * }).then(function(blob) {
         *     // use the data
         * }).otherwise(function(error) {
         *     // an error occurred
         * });
         * 
         * @see loadArrayBuffer
         * @see loadBlob
         * @see loadJson
         * @see loadText
         * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
         * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
         */

        function loadWithXhr(options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);

            //>>includeStart('debug', pragmas.debug);
            if (!defined(options.url)) {
                throw new DeveloperError('options.url is required.');
            }
            //>>includeEnd('debug');

            var responseType = options.responseType;
            var method = defaultValue(options.method, 'GET');
            var data = options.data;
            var headers = options.headers;
            var overrideMimeType = options.overrideMimeType;

            return when(options.url, function (url) {
                var deferred = when.defer();

                loadWithXhr.load(url, responseType, method, data, headers, deferred, overrideMimeType);

                return deferred.promise;
            });
        }

        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;

        function decodeDataUriText(isBase64, data) {
            var result = decodeURIComponent(data);
            if (isBase64) {
                return atob(result);
            }
            return result;
        }

        function decodeDataUriArrayBuffer(isBase64, data) {
            var byteString = decodeDataUriText(isBase64, data);
            var buffer = new ArrayBuffer(byteString.length);
            var view = new Uint8Array(buffer);
            for (var i = 0; i < byteString.length; i++) {
                view[i] = byteString.charCodeAt(i);
            }
            return buffer;
        }

        function decodeDataUri(dataUriRegexResult, responseType) {
            responseType = defaultValue(responseType, '');
            var mimeType = dataUriRegexResult[1];
            var isBase64 = !!dataUriRegexResult[2];
            var data = dataUriRegexResult[3];

            switch (responseType) {
                case '':
                case 'text':
                    return decodeDataUriText(isBase64, data);
                case 'arraybuffer':
                    return decodeDataUriArrayBuffer(isBase64, data);
                case 'blob':
                    var buffer = decodeDataUriArrayBuffer(isBase64, data);
                    return new Blob([buffer], {
                        type: mimeType
                    });
                case 'document':
                    var parser = new DOMParser();
                    return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);
                case 'json':
                    return JSON.parse(decodeDataUriText(isBase64, data));
                default:
                    throw new DeveloperError('Unhandled responseType: ' + responseType);
            }
        }

        // This is broken out into a separate function so that it can be mocked for testing purposes.
        loadWithXhr.load = function (url, responseType, method, data, headers, deferred, overrideMimeType) {
            var dataUriRegexResult = dataUriRegex.exec(url);
            if (dataUriRegexResult !== null) {
                deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
                return;
            }

            var xhr = new XMLHttpRequest();

            if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {
                xhr.overrideMimeType(overrideMimeType);
            }

            xhr.open(method, url, true);

            if (defined(headers)) {
                for (var key in headers) {
                    if (headers.hasOwnProperty(key)) {
                        xhr.setRequestHeader(key, headers[key]);
                    }
                }
            }

            if (defined(responseType)) {
                xhr.responseType = responseType;
            }

            xhr.onload = function () {
                if (xhr.status >= 200 && xhr.status < 300) {
                    if (defined(xhr.response)) {
                        deferred.resolve(xhr.response);
                    } else {
                        // busted old browsers.
                        if (defined(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {
                            deferred.resolve(xhr.responseXML);
                        } else if (defined(xhr.responseText)) {
                            deferred.resolve(xhr.responseText);
                        } else {
                            deferred.reject(new RuntimeError('unknown XMLHttpRequest response type.'));
                        }
                    }
                } else {
                    deferred.reject(new RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()));
                }
            };

            xhr.onerror = function (e) {
                deferred.reject(new RequestErrorEvent());
            };

            xhr.send(data);
        };

        loadWithXhr.defaultLoad = loadWithXhr.load;

        return loadWithXhr;
    }).call(this, $__require('57'), $__require('2c'), $__require('23'), $__require('25'), $__require('63'), $__require('41'));
});
/*global define*/
$__System.registerDynamic('65', ['64'], false, function ($__require, $__exports, $__module) {
    return (function (loadWithXhr) {
        'use strict';

        /**
         * Asynchronously loads the given URL as text.  Returns a promise that will resolve to
         * a String once loaded, or reject if the URL failed to load.  The data is loaded
         * using XMLHttpRequest, which means that in order to make requests to another origin,
         * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
         *
         * @exports loadText
         *
         * @param {String|Promise.<String>} url The URL to request, or a promise for the URL.
         * @param {Object} [headers] HTTP headers to send with the request.
         * @returns {Promise.<String>} a promise that will resolve to the requested data when loaded.
         *
         *
         * @example
         * // load text from a URL, setting a custom header
         * Cesium.loadText('http://someUrl.com/someJson.txt', {
         *   'X-Custom-Header' : 'some value'
         * }).then(function(text) {
         *     // Do something with the text
         * }).otherwise(function(error) {
         *     // an error occurred
         * });
         * 
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}
         * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
         * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
         */

        function loadText(url, headers) {
            return loadWithXhr({
                url: url,
                headers: headers
            });
        }

        return loadText;
    }).call(this, $__require('64'));
});
/*global define*/
$__System.registerDynamic('5a', ['61', '23', '25', '65'], false, function ($__require, $__exports, $__module) {
    return (function (clone, defined, DeveloperError, loadText) {
        'use strict';

        var defaultHeaders = {
            Accept: 'application/json,*/*;q=0.01'
        };

        // note: &#42;&#47;&#42; below is */* but that ends the comment block early
        /**
         * Asynchronously loads the given URL as JSON.  Returns a promise that will resolve to
         * a JSON object once loaded, or reject if the URL failed to load.  The data is loaded
         * using XMLHttpRequest, which means that in order to make requests to another origin,
         * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
         * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
         * already specified.
         *
         * @exports loadJson
         *
         * @param {String|Promise.<String>} url The URL to request, or a promise for the URL.
         * @param {Object} [headers] HTTP headers to send with the request.
         * 'Accept: application/json,&#42;&#47;&#42;;q=0.01' is added to the request headers automatically
         * if not specified.
         * @returns {Promise.<Object>} a promise that will resolve to the requested data when loaded.
         *
         *
         * @example
         * Cesium.loadJson('http://someUrl.com/someJson.txt').then(function(jsonData) {
         *     // Do something with the JSON object
         * }).otherwise(function(error) {
         *     // an error occurred
         * });
         * 
         * @see loadText
         * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
         * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
         */
        function loadJson(url, headers) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(url)) {
                throw new DeveloperError('url is required.');
            }
            //>>includeEnd('debug');

            if (!defined(headers)) {
                headers = defaultHeaders;
            } else if (!defined(headers.Accept)) {
                // clone before adding the Accept header
                headers = clone(headers);
                headers.Accept = defaultHeaders.Accept;
            }

            return loadText(url, headers).then(function (value) {
                return JSON.parse(value);
            });
        }

        return loadJson;
    }).call(this, $__require('61'), $__require('23'), $__require('25'), $__require('65'));
});
/*global define*/
$__System.registerDynamic('66', ['57', '60', '2c', '23', '67', '2d', '5a', '5c'], false, function ($__require, $__exports, $__module) {
    return (function (when, buildModuleUrl, defaultValue, defined, Iau2006XysSample, JulianDate, loadJson, TimeStandard) {
        'use strict';

        /**
         * A set of IAU2006 XYS data that is used to evaluate the transformation between the International
         * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).
         *
         * @alias Iau2006XysData
         * @constructor
         *
         * @param {Object} [options] Object with the following properties:
         * @param {String} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,
         *                 `{0}` will be replaced with the file index.
         * @param {Number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.
         * @param {Number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the
         *                 first XYS sample.
         * @param {Number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.
         * @param {Number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.
         * @param {Number} [options.totalSamples=27426] The total number of samples in all XYS files.
         *
         * @private
         */

        function Iau2006XysData(options) {
            options = defaultValue(options, defaultValue.EMPTY_OBJECT);

            this._xysFileUrlTemplate = options.xysFileUrlTemplate;
            this._interpolationOrder = defaultValue(options.interpolationOrder, 9);
            this._sampleZeroJulianEphemerisDate = defaultValue(options.sampleZeroJulianEphemerisDate, 2442396.5);
            this._sampleZeroDateTT = new JulianDate(this._sampleZeroJulianEphemerisDate, 0.0, TimeStandard.TAI);
            this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);
            this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);
            this._totalSamples = defaultValue(options.totalSamples, 27426);
            this._samples = new Array(this._totalSamples * 3);
            this._chunkDownloadsInProgress = [];

            var order = this._interpolationOrder;

            // Compute denominators and X values for interpolation.
            var denom = this._denominators = new Array(order + 1);
            var xTable = this._xTable = new Array(order + 1);

            var stepN = Math.pow(this._stepSizeDays, order);

            for (var i = 0; i <= order; ++i) {
                denom[i] = stepN;
                xTable[i] = i * this._stepSizeDays;

                for (var j = 0; j <= order; ++j) {
                    if (j !== i) {
                        denom[i] *= i - j;
                    }
                }

                denom[i] = 1.0 / denom[i];
            }

            // Allocate scratch arrays for interpolation.
            this._work = new Array(order + 1);
            this._coef = new Array(order + 1);
        }

        var julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);

        function getDaysSinceEpoch(xys, dayTT, secondTT) {
            var dateTT = julianDateScratch;
            dateTT.dayNumber = dayTT;
            dateTT.secondsOfDay = secondTT;
            return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);
        }

        /**
         * Preloads XYS data for a specified date range.
         *
         * @param {Number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in
         *                 the Terrestrial Time (TT) time standard.
         * @param {Number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in
         *                 the Terrestrial Time (TT) time standard.
         * @param {Number} stopDayTT The Julian day number of the end of the interval to preload, expressed in
         *                 the Terrestrial Time (TT) time standard.
         * @param {Number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in
         *                 the Terrestrial Time (TT) time standard.
         * @returns {Promise.<undefined>} A promise that, when resolved, indicates that the requested interval has been
         *                    preloaded.
         */
        Iau2006XysData.prototype.preload = function (startDayTT, startSecondTT, stopDayTT, stopSecondTT) {
            var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);
            var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);

            var startIndex = startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2 | 0;
            if (startIndex < 0) {
                startIndex = 0;
            }

            var stopIndex = stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder;
            if (stopIndex >= this._totalSamples) {
                stopIndex = this._totalSamples - 1;
            }

            var startChunk = startIndex / this._samplesPerXysFile | 0;
            var stopChunk = stopIndex / this._samplesPerXysFile | 0;

            var promises = [];
            for (var i = startChunk; i <= stopChunk; ++i) {
                promises.push(requestXysChunk(this, i));
            }

            return when.all(promises);
        };

        /**
         * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,
         * this method will return undefined.
         *
         * @param {Number} dayTT The Julian day number for which to compute the XYS value, expressed in
         *                 the Terrestrial Time (TT) time standard.
         * @param {Number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in
         *                 the Terrestrial Time (TT) time standard.
         * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter
         *                           is undefined, a new instance is allocated and returned.
         * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this
         *                             computation has not yet been downloaded.
         *
         * @see Iau2006XysData#preload
         */
        Iau2006XysData.prototype.computeXysRadians = function (dayTT, secondTT, result) {
            var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
            if (daysSinceEpoch < 0.0) {
                // Can't evaluate prior to the epoch of the data.
                return undefined;
            }

            var centerIndex = daysSinceEpoch / this._stepSizeDays | 0;
            if (centerIndex >= this._totalSamples) {
                // Can't evaluate after the last sample in the data.
                return undefined;
            }

            var degree = this._interpolationOrder;

            var firstIndex = centerIndex - (degree / 2 | 0);
            if (firstIndex < 0) {
                firstIndex = 0;
            }
            var lastIndex = firstIndex + degree;
            if (lastIndex >= this._totalSamples) {
                lastIndex = this._totalSamples - 1;
                firstIndex = lastIndex - degree;
                if (firstIndex < 0) {
                    firstIndex = 0;
                }
            }

            // Are all the samples we need present?
            // We can assume so if the first and last are present
            var isDataMissing = false;
            var samples = this._samples;
            if (!defined(samples[firstIndex * 3])) {
                requestXysChunk(this, firstIndex / this._samplesPerXysFile | 0);
                isDataMissing = true;
            }

            if (!defined(samples[lastIndex * 3])) {
                requestXysChunk(this, lastIndex / this._samplesPerXysFile | 0);
                isDataMissing = true;
            }

            if (isDataMissing) {
                return undefined;
            }

            if (!defined(result)) {
                result = new Iau2006XysSample(0.0, 0.0, 0.0);
            } else {
                result.x = 0.0;
                result.y = 0.0;
                result.s = 0.0;
            }

            var x = daysSinceEpoch - firstIndex * this._stepSizeDays;

            var work = this._work;
            var denom = this._denominators;
            var coef = this._coef;
            var xTable = this._xTable;

            var i, j;
            for (i = 0; i <= degree; ++i) {
                work[i] = x - xTable[i];
            }

            for (i = 0; i <= degree; ++i) {
                coef[i] = 1.0;

                for (j = 0; j <= degree; ++j) {
                    if (j !== i) {
                        coef[i] *= work[j];
                    }
                }

                coef[i] *= denom[i];

                var sampleIndex = (firstIndex + i) * 3;
                result.x += coef[i] * samples[sampleIndex++];
                result.y += coef[i] * samples[sampleIndex++];
                result.s += coef[i] * samples[sampleIndex];
            }

            return result;
        };

        function requestXysChunk(xysData, chunkIndex) {
            if (xysData._chunkDownloadsInProgress[chunkIndex]) {
                // Chunk has already been requested.
                return xysData._chunkDownloadsInProgress[chunkIndex];
            }

            var deferred = when.defer();

            xysData._chunkDownloadsInProgress[chunkIndex] = deferred;

            var chunkUrl;
            var xysFileUrlTemplate = xysData._xysFileUrlTemplate;
            if (defined(xysFileUrlTemplate)) {
                chunkUrl = xysFileUrlTemplate.replace('{0}', chunkIndex);
            } else {
                chunkUrl = buildModuleUrl('Assets/IAU2006_XYS/IAU2006_XYS_' + chunkIndex + '.json');
            }

            when(loadJson(chunkUrl), function (chunk) {
                xysData._chunkDownloadsInProgress[chunkIndex] = false;

                var samples = xysData._samples;
                var newSamples = chunk.samples;
                var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;

                for (var i = 0, len = newSamples.length; i < len; ++i) {
                    samples[startIndex + i] = newSamples[i];
                }

                deferred.resolve();
            });

            return deferred.promise;
        }

        return Iau2006XysData;
    }).call(this, $__require('57'), $__require('60'), $__require('2c'), $__require('23'), $__require('67'), $__require('2d'), $__require('5a'), $__require('5c'));
});
/*global define*/
$__System.registerDynamic('67', [], false, function ($__require, $__exports, $__module) {
  return (function () {
    'use strict';

    /**
     * An IAU 2006 XYS value sampled at a particular time.
     *
     * @alias Iau2006XysSample
     * @constructor
     *
     * @param {Number} x The X value.
     * @param {Number} y The Y value.
     * @param {Number} s The S value.
     *
     * @private
     */

    function Iau2006XysSample(x, y, s) {
      /**
       * The X value.
       * @type {Number}
       */
      this.x = x;

      /**
       * The Y value.
       * @type {Number}
       */
      this.y = y;

      /**
       * The S value.
       * @type {Number}
       */
      this.s = s;
    }

    return Iau2006XysSample;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('68', ['23', '24'], false, function ($__require, $__exports, $__module) {
    return (function (defined, defineProperties) {
        'use strict';

        var _supportsFullscreen;
        var _names = {
            requestFullscreen: undefined,
            exitFullscreen: undefined,
            fullscreenEnabled: undefined,
            fullscreenElement: undefined,
            fullscreenchange: undefined,
            fullscreenerror: undefined
        };

        /**
         * Browser-independent functions for working with the standard fullscreen API.
         *
         * @exports Fullscreen
         *
         * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
         */
        var Fullscreen = {};

        defineProperties(Fullscreen, {
            /**
             * The element that is currently fullscreen, if any.  To simply check if the
             * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
             * @memberof Fullscreen
             * @type {Object}
             * @readonly
             */
            element: {
                get: function () {
                    if (!Fullscreen.supportsFullscreen()) {
                        return undefined;
                    }

                    return document[_names.fullscreenElement];
                }
            },

            /**
             * The name of the event on the document that is fired when fullscreen is
             * entered or exited.  This event name is intended for use with addEventListener.
             * In your event handler, to determine if the browser is in fullscreen mode or not,
             * use {@link Fullscreen#fullscreen}.
             * @memberof Fullscreen
             * @type {String}
             * @readonly
             */
            changeEventName: {
                get: function () {
                    if (!Fullscreen.supportsFullscreen()) {
                        return undefined;
                    }

                    return _names.fullscreenchange;
                }
            },

            /**
             * The name of the event that is fired when a fullscreen error
             * occurs.  This event name is intended for use with addEventListener.
             * @memberof Fullscreen
             * @type {String}
             * @readonly
             */
            errorEventName: {
                get: function () {
                    if (!Fullscreen.supportsFullscreen()) {
                        return undefined;
                    }

                    return _names.fullscreenerror;
                }
            },

            /**
             * Determine whether the browser will allow an element to be made fullscreen, or not.
             * For example, by default, iframes cannot go fullscreen unless the containing page
             * adds an "allowfullscreen" attribute (or prefixed equivalent).
             * @memberof Fullscreen
             * @type {Boolean}
             * @readonly
             */
            enabled: {
                get: function () {
                    if (!Fullscreen.supportsFullscreen()) {
                        return undefined;
                    }

                    return document[_names.fullscreenEnabled];
                }
            },

            /**
             * Determines if the browser is currently in fullscreen mode.
             * @memberof Fullscreen
             * @type {Boolean}
             * @readonly
             */
            fullscreen: {
                get: function () {
                    if (!Fullscreen.supportsFullscreen()) {
                        return undefined;
                    }

                    return Fullscreen.element !== null;
                }
            }
        });

        /**
         * Detects whether the browser supports the standard fullscreen API.
         *
         * @returns {Boolean} <code>true</code> if the browser supports the standard fullscreen API,
         * <code>false</code> otherwise.
         */
        Fullscreen.supportsFullscreen = function () {
            if (defined(_supportsFullscreen)) {
                return _supportsFullscreen;
            }

            _supportsFullscreen = false;

            var body = document.body;
            if (typeof body.requestFullscreen === 'function') {
                // go with the unprefixed, standard set of names
                _names.requestFullscreen = 'requestFullscreen';
                _names.exitFullscreen = 'exitFullscreen';
                _names.fullscreenEnabled = 'fullscreenEnabled';
                _names.fullscreenElement = 'fullscreenElement';
                _names.fullscreenchange = 'fullscreenchange';
                _names.fullscreenerror = 'fullscreenerror';
                _supportsFullscreen = true;
                return _supportsFullscreen;
            }

            //check for the correct combination of prefix plus the various names that browsers use
            var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];
            var name;
            for (var i = 0, len = prefixes.length; i < len; ++i) {
                var prefix = prefixes[i];

                // casing of Fullscreen differs across browsers
                name = prefix + 'RequestFullscreen';
                if (typeof body[name] === 'function') {
                    _names.requestFullscreen = name;
                    _supportsFullscreen = true;
                } else {
                    name = prefix + 'RequestFullScreen';
                    if (typeof body[name] === 'function') {
                        _names.requestFullscreen = name;
                        _supportsFullscreen = true;
                    }
                }

                // disagreement about whether it's "exit" as per spec, or "cancel"
                name = prefix + 'ExitFullscreen';
                if (typeof document[name] === 'function') {
                    _names.exitFullscreen = name;
                } else {
                    name = prefix + 'CancelFullScreen';
                    if (typeof document[name] === 'function') {
                        _names.exitFullscreen = name;
                    }
                }

                // casing of Fullscreen differs across browsers
                name = prefix + 'FullscreenEnabled';
                if (document[name] !== undefined) {
                    _names.fullscreenEnabled = name;
                } else {
                    name = prefix + 'FullScreenEnabled';
                    if (document[name] !== undefined) {
                        _names.fullscreenEnabled = name;
                    }
                }

                // casing of Fullscreen differs across browsers
                name = prefix + 'FullscreenElement';
                if (document[name] !== undefined) {
                    _names.fullscreenElement = name;
                } else {
                    name = prefix + 'FullScreenElement';
                    if (document[name] !== undefined) {
                        _names.fullscreenElement = name;
                    }
                }

                // thankfully, event names are all lowercase per spec
                name = prefix + 'fullscreenchange';
                // event names do not have 'on' in the front, but the property on the document does
                if (document['on' + name] !== undefined) {
                    //except on IE
                    if (prefix === 'ms') {
                        name = 'MSFullscreenChange';
                    }
                    _names.fullscreenchange = name;
                }

                name = prefix + 'fullscreenerror';
                if (document['on' + name] !== undefined) {
                    //except on IE
                    if (prefix === 'ms') {
                        name = 'MSFullscreenError';
                    }
                    _names.fullscreenerror = name;
                }
            }

            return _supportsFullscreen;
        };

        /**
         * Asynchronously requests the browser to enter fullscreen mode on the given element.
         * If fullscreen mode is not supported by the browser, does nothing.
         *
         * @param {Object} element The HTML element which will be placed into fullscreen mode.
         * @param {HMDVRDevice} [vrDevice] The VR device.
         *
         * @example
         * // Put the entire page into fullscreen.
         * Cesium.Fullscreen.requestFullscreen(document.body)
         *
         * // Place only the Cesium canvas into fullscreen.
         * Cesium.Fullscreen.requestFullscreen(scene.canvas)
         */
        Fullscreen.requestFullscreen = function (element, vrDevice) {
            if (!Fullscreen.supportsFullscreen()) {
                return;
            }

            element[_names.requestFullscreen]({ vrDisplay: vrDevice });
        };

        /**
         * Asynchronously exits fullscreen mode.  If the browser is not currently
         * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
         */
        Fullscreen.exitFullscreen = function () {
            if (!Fullscreen.supportsFullscreen()) {
                return;
            }

            document[_names.exitFullscreen]();
        };

        return Fullscreen;
    }).call(this, $__require('23'), $__require('24'));
});
/*global define*/
$__System.registerDynamic('69', ['2c', '23', '68'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, Fullscreen) {
        'use strict';

        var theNavigator;
        if (typeof navigator !== 'undefined') {
            theNavigator = navigator;
        } else {
            theNavigator = {};
        }

        function extractVersion(versionString) {
            var parts = versionString.split('.');
            for (var i = 0, len = parts.length; i < len; ++i) {
                parts[i] = parseInt(parts[i], 10);
            }
            return parts;
        }

        var isChromeResult;
        var chromeVersionResult;
        function isChrome() {
            if (!defined(isChromeResult)) {
                isChromeResult = false;

                var fields = / Chrome\/([\.0-9]+)/.exec(theNavigator.userAgent);
                if (fields !== null) {
                    isChromeResult = true;
                    chromeVersionResult = extractVersion(fields[1]);
                }
            }

            return isChromeResult;
        }

        function chromeVersion() {
            return isChrome() && chromeVersionResult;
        }

        var isSafariResult;
        var safariVersionResult;
        function isSafari() {
            if (!defined(isSafariResult)) {
                isSafariResult = false;

                // Chrome contains Safari in the user agent too
                if (!isChrome() && / Safari\/[\.0-9]+/.test(theNavigator.userAgent)) {
                    var fields = / Version\/([\.0-9]+)/.exec(theNavigator.userAgent);
                    if (fields !== null) {
                        isSafariResult = true;
                        safariVersionResult = extractVersion(fields[1]);
                    }
                }
            }

            return isSafariResult;
        }

        function safariVersion() {
            return isSafari() && safariVersionResult;
        }

        var isWebkitResult;
        var webkitVersionResult;
        function isWebkit() {
            if (!defined(isWebkitResult)) {
                isWebkitResult = false;

                var fields = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(theNavigator.userAgent);
                if (fields !== null) {
                    isWebkitResult = true;
                    webkitVersionResult = extractVersion(fields[1]);
                    webkitVersionResult.isNightly = !!fields[2];
                }
            }

            return isWebkitResult;
        }

        function webkitVersion() {
            return isWebkit() && webkitVersionResult;
        }

        var isInternetExplorerResult;
        var internetExplorerVersionResult;
        function isInternetExplorer() {
            if (!defined(isInternetExplorerResult)) {
                isInternetExplorerResult = false;

                var fields;
                if (theNavigator.appName === 'Microsoft Internet Explorer') {
                    fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
                    if (fields !== null) {
                        isInternetExplorerResult = true;
                        internetExplorerVersionResult = extractVersion(fields[1]);
                    }
                } else if (theNavigator.appName === 'Netscape') {
                    fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(theNavigator.userAgent);
                    if (fields !== null) {
                        isInternetExplorerResult = true;
                        internetExplorerVersionResult = extractVersion(fields[1]);
                    }
                }
            }
            return isInternetExplorerResult;
        }

        function internetExplorerVersion() {
            return isInternetExplorer() && internetExplorerVersionResult;
        }

        var isFirefoxResult;
        var firefoxVersionResult;
        function isFirefox() {
            if (!defined(isFirefoxResult)) {
                isFirefoxResult = false;

                var fields = /Firefox\/([\.0-9]+)/.exec(theNavigator.userAgent);
                if (fields !== null) {
                    isFirefoxResult = true;
                    firefoxVersionResult = extractVersion(fields[1]);
                }
            }
            return isFirefoxResult;
        }

        var isWindowsResult;
        function isWindows() {
            if (!defined(isWindowsResult)) {
                isWindowsResult = /Windows/i.test(theNavigator.appVersion);
            }
            return isWindowsResult;
        }

        function firefoxVersion() {
            return isFirefox() && firefoxVersionResult;
        }

        var hasPointerEvents;
        function supportsPointerEvents() {
            if (!defined(hasPointerEvents)) {
                //While navigator.pointerEnabled is deprecated in the W3C specification
                //we still need to use it if it exists in order to support browsers
                //that rely on it, such as the Windows WebBrowser control which defines
                //PointerEvent but sets navigator.pointerEnabled to false.
                hasPointerEvents = typeof PointerEvent !== 'undefined' && (!defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);
            }
            return hasPointerEvents;
        }

        var imageRenderingValueResult;
        var supportsImageRenderingPixelatedResult;
        function supportsImageRenderingPixelated() {
            if (!defined(supportsImageRenderingPixelatedResult)) {
                var canvas = document.createElement('canvas');
                canvas.setAttribute('style', 'image-rendering: -moz-crisp-edges;' + 'image-rendering: pixelated;');
                //canvas.style.imageRendering will be undefined, null or an empty string on unsupported browsers.
                var tmp = canvas.style.imageRendering;
                supportsImageRenderingPixelatedResult = defined(tmp) && tmp !== '';
                if (supportsImageRenderingPixelatedResult) {
                    imageRenderingValueResult = tmp;
                }
            }
            return supportsImageRenderingPixelatedResult;
        }

        function imageRenderingValue() {
            return supportsImageRenderingPixelated() ? imageRenderingValueResult : undefined;
        }

        /**
         * A set of functions to detect whether the current browser supports
         * various features.
         *
         * @exports FeatureDetection
         */
        var FeatureDetection = {
            isChrome: isChrome,
            chromeVersion: chromeVersion,
            isSafari: isSafari,
            safariVersion: safariVersion,
            isWebkit: isWebkit,
            webkitVersion: webkitVersion,
            isInternetExplorer: isInternetExplorer,
            internetExplorerVersion: internetExplorerVersion,
            isFirefox: isFirefox,
            firefoxVersion: firefoxVersion,
            isWindows: isWindows,
            hardwareConcurrency: defaultValue(theNavigator.hardwareConcurrency, 3),
            supportsPointerEvents: supportsPointerEvents,
            supportsImageRenderingPixelated: supportsImageRenderingPixelated,
            imageRenderingValue: imageRenderingValue
        };

        /**
         * Detects whether the current browser supports the full screen standard.
         *
         * @returns {Boolean} true if the browser supports the full screen standard, false if not.
         *
         * @see Fullscreen
         * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
         */
        FeatureDetection.supportsFullscreen = function () {
            return Fullscreen.supportsFullscreen();
        };

        /**
         * Detects whether the current browser supports typed arrays.
         *
         * @returns {Boolean} true if the browser supports typed arrays, false if not.
         *
         * @see {@link http://www.khronos.org/registry/typedarray/specs/latest/|Typed Array Specification}
         */
        FeatureDetection.supportsTypedArrays = function () {
            return typeof ArrayBuffer !== 'undefined';
        };

        /**
         * Detects whether the current browser supports Web Workers.
         *
         * @returns {Boolean} true if the browsers supports Web Workers, false if not.
         *
         * @see {@link http://www.w3.org/TR/workers/}
         */
        FeatureDetection.supportsWebWorkers = function () {
            return typeof Worker !== 'undefined';
        };

        return FeatureDetection;
    }).call(this, $__require('2c'), $__require('23'), $__require('68'));
});
/*global define*/
$__System.registerDynamic('3d', ['35', '2c', '23', '25', '69', '28', '30', '3b'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defaultValue, defined, DeveloperError, FeatureDetection, freezeObject, CesiumMath, Matrix3) {
        'use strict';

        /**
         * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
         * @alias Quaternion
         * @constructor
         *
         * @param {Number} [x=0.0] The X component.
         * @param {Number} [y=0.0] The Y component.
         * @param {Number} [z=0.0] The Z component.
         * @param {Number} [w=0.0] The W component.
         *
         * @see PackableForInterpolation
         */

        function Quaternion(x, y, z, w) {
            /**
             * The X component.
             * @type {Number}
             * @default 0.0
             */
            this.x = defaultValue(x, 0.0);

            /**
             * The Y component.
             * @type {Number}
             * @default 0.0
             */
            this.y = defaultValue(y, 0.0);

            /**
             * The Z component.
             * @type {Number}
             * @default 0.0
             */
            this.z = defaultValue(z, 0.0);

            /**
             * The W component.
             * @type {Number}
             * @default 0.0
             */
            this.w = defaultValue(w, 0.0);
        }

        var fromAxisAngleScratch = new Cartesian3();

        /**
         * Computes a quaternion representing a rotation around an axis.
         *
         * @param {Cartesian3} axis The axis of rotation.
         * @param {Number} angle The angle in radians to rotate around the axis.
         * @param {Quaternion} [result] The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
         */
        Quaternion.fromAxisAngle = function (axis, angle, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(axis)) {
                throw new DeveloperError('axis is required.');
            }
            if (typeof angle !== 'number') {
                throw new DeveloperError('angle is required and must be a number.');
            }
            //>>includeEnd('debug');

            var halfAngle = angle / 2.0;
            var s = Math.sin(halfAngle);
            fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);

            var x = fromAxisAngleScratch.x * s;
            var y = fromAxisAngleScratch.y * s;
            var z = fromAxisAngleScratch.z * s;
            var w = Math.cos(halfAngle);
            if (!defined(result)) {
                return new Quaternion(x, y, z, w);
            }
            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        var fromRotationMatrixNext = [1, 2, 0];
        var fromRotationMatrixQuat = new Array(3);
        /**
         * Computes a Quaternion from the provided Matrix3 instance.
         *
         * @param {Matrix3} matrix The rotation matrix.
         * @param {Quaternion} [result] The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
         *
         * @see Matrix3.fromQuaternion
         */
        Quaternion.fromRotationMatrix = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }
            //>>includeEnd('debug');

            var root;
            var x;
            var y;
            var z;
            var w;

            var m00 = matrix[Matrix3.COLUMN0ROW0];
            var m11 = matrix[Matrix3.COLUMN1ROW1];
            var m22 = matrix[Matrix3.COLUMN2ROW2];
            var trace = m00 + m11 + m22;

            if (trace > 0.0) {
                // |w| > 1/2, may as well choose w > 1/2
                root = Math.sqrt(trace + 1.0); // 2w
                w = 0.5 * root;
                root = 0.5 / root; // 1/(4w)

                x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;
                y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;
                z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;
            } else {
                // |w| <= 1/2
                var next = fromRotationMatrixNext;

                var i = 0;
                if (m11 > m00) {
                    i = 1;
                }
                if (m22 > m00 && m22 > m11) {
                    i = 2;
                }
                var j = next[i];
                var k = next[j];

                root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);

                var quat = fromRotationMatrixQuat;
                quat[i] = 0.5 * root;
                root = 0.5 / root;
                w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;
                quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;
                quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;

                x = -quat[0];
                y = -quat[1];
                z = -quat[2];
            }

            if (!defined(result)) {
                return new Quaternion(x, y, z, w);
            }
            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        var scratchHPRQuaternion = new Quaternion();

        /**
         * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
         * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
         * the positive x axis.
         *
         * @param {Number} heading The heading angle in radians.
         * @param {Number} pitch The pitch angle in radians.
         * @param {Number} roll The roll angle in radians.
         * @param {Quaternion} [result] The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
         */
        Quaternion.fromHeadingPitchRoll = function (heading, pitch, roll, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(heading)) {
                throw new DeveloperError('heading is required.');
            }
            if (!defined(pitch)) {
                throw new DeveloperError('pitch is required.');
            }
            if (!defined(roll)) {
                throw new DeveloperError('roll is required.');
            }
            //>>includeEnd('debug');

            var rollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, roll, scratchHPRQuaternion);
            var pitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, result);
            result = Quaternion.multiply(pitchQuaternion, rollQuaternion, pitchQuaternion);
            var headingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchHPRQuaternion);
            return Quaternion.multiply(headingQuaternion, result, result);
        };

        var sampledQuaternionAxis = new Cartesian3();
        var sampledQuaternionRotation = new Cartesian3();
        var sampledQuaternionTempQuaternion = new Quaternion();
        var sampledQuaternionQuaternion0 = new Quaternion();
        var sampledQuaternionQuaternion0Conjugate = new Quaternion();

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Quaternion.packedLength = 4;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Quaternion} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Quaternion.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }

            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            array[startingIndex++] = value.x;
            array[startingIndex++] = value.y;
            array[startingIndex++] = value.z;
            array[startingIndex] = value.w;
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Quaternion} [result] The object into which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
         */
        Quaternion.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Quaternion();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            result.w = array[startingIndex + 3];
            return result;
        };

        /**
         * The number of elements used to store the object into an array in its interpolatable form.
         * @type {Number}
         */
        Quaternion.packedInterpolationLength = 3;

        /**
         * Converts a packed array into a form suitable for interpolation.
         *
         * @param {Number[]} packedArray The packed array.
         * @param {Number} [startingIndex=0] The index of the first element to be converted.
         * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.
         * @param {Number[]} result The object into which to store the result.
         */
        Quaternion.convertPackedArrayForInterpolation = function (packedArray, startingIndex, lastIndex, result) {
            Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);
            Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);

            for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {
                var offset = i * 3;
                Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);

                Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);

                if (sampledQuaternionTempQuaternion.w < 0) {
                    Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);
                }

                Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);
                var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
                result[offset] = sampledQuaternionAxis.x * angle;
                result[offset + 1] = sampledQuaternionAxis.y * angle;
                result[offset + 2] = sampledQuaternionAxis.z * angle;
            }
        };

        /**
         * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
         *
         * @param {Number[]} array The array previously packed for interpolation.
         * @param {Number[]} sourceArray The original packed array.
         * @param {Number} [startingIndex=0] The startingIndex used to convert the array.
         * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
         * @param {Quaternion} [result] The object into which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
         */
        Quaternion.unpackInterpolationResult = function (array, sourceArray, firstIndex, lastIndex, result) {
            if (!defined(result)) {
                result = new Quaternion();
            }
            Cartesian3.fromArray(array, 0, sampledQuaternionRotation);
            var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);

            Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);

            if (magnitude === 0) {
                Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
            } else {
                Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);
            }

            return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);
        };

        /**
         * Duplicates a Quaternion instance.
         *
         * @param {Quaternion} quaternion The quaternion to duplicate.
         * @param {Quaternion} [result] The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)
         */
        Quaternion.clone = function (quaternion, result) {
            if (!defined(quaternion)) {
                return undefined;
            }

            if (!defined(result)) {
                return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
            }

            result.x = quaternion.x;
            result.y = quaternion.y;
            result.z = quaternion.z;
            result.w = quaternion.w;
            return result;
        };

        /**
         * Computes the conjugate of the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to conjugate.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.conjugate = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = -quaternion.x;
            result.y = -quaternion.y;
            result.z = -quaternion.z;
            result.w = quaternion.w;
            return result;
        };

        /**
         * Computes magnitude squared for the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to conjugate.
         * @returns {Number} The magnitude squared.
         */
        Quaternion.magnitudeSquared = function (quaternion) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            //>>includeEnd('debug');

            return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
        };

        /**
         * Computes magnitude for the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to conjugate.
         * @returns {Number} The magnitude.
         */
        Quaternion.magnitude = function (quaternion) {
            return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
        };

        /**
         * Computes the normalized form of the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to normalize.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.normalize = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);
            var x = quaternion.x * inverseMagnitude;
            var y = quaternion.y * inverseMagnitude;
            var z = quaternion.z * inverseMagnitude;
            var w = quaternion.w * inverseMagnitude;

            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        /**
         * Computes the inverse of the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to normalize.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.inverse = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
            result = Quaternion.conjugate(quaternion, result);
            return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);
        };

        /**
         * Computes the componentwise sum of two quaternions.
         *
         * @param {Quaternion} left The first quaternion.
         * @param {Quaternion} right The second quaternion.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.add = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x + right.x;
            result.y = left.y + right.y;
            result.z = left.z + right.z;
            result.w = left.w + right.w;
            return result;
        };

        /**
         * Computes the componentwise difference of two quaternions.
         *
         * @param {Quaternion} left The first quaternion.
         * @param {Quaternion} right The second quaternion.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.subtract = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x - right.x;
            result.y = left.y - right.y;
            result.z = left.z - right.z;
            result.w = left.w - right.w;
            return result;
        };

        /**
         * Negates the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to be negated.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.negate = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = -quaternion.x;
            result.y = -quaternion.y;
            result.z = -quaternion.z;
            result.w = -quaternion.w;
            return result;
        };

        /**
         * Computes the dot (scalar) product of two quaternions.
         *
         * @param {Quaternion} left The first quaternion.
         * @param {Quaternion} right The second quaternion.
         * @returns {Number} The dot product.
         */
        Quaternion.dot = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            //>>includeEnd('debug');

            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        };

        /**
         * Computes the product of two quaternions.
         *
         * @param {Quaternion} left The first quaternion.
         * @param {Quaternion} right The second quaternion.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.multiply = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var leftX = left.x;
            var leftY = left.y;
            var leftZ = left.z;
            var leftW = left.w;

            var rightX = right.x;
            var rightY = right.y;
            var rightZ = right.z;
            var rightW = right.w;

            var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
            var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
            var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
            var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;

            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        /**
         * Multiplies the provided quaternion componentwise by the provided scalar.
         *
         * @param {Quaternion} quaternion The quaternion to be scaled.
         * @param {Number} scalar The scalar to multiply with.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.multiplyByScalar = function (quaternion, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = quaternion.x * scalar;
            result.y = quaternion.y * scalar;
            result.z = quaternion.z * scalar;
            result.w = quaternion.w * scalar;
            return result;
        };

        /**
         * Divides the provided quaternion componentwise by the provided scalar.
         *
         * @param {Quaternion} quaternion The quaternion to be divided.
         * @param {Number} scalar The scalar to divide by.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.divideByScalar = function (quaternion, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = quaternion.x / scalar;
            result.y = quaternion.y / scalar;
            result.z = quaternion.z / scalar;
            result.w = quaternion.w / scalar;
            return result;
        };

        /**
         * Computes the axis of rotation of the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to use.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Quaternion.computeAxis = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var w = quaternion.w;
            if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {
                result.x = result.y = result.z = 0;
                return result;
            }

            var scalar = 1.0 / Math.sqrt(1.0 - w * w);

            result.x = quaternion.x * scalar;
            result.y = quaternion.y * scalar;
            result.z = quaternion.z * scalar;
            return result;
        };

        /**
         * Computes the angle of rotation of the provided quaternion.
         *
         * @param {Quaternion} quaternion The quaternion to use.
         * @returns {Number} The angle of rotation.
         */
        Quaternion.computeAngle = function (quaternion) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            //>>includeEnd('debug');

            if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {
                return 0.0;
            }
            return 2.0 * Math.acos(quaternion.w);
        };

        var lerpScratch = new Quaternion();
        /**
         * Computes the linear interpolation or extrapolation at t using the provided quaternions.
         *
         * @param {Quaternion} start The value corresponding to t at 0.0.
         * @param {Quaternion} end The value corresponding to t at 1.0.
         * @param {Number} t The point along t at which to interpolate.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.lerp = function (start, end, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start is required.');
            }
            if (!defined(end)) {
                throw new DeveloperError('end is required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
            result = Quaternion.multiplyByScalar(start, 1.0 - t, result);
            return Quaternion.add(lerpScratch, result, result);
        };

        var slerpEndNegated = new Quaternion();
        var slerpScaledP = new Quaternion();
        var slerpScaledR = new Quaternion();
        /**
         * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
         *
         * @param {Quaternion} start The value corresponding to t at 0.0.
         * @param {Quaternion} end The value corresponding to t at 1.0.
         * @param {Number} t The point along t at which to interpolate.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         *
         * @see Quaternion#fastSlerp
         */
        Quaternion.slerp = function (start, end, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start is required.');
            }
            if (!defined(end)) {
                throw new DeveloperError('end is required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var dot = Quaternion.dot(start, end);

            // The angle between start must be acute. Since q and -q represent
            // the same rotation, negate q to get the acute angle.
            var r = end;
            if (dot < 0.0) {
                dot = -dot;
                r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
            }

            // dot > 0, as the dot product approaches 1, the angle between the
            // quaternions vanishes. use linear interpolation.
            if (1.0 - dot < CesiumMath.EPSILON6) {
                return Quaternion.lerp(start, r, t, result);
            }

            var theta = Math.acos(dot);
            slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);
            slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);
            result = Quaternion.add(slerpScaledP, slerpScaledR, result);
            return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);
        };

        /**
         * The logarithmic quaternion function.
         *
         * @param {Quaternion} quaternion The unit quaternion.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Quaternion.log = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var theta = CesiumMath.acosClamped(quaternion.w);
            var thetaOverSinTheta = 0.0;

            if (theta !== 0.0) {
                thetaOverSinTheta = theta / Math.sin(theta);
            }

            return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);
        };

        /**
         * The exponential quaternion function.
         *
         * @param {Cartesian3} cartesian The cartesian.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         */
        Quaternion.exp = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var theta = Cartesian3.magnitude(cartesian);
            var sinThetaOverTheta = 0.0;

            if (theta !== 0.0) {
                sinThetaOverTheta = Math.sin(theta) / theta;
            }

            result.x = cartesian.x * sinThetaOverTheta;
            result.y = cartesian.y * sinThetaOverTheta;
            result.z = cartesian.z * sinThetaOverTheta;
            result.w = Math.cos(theta);

            return result;
        };

        var squadScratchCartesian0 = new Cartesian3();
        var squadScratchCartesian1 = new Cartesian3();
        var squadScratchQuaternion0 = new Quaternion();
        var squadScratchQuaternion1 = new Quaternion();

        /**
         * Computes an inner quadrangle point.
         * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
         *
         * @param {Quaternion} q0 The first quaternion.
         * @param {Quaternion} q1 The second quaternion.
         * @param {Quaternion} q2 The third quaternion.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         *
         * @see Quaternion#squad
         */
        Quaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(q0) || !defined(q1) || !defined(q2)) {
                throw new DeveloperError('q0, q1, and q2 are required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);
            Quaternion.multiply(qInv, q2, squadScratchQuaternion1);
            var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);

            Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
            var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);

            Cartesian3.add(cart0, cart1, cart0);
            Cartesian3.multiplyByScalar(cart0, 0.25, cart0);
            Cartesian3.negate(cart0, cart0);
            Quaternion.exp(cart0, squadScratchQuaternion0);

            return Quaternion.multiply(q1, squadScratchQuaternion0, result);
        };

        /**
         * Computes the spherical quadrangle interpolation between quaternions.
         *
         * @param {Quaternion} q0 The first quaternion.
         * @param {Quaternion} q1 The second quaternion.
         * @param {Quaternion} s0 The first inner quadrangle.
         * @param {Quaternion} s1 The second inner quadrangle.
         * @param {Number} t The time in [0,1] used to interpolate.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         *
         *
         * @example
         * // 1. compute the squad interpolation between two quaternions on a curve
         * var s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());
         * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());
         * var q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());
         *
         * // 2. compute the squad interpolation as above but where the first quaternion is a end point.
         * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());
         * var q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());
         * 
         * @see Quaternion#computeInnerQuadrangle
         */
        Quaternion.squad = function (q0, q1, s0, s1, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
                throw new DeveloperError('q0, q1, s0, and s1 are required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);
            var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
            return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
        };

        var fastSlerpScratchQuaternion = new Quaternion();
        var opmu = 1.90110745351730037;
        var u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
        var v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
        var bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
        var bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];

        for (var i = 0; i < 7; ++i) {
            var s = i + 1.0;
            var t = 2.0 * s + 1.0;
            u[i] = 1.0 / (s * t);
            v[i] = s / t;
        }

        u[7] = opmu / (8.0 * 17.0);
        v[7] = opmu * 8.0 / 17.0;

        /**
         * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
         * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
         *
         * @param {Quaternion} start The value corresponding to t at 0.0.
         * @param {Quaternion} end The value corresponding to t at 1.0.
         * @param {Number} t The point along t at which to interpolate.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter.
         *
         * @see Quaternion#slerp
         */
        Quaternion.fastSlerp = function (start, end, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start is required.');
            }
            if (!defined(end)) {
                throw new DeveloperError('end is required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var x = Quaternion.dot(start, end);

            var sign;
            if (x >= 0) {
                sign = 1.0;
            } else {
                sign = -1.0;
                x = -x;
            }

            var xm1 = x - 1.0;
            var d = 1.0 - t;
            var sqrT = t * t;
            var sqrD = d * d;

            for (var i = 7; i >= 0; --i) {
                bT[i] = (u[i] * sqrT - v[i]) * xm1;
                bD[i] = (u[i] * sqrD - v[i]) * xm1;
            }

            var cT = sign * t * (1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));
            var cD = d * (1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));

            var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);
            Quaternion.multiplyByScalar(end, cT, result);
            return Quaternion.add(temp, result, result);
        };

        /**
         * Computes the spherical quadrangle interpolation between quaternions.
         * An implementation that is faster than {@link Quaternion#squad}, but less accurate.
         *
         * @param {Quaternion} q0 The first quaternion.
         * @param {Quaternion} q1 The second quaternion.
         * @param {Quaternion} s0 The first inner quadrangle.
         * @param {Quaternion} s1 The second inner quadrangle.
         * @param {Number} t The time in [0,1] used to interpolate.
         * @param {Quaternion} result The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new instance if none was provided.
         *
         * @see Quaternion#squad
         */
        Quaternion.fastSquad = function (q0, q1, s0, s1, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
                throw new DeveloperError('q0, q1, s0, and s1 are required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);
            var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
            return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);
        };

        /**
         * Compares the provided quaternions componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Quaternion} [left] The first quaternion.
         * @param {Quaternion} [right] The second quaternion.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Quaternion.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
        };

        /**
         * Compares the provided quaternions componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Quaternion} [left] The first quaternion.
         * @param {Quaternion} [right] The second quaternion.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Quaternion.equalsEpsilon = function (left, right, epsilon) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof epsilon !== 'number') {
                throw new DeveloperError('epsilon is required and must be a number.');
            }
            //>>includeEnd('debug');

            return left === right || defined(left) && defined(right) && Math.abs(left.x - right.x) <= epsilon && Math.abs(left.y - right.y) <= epsilon && Math.abs(left.z - right.z) <= epsilon && Math.abs(left.w - right.w) <= epsilon;
        };

        /**
         * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
         *
         * @type {Quaternion}
         * @constant
         */
        Quaternion.ZERO = freezeObject(new Quaternion(0.0, 0.0, 0.0, 0.0));

        /**
         * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
         *
         * @type {Quaternion}
         * @constant
         */
        Quaternion.IDENTITY = freezeObject(new Quaternion(0.0, 0.0, 0.0, 1.0));

        /**
         * Duplicates this Quaternion instance.
         *
         * @param {Quaternion} [result] The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
         */
        Quaternion.prototype.clone = function (result) {
            return Quaternion.clone(this, result);
        };

        /**
         * Compares this and the provided quaternion componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Quaternion} [right] The right hand side quaternion.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Quaternion.prototype.equals = function (right) {
            return Quaternion.equals(this, right);
        };

        /**
         * Compares this and the provided quaternion componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Quaternion} [right] The right hand side quaternion.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Quaternion.prototype.equalsEpsilon = function (right, epsilon) {
            return Quaternion.equalsEpsilon(this, right, epsilon);
        };

        /**
         * Returns a string representing this quaternion in the format (x, y, z, w).
         *
         * @returns {String} A string representing this Quaternion.
         */
        Quaternion.prototype.toString = function () {
            return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
        };

        return Quaternion;
    }).call(this, $__require('35'), $__require('2c'), $__require('23'), $__require('25'), $__require('69'), $__require('28'), $__require('30'), $__require('3b'));
});
/*global define*/
$__System.registerDynamic('3e', ['57', '4e', '35', '4c', '44', '2c', '23', '25', '56', '58', '45', '66', '67', '2d', '30', '3b', '3c', '3d', '5b'], false, function ($__require, $__exports, $__module) {
    return (function (when, Cartesian2, Cartesian3, Cartesian4, Cartographic, defaultValue, defined, DeveloperError, EarthOrientationParameters, EarthOrientationParametersSample, Ellipsoid, Iau2006XysData, Iau2006XysSample, JulianDate, CesiumMath, Matrix3, Matrix4, Quaternion, TimeConstants) {
        'use strict';

        /**
         * Contains functions for transforming positions to various reference frames.
         *
         * @exports Transforms
         */

        var Transforms = {};

        var eastNorthUpToFixedFrameNormal = new Cartesian3();
        var eastNorthUpToFixedFrameTangent = new Cartesian3();
        var eastNorthUpToFixedFrameBitangent = new Cartesian3();

        /**
         * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
         * centered at the provided origin to the provided ellipsoid's fixed reference frame.
         * The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local east direction.</li>
         * <li>The <code>y</code> axis points in the local north direction.</li>
         * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
         *
         * @example
         * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
         * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
         */
        Transforms.eastNorthUpToFixedFrame = function (origin, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(origin)) {
                throw new DeveloperError('origin is required.');
            }
            //>>includeEnd('debug');

            // If x and y are zero, assume origin is at a pole, which is a special case.
            if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
                var sign = CesiumMath.sign(origin.z);
                if (!defined(result)) {
                    return new Matrix4(0.0, -sign, 0.0, origin.x, 1.0, 0.0, 0.0, origin.y, 0.0, 0.0, sign, origin.z, 0.0, 0.0, 0.0, 1.0);
                }
                result[0] = 0.0;
                result[1] = 1.0;
                result[2] = 0.0;
                result[3] = 0.0;
                result[4] = -sign;
                result[5] = 0.0;
                result[6] = 0.0;
                result[7] = 0.0;
                result[8] = 0.0;
                result[9] = 0.0;
                result[10] = sign;
                result[11] = 0.0;
                result[12] = origin.x;
                result[13] = origin.y;
                result[14] = origin.z;
                result[15] = 1.0;
                return result;
            }

            var normal = eastNorthUpToFixedFrameNormal;
            var tangent = eastNorthUpToFixedFrameTangent;
            var bitangent = eastNorthUpToFixedFrameBitangent;

            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
            ellipsoid.geodeticSurfaceNormal(origin, normal);

            tangent.x = -origin.y;
            tangent.y = origin.x;
            tangent.z = 0.0;
            Cartesian3.normalize(tangent, tangent);

            Cartesian3.cross(normal, tangent, bitangent);

            if (!defined(result)) {
                return new Matrix4(tangent.x, bitangent.x, normal.x, origin.x, tangent.y, bitangent.y, normal.y, origin.y, tangent.z, bitangent.z, normal.z, origin.z, 0.0, 0.0, 0.0, 1.0);
            }
            result[0] = tangent.x;
            result[1] = tangent.y;
            result[2] = tangent.z;
            result[3] = 0.0;
            result[4] = bitangent.x;
            result[5] = bitangent.y;
            result[6] = bitangent.z;
            result[7] = 0.0;
            result[8] = normal.x;
            result[9] = normal.y;
            result[10] = normal.z;
            result[11] = 0.0;
            result[12] = origin.x;
            result[13] = origin.y;
            result[14] = origin.z;
            result[15] = 1.0;
            return result;
        };

        var northEastDownToFixedFrameNormal = new Cartesian3();
        var northEastDownToFixedFrameTangent = new Cartesian3();
        var northEastDownToFixedFrameBitangent = new Cartesian3();

        /**
         * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
         * centered at the provided origin to the provided ellipsoid's fixed reference frame.
         * The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local north direction.</li>
         * <li>The <code>y</code> axis points in the local east direction.</li>
         * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
         *
         * @example
         * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
         * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);
         */
        Transforms.northEastDownToFixedFrame = function (origin, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(origin)) {
                throw new DeveloperError('origin is required.');
            }
            //>>includeEnd('debug');

            if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
                // The poles are special cases.  If x and y are zero, assume origin is at a pole.
                var sign = CesiumMath.sign(origin.z);
                if (!defined(result)) {
                    return new Matrix4(-sign, 0.0, 0.0, origin.x, 0.0, 1.0, 0.0, origin.y, 0.0, 0.0, -sign, origin.z, 0.0, 0.0, 0.0, 1.0);
                }
                result[0] = -sign;
                result[1] = 0.0;
                result[2] = 0.0;
                result[3] = 0.0;
                result[4] = 0.0;
                result[5] = 1.0;
                result[6] = 0.0;
                result[7] = 0.0;
                result[8] = 0.0;
                result[9] = 0.0;
                result[10] = -sign;
                result[11] = 0.0;
                result[12] = origin.x;
                result[13] = origin.y;
                result[14] = origin.z;
                result[15] = 1.0;
                return result;
            }

            var normal = northEastDownToFixedFrameNormal;
            var tangent = northEastDownToFixedFrameTangent;
            var bitangent = northEastDownToFixedFrameBitangent;

            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
            ellipsoid.geodeticSurfaceNormal(origin, normal);

            tangent.x = -origin.y;
            tangent.y = origin.x;
            tangent.z = 0.0;
            Cartesian3.normalize(tangent, tangent);

            Cartesian3.cross(normal, tangent, bitangent);

            if (!defined(result)) {
                return new Matrix4(bitangent.x, tangent.x, -normal.x, origin.x, bitangent.y, tangent.y, -normal.y, origin.y, bitangent.z, tangent.z, -normal.z, origin.z, 0.0, 0.0, 0.0, 1.0);
            }
            result[0] = bitangent.x;
            result[1] = bitangent.y;
            result[2] = bitangent.z;
            result[3] = 0.0;
            result[4] = tangent.x;
            result[5] = tangent.y;
            result[6] = tangent.z;
            result[7] = 0.0;
            result[8] = -normal.x;
            result[9] = -normal.y;
            result[10] = -normal.z;
            result[11] = 0.0;
            result[12] = origin.x;
            result[13] = origin.y;
            result[14] = origin.z;
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
         * centered at the provided origin to the provided ellipsoid's fixed reference frame.
         * The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local north direction.</li>
         * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
         * <li>The <code>z</code> axis points in the local east direction.</li>
         * </ul>
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
         *
         * @example
         * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
         * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);
         */
        Transforms.northUpEastToFixedFrame = function (origin, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(origin)) {
                throw new DeveloperError('origin is required.');
            }
            //>>includeEnd('debug');

            // If x and y are zero, assume origin is at a pole, which is a special case.
            if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {
                var sign = CesiumMath.sign(origin.z);
                if (!defined(result)) {
                    return new Matrix4(-sign, 0.0, 0.0, origin.x, 0.0, 0.0, 1.0, origin.y, 0.0, sign, 0.0, origin.z, 0.0, 0.0, 0.0, 1.0);
                }
                result[0] = -sign;
                result[1] = 0.0;
                result[2] = 0.0;
                result[3] = 0.0;
                result[4] = 0.0;
                result[5] = 0.0;
                result[6] = sign;
                result[7] = 0.0;
                result[8] = 0.0;
                result[9] = 1.0;
                result[10] = 0.0;
                result[11] = 0.0;
                result[12] = origin.x;
                result[13] = origin.y;
                result[14] = origin.z;
                result[15] = 1.0;
                return result;
            }

            var normal = eastNorthUpToFixedFrameNormal;
            var tangent = eastNorthUpToFixedFrameTangent;
            var bitangent = eastNorthUpToFixedFrameBitangent;

            ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
            ellipsoid.geodeticSurfaceNormal(origin, normal);

            tangent.x = -origin.y;
            tangent.y = origin.x;
            tangent.z = 0.0;
            Cartesian3.normalize(tangent, tangent);

            Cartesian3.cross(normal, tangent, bitangent);

            if (!defined(result)) {
                return new Matrix4(bitangent.x, normal.x, tangent.x, origin.x, bitangent.y, normal.y, tangent.y, origin.y, bitangent.z, normal.z, tangent.z, origin.z, 0.0, 0.0, 0.0, 1.0);
            }
            result[0] = bitangent.x;
            result[1] = bitangent.y;
            result[2] = bitangent.z;
            result[3] = 0.0;
            result[4] = normal.x;
            result[5] = normal.y;
            result[6] = normal.z;
            result[7] = 0.0;
            result[8] = tangent.x;
            result[9] = tangent.y;
            result[10] = tangent.z;
            result[11] = 0.0;
            result[12] = origin.x;
            result[13] = origin.y;
            result[14] = origin.z;
            result[15] = 1.0;
            return result;
        };

        var scratchHPRQuaternion = new Quaternion();
        var scratchScale = new Cartesian3(1.0, 1.0, 1.0);
        var scratchHPRMatrix4 = new Matrix4();

        /**
         * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
         * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north
         * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
         * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Number} heading The heading angle in radians.
         * @param {Number} pitch The pitch angle in radians.
         * @param {Number} roll The roll angle in radians.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
         *
         * @example
         * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
         * var heading = -Cesium.Math.PI_OVER_TWO;
         * var pitch = Cesium.Math.PI_OVER_FOUR;
         * var roll = 0.0;
         * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, heading, pitch, roll);
         */
        Transforms.headingPitchRollToFixedFrame = function (origin, heading, pitch, roll, ellipsoid, result) {
            // checks for required parameters happen in the called functions
            var hprQuaternion = Quaternion.fromHeadingPitchRoll(heading, pitch, roll, scratchHPRQuaternion);
            var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);
            result = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, result);
            return Matrix4.multiply(result, hprMatrix, result);
        };

        var scratchENUMatrix4 = new Matrix4();
        var scratchHPRMatrix3 = new Matrix3();

        /**
         * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
         * centered at the provided origin. Heading is the rotation from the local north
         * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
         * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
         *
         * @param {Cartesian3} origin The center point of the local reference frame.
         * @param {Number} heading The heading angle in radians.
         * @param {Number} pitch The pitch angle in radians.
         * @param {Number} roll The roll angle in radians.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
         * @param {Quaternion} [result] The object onto which to store the result.
         * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
         *
         * @example
         * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
         * var heading = -Cesium.Math.PI_OVER_TWO;
         * var pitch = Cesium.Math.PI_OVER_FOUR;
         * var roll = 0.0;
         * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, heading, pitch, roll);
         */
        Transforms.headingPitchRollQuaternion = function (origin, heading, pitch, roll, ellipsoid, result) {
            // checks for required parameters happen in the called functions
            var transform = Transforms.headingPitchRollToFixedFrame(origin, heading, pitch, roll, ellipsoid, scratchENUMatrix4);
            var rotation = Matrix4.getRotation(transform, scratchHPRMatrix3);
            return Quaternion.fromRotationMatrix(rotation, result);
        };

        var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
        var gmstConstant1 = 8640184.812866;
        var gmstConstant2 = 0.093104;
        var gmstConstant3 = -6.2E-6;
        var rateCoef = 1.1772758384668e-19;
        var wgs84WRPrecessing = 7.2921158553E-5;
        var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;
        var dateInUtc = new JulianDate();

        /**
         * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
         * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
         *
         * @param {JulianDate} date The time at which to compute the rotation matrix.
         * @param {Matrix3} [result] The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
         *
         * @example
         * //Set the view to in the inertial frame.
         * scene.preRender.addEventListener(function(scene, time) {
         *    var now = Cesium.JulianDate.now();
         *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
         *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));
         *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
         *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
         *    camera.lookAtTransform(transform, offset);
         * });
         */
        Transforms.computeTemeToPseudoFixedMatrix = function (date, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(date)) {
                throw new DeveloperError('date is required.');
            }
            //>>includeEnd('debug');

            // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.
            // We do not want to use the function like convertTaiToUtc in JulianDate because
            // we explicitly do not want to fail when inside the leap second.

            dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);
            var utcDayNumber = dateInUtc.dayNumber;
            var utcSecondsIntoDay = dateInUtc.secondsOfDay;

            var t;
            var diffDays = utcDayNumber - 2451545;
            if (utcSecondsIntoDay >= 43200.0) {
                t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            } else {
                t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            }

            var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
            var angle = gmst0 * twoPiOverSecondsInDay % CesiumMath.TWO_PI;
            var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
            var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;
            var gha = angle + ratio * secondsSinceMidnight;
            var cosGha = Math.cos(gha);
            var sinGha = Math.sin(gha);

            if (!defined(result)) {
                return new Matrix3(cosGha, sinGha, 0.0, -sinGha, cosGha, 0.0, 0.0, 0.0, 1.0);
            }
            result[0] = cosGha;
            result[1] = -sinGha;
            result[2] = 0.0;
            result[3] = sinGha;
            result[4] = cosGha;
            result[5] = 0.0;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 1.0;
            return result;
        };

        /**
         * The source of IAU 2006 XYS data, used for computing the transformation between the
         * Fixed and ICRF axes.
         * @type {Iau2006XysData}
         *
         * @see Transforms.computeIcrfToFixedMatrix
         * @see Transforms.computeFixedToIcrfMatrix
         *
         * @private
         */
        Transforms.iau2006XysData = new Iau2006XysData();

        /**
         * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation
         * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,
         * yielding a reasonable but not completely accurate representation of the ICRF axes.
         * @type {EarthOrientationParameters}
         *
         * @see Transforms.computeIcrfToFixedMatrix
         * @see Transforms.computeFixedToIcrfMatrix
         *
         * @private
         */
        Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;

        var ttMinusTai = 32.184;
        var j2000ttDays = 2451545.0;

        /**
         * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
         * direction, over a given interval.  This function returns a promise that, when resolved,
         * indicates that the preload has completed.
         *
         * @param {TimeInterval} timeInterval The interval to preload.
         * @returns {Promise.<undefined>} A promise that, when resolved, indicates that the preload has completed
         *          and evaluation of the transformation between the fixed and ICRF axes will
         *          no longer return undefined for a time inside the interval.
         *
         *
         * @example
         * var interval = new Cesium.TimeInterval(...);
         * when(Cesium.Transforms.preloadIcrfFixed(interval), function() {
         *     // the data is now loaded
         * });
         * 
         * @see Transforms.computeIcrfToFixedMatrix
         * @see Transforms.computeFixedToIcrfMatrix
         * @see when
         */
        Transforms.preloadIcrfFixed = function (timeInterval) {
            var startDayTT = timeInterval.start.dayNumber;
            var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
            var stopDayTT = timeInterval.stop.dayNumber;
            var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;

            var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);
            var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();

            return when.all([xysPromise, eopPromise]);
        };

        /**
         * Computes a rotation matrix to transform a point or vector from the International Celestial
         * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
         * at a given time.  This function may return undefined if the data necessary to
         * do the transformation is not yet loaded.
         *
         * @param {JulianDate} date The time at which to compute the rotation matrix.
         * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
         *                  not specified, a new instance is created and returned.
         * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the
         *                   transformation is not yet loaded.
         *
         *
         * @example
         * scene.preRender.addEventListener(function(scene, time) {
         *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
         *   if (Cesium.defined(icrfToFixed)) {
         *     var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
         *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed)
         *     var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
         *     Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
         *     camera.lookAtTransform(transform, offset);
         *   }
         * });
         * 
         * @see Transforms.preloadIcrfFixed
         */
        Transforms.computeIcrfToFixedMatrix = function (date, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(date)) {
                throw new DeveloperError('date is required.');
            }
            //>>includeEnd('debug');
            if (!defined(result)) {
                result = new Matrix3();
            }

            var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
            if (!defined(fixedToIcrfMtx)) {
                return undefined;
            }

            return Matrix3.transpose(fixedToIcrfMtx, result);
        };

        var xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);
        var eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        var rotation1Scratch = new Matrix3();
        var rotation2Scratch = new Matrix3();

        /**
         * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
         * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
         * at a given time.  This function may return undefined if the data necessary to
         * do the transformation is not yet loaded.
         *
         * @param {JulianDate} date The time at which to compute the rotation matrix.
         * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
         *                  not specified, a new instance is created and returned.
         * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the
         *                   transformation is not yet loaded.
         *
         *
         * @example
         * // Transform a point from the ICRF axes to the Fixed axes.
         * var now = Cesium.JulianDate.now();
         * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
         * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);
         * var pointInInertial = new Cesium.Cartesian3();
         * if (Cesium.defined(fixedToIcrf)) {
         *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
         * }
         * 
         * @see Transforms.preloadIcrfFixed
         */
        Transforms.computeFixedToIcrfMatrix = function (date, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(date)) {
                throw new DeveloperError('date is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Matrix3();
            }

            // Compute pole wander
            var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
            if (!defined(eop)) {
                return undefined;
            }

            // There is no external conversion to Terrestrial Time (TT).
            // So use International Atomic Time (TAI) and convert using offsets.
            // Here we are assuming that dayTT and secondTT are positive
            var dayTT = date.dayNumber;
            // It's possible here that secondTT could roll over 86400
            // This does not seem to affect the precision (unit tests check for this)
            var secondTT = date.secondsOfDay + ttMinusTai;

            var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);
            if (!defined(xys)) {
                return undefined;
            }

            var x = xys.x + eop.xPoleOffset;
            var y = xys.y + eop.yPoleOffset;

            // Compute XYS rotation
            var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));

            var rotation1 = rotation1Scratch;
            rotation1[0] = 1.0 - a * x * x;
            rotation1[3] = -a * x * y;
            rotation1[6] = x;
            rotation1[1] = -a * x * y;
            rotation1[4] = 1 - a * y * y;
            rotation1[7] = y;
            rotation1[2] = -x;
            rotation1[5] = -y;
            rotation1[8] = 1 - a * (x * x + y * y);

            var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);
            var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);

            // Similar to TT conversions above
            // It's possible here that secondTT could roll over 86400
            // This does not seem to affect the precision (unit tests check for this)
            var dateUt1day = date.dayNumber;
            var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;

            // Compute Earth rotation angle
            // The IERS standard for era is
            //    era = 0.7790572732640 + 1.00273781191135448 * Tu
            // where
            //    Tu = JulianDateInUt1 - 2451545.0
            // However, you get much more precision if you make the following simplification
            //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)
            //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)
            //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)
            // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.
            var daysSinceJ2000 = dateUt1day - 2451545;
            var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;
            var era = 0.7790572732640 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
            era = era % 1.0 * CesiumMath.TWO_PI;

            var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);

            // pseudoFixed to ICRF
            var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);

            // Compute pole wander matrix
            var cosxp = Math.cos(eop.xPoleWander);
            var cosyp = Math.cos(eop.yPoleWander);
            var sinxp = Math.sin(eop.xPoleWander);
            var sinyp = Math.sin(eop.yPoleWander);

            var ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;
            ttt /= 36525.0;

            // approximate sp value in rad
            var sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;
            var cossp = Math.cos(sp);
            var sinsp = Math.sin(sp);

            var fToPfMtx = rotation2Scratch;
            fToPfMtx[0] = cosxp * cossp;
            fToPfMtx[1] = cosxp * sinsp;
            fToPfMtx[2] = sinxp;
            fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
            fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
            fToPfMtx[5] = -sinyp * cosxp;
            fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
            fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
            fToPfMtx[8] = cosyp * cosxp;

            return Matrix3.multiply(pfToIcrf, fToPfMtx, result);
        };

        var pointToWindowCoordinatesTemp = new Cartesian4();

        /**
         * Transform a point from model coordinates to window coordinates.
         *
         * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.
         * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.
         * @param {Cartesian3} point The point to transform.
         * @param {Cartesian2} [result] The object onto which to store the result.
         * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
         */
        Transforms.pointToWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {
            result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);
            result.y = 2.0 * viewportTransformation[5] - result.y;
            return result;
        };

        /**
         * @private
         */
        Transforms.pointToGLWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(modelViewProjectionMatrix)) {
                throw new DeveloperError('modelViewProjectionMatrix is required.');
            }

            if (!defined(viewportTransformation)) {
                throw new DeveloperError('viewportTransformation is required.');
            }

            if (!defined(point)) {
                throw new DeveloperError('point is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Cartesian2();
            }

            var tmp = pointToWindowCoordinatesTemp;

            Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);
            Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);
            Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
            return Cartesian2.fromCartesian4(tmp, result);
        };

        var normalScratch = new Cartesian3();
        var rightScratch = new Cartesian3();
        var upScratch = new Cartesian3();

        /**
         * @private
         */
        Transforms.rotationMatrixFromPositionVelocity = function (position, velocity, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(position)) {
                throw new DeveloperError('position is required.');
            }

            if (!defined(velocity)) {
                throw new DeveloperError('velocity is required.');
            }
            //>>includeEnd('debug');

            var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(position, normalScratch);
            var right = Cartesian3.cross(velocity, normal, rightScratch);
            if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
                right = Cartesian3.clone(Cartesian3.UNIT_X, right);
            }

            var up = Cartesian3.cross(right, velocity, upScratch);
            Cartesian3.cross(velocity, up, right);
            Cartesian3.negate(right, right);

            if (!defined(result)) {
                result = new Matrix3();
            }

            result[0] = velocity.x;
            result[1] = velocity.y;
            result[2] = velocity.z;
            result[3] = right.x;
            result[4] = right.y;
            result[5] = right.z;
            result[6] = up.x;
            result[7] = up.y;
            result[8] = up.z;

            return result;
        };

        var scratchCartographic = new Cartographic();
        var scratchCartesian3Projection = new Cartesian3();
        var scratchCartesian3 = new Cartesian3();
        var scratchCartesian4Origin = new Cartesian4();
        var scratchCartesian4NewOrigin = new Cartesian4();
        var scratchCartesian4NewXAxis = new Cartesian4();
        var scratchCartesian4NewYAxis = new Cartesian4();
        var scratchCartesian4NewZAxis = new Cartesian4();
        var scratchFromENU = new Matrix4();
        var scratchToENU = new Matrix4();

        /**
         * @private
         */
        Transforms.basisTo2D = function (projection, matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(projection)) {
                throw new DeveloperError('projection is required.');
            }
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var ellipsoid = projection.ellipsoid;

            var origin = Matrix4.getColumn(matrix, 3, scratchCartesian4Origin);
            var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);

            var fromENU = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, scratchFromENU);
            var toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);

            var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
            var newOrigin = scratchCartesian4NewOrigin;
            newOrigin.x = projectedPosition.z;
            newOrigin.y = projectedPosition.x;
            newOrigin.z = projectedPosition.y;
            newOrigin.w = 1.0;

            var xAxis = Matrix4.getColumn(matrix, 0, scratchCartesian3);
            var xScale = Cartesian3.magnitude(xAxis);
            var newXAxis = Matrix4.multiplyByVector(toENU, xAxis, scratchCartesian4NewXAxis);
            Cartesian4.fromElements(newXAxis.z, newXAxis.x, newXAxis.y, 0.0, newXAxis);

            var yAxis = Matrix4.getColumn(matrix, 1, scratchCartesian3);
            var yScale = Cartesian3.magnitude(yAxis);
            var newYAxis = Matrix4.multiplyByVector(toENU, yAxis, scratchCartesian4NewYAxis);
            Cartesian4.fromElements(newYAxis.z, newYAxis.x, newYAxis.y, 0.0, newYAxis);

            var zAxis = Matrix4.getColumn(matrix, 2, scratchCartesian3);
            var zScale = Cartesian3.magnitude(zAxis);

            var newZAxis = scratchCartesian4NewZAxis;
            Cartesian3.cross(newXAxis, newYAxis, newZAxis);
            Cartesian3.normalize(newZAxis, newZAxis);
            Cartesian3.cross(newYAxis, newZAxis, newXAxis);
            Cartesian3.normalize(newXAxis, newXAxis);
            Cartesian3.cross(newZAxis, newXAxis, newYAxis);
            Cartesian3.normalize(newYAxis, newYAxis);

            Cartesian3.multiplyByScalar(newXAxis, xScale, newXAxis);
            Cartesian3.multiplyByScalar(newYAxis, yScale, newYAxis);
            Cartesian3.multiplyByScalar(newZAxis, zScale, newZAxis);

            Matrix4.setColumn(result, 0, newXAxis, result);
            Matrix4.setColumn(result, 1, newYAxis, result);
            Matrix4.setColumn(result, 2, newZAxis, result);
            Matrix4.setColumn(result, 3, newOrigin, result);

            return result;
        };

        return Transforms;
    }).call(this, $__require('57'), $__require('4e'), $__require('35'), $__require('4c'), $__require('44'), $__require('2c'), $__require('23'), $__require('25'), $__require('56'), $__require('58'), $__require('45'), $__require('66'), $__require('67'), $__require('2d'), $__require('30'), $__require('3b'), $__require('3c'), $__require('3d'), $__require('5b'));
});
/**
@license
sprintf.js from the php.js project - https://github.com/kvz/phpjs
Directly from https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js

php.js is copyright 2012 Kevin van Zonneveld.

Portions copyright Brett Zamir (http://brett-zamir.me), Kevin van Zonneveld
(http://kevin.vanzonneveld.net), Onno Marsman, Theriault, Michael White
(http://getsprink.com), Waldo Malqui Silva, Paulo Freitas, Jack, Jonas
Raoni Soares Silva (http://www.jsfromhell.com), Philip Peterson, Legaev
Andrey, Ates Goral (http://magnetiq.com), Alex, Ratheous, Martijn Wieringa,
Rafa? Kukawski (http://blog.kukawski.pl), lmeyrick
(https://sourceforge.net/projects/bcmath-js/), Nate, Philippe Baumann,
Enrique Gonzalez, Webtoolkit.info (http://www.webtoolkit.info/), Carlos R.
L. Rodrigues (http://www.jsfromhell.com), Ash Searle
(http://hexmen.com/blog/), Jani Hartikainen, travc, Ole Vrijenhoek,
Erkekjetter, Michael Grier, Rafa? Kukawski (http://kukawski.pl), Johnny
Mast (http://www.phpvrouwen.nl), T.Wild, d3x,
http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript,
Rafa? Kukawski (http://blog.kukawski.pl/), stag019, pilus, WebDevHobo
(http://webdevhobo.blogspot.com/), marrtins, GeekFG
(http://geekfg.blogspot.com), Andrea Giammarchi
(http://webreflection.blogspot.com), Arpad Ray (mailto:arpad@php.net),
gorthaur, Paul Smith, Tim de Koning (http://www.kingsquare.nl), Joris, Oleg
Eremeev, Steve Hilder, majak, gettimeofday, KELAN, Josh Fraser
(http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),
Marc Palau, Martin
(http://www.erlenwiese.de/), Breaking Par Consulting Inc
(http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),
Chris, Mirek Slugen, saulius, Alfonso Jimenez
(http://www.alfonsojimenez.com), Diplom@t (http://difane.com/), felix,
Mailfaker (http://www.weedem.fr/), Tyler Akins (http://rumkin.com), Caio
Ariede (http://caioariede.com), Robin, Kankrelune
(http://www.webfaktory.info/), Karol Kowalski, Imgen Tata
(http://www.myipdf.com/), mdsjack (http://www.mdsjack.bo.it), Dreamer,
Felix Geisendoerfer (http://www.debuggable.com/felix), Lars Fischer, AJ,
David, Aman Gupta, Michael White, Public Domain
(http://www.json.org/json2.js), Steven Levithan
(http://blog.stevenlevithan.com), Sakimori, Pellentesque Malesuada,
Thunder.m, Dj (http://phpjs.org/functions/htmlentities:425#comment_134018),
Steve Clay, David James, Francois, class_exists, nobbler, T. Wild, Itsacon
(http://www.itsacon.net/), date, Ole Vrijenhoek (http://www.nervous.nl/),
Fox, Raphael (Ao RUDLER), Marco, noname, Mateusz "loonquawl" Zalega, Frank
Forte, Arno, ger, mktime, john (http://www.jd-tech.net), Nick Kolosov
(http://sammy.ru), marc andreu, Scott Cariss, Douglas Crockford
(http://javascript.crockford.com), madipta, Slawomir Kaniecki,
ReverseSyntax, Nathan, Alex Wilson, kenneth, Bayron Guevara, Adam Wallner
(http://web2.bitbaro.hu/), paulo kuong, jmweb, Lincoln Ramsay, djmix,
Pyerre, Jon Hohle, Thiago Mata (http://thiagomata.blog.com), lmeyrick
(https://sourceforge.net/projects/bcmath-js/this.), Linuxworld, duncan,
Gilbert, Sanjoy Roy, Shingo, sankai, Oskar Larsson H?gfeldt
(http://oskar-lh.name/), Denny Wardhana, 0m3r, Everlasto, Subhasis Deb,
josh, jd, Pier Paolo Ramon (http://www.mastersoup.com/), P, merabi, Soren
Hansen, Eugene Bulkin (http://doubleaw.com/), Der Simon
(http://innerdom.sourceforge.net/), echo is bad, Ozh, XoraX
(http://www.xorax.info), EdorFaus, JB, J A R, Marc Jansen, Francesco, LH,
Stoyan Kyosev (http://www.svest.org/), nord_ua, omid
(http://phpjs.org/functions/380:380#comment_137122), Brad Touesnard, MeEtc
(http://yass.meetcweb.com), Peter-Paul Koch
(http://www.quirksmode.org/js/beat.html), Olivier Louvignes
(http://mg-crea.com/), T0bsn, Tim Wiel, Bryan Elliott, Jalal Berrami,
Martin, JT, David Randall, Thomas Beaucourt (http://www.webapp.fr), taith,
vlado houba, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian Nucleair
Research Centre), Martin Pool, Kirk Strobeck, Rick Waldron, Brant Messenger
(http://www.brantmessenger.com/), Devan Penner-Woelk, Saulo Vallory, Wagner
B. Soares, Artur Tchernychev, Valentina De Rosa, Jason Wong
(http://carrot.org/), Christoph, Daniel Esteban, strftime, Mick@el, rezna,
Simon Willison (http://simonwillison.net), Anton Ongson, Gabriel Paderni,
Marco van Oort, penutbutterjelly, Philipp Lenssen, Bjorn Roesbeke
(http://www.bjornroesbeke.be/), Bug?, Eric Nagel, Tomasz Wesolowski,
Evertjan Garretsen, Bobby Drake, Blues (http://tech.bluesmoon.info/), Luke
Godfrey, Pul, uestla, Alan C, Ulrich, Rafal Kukawski, Yves Sucaet,
sowberry, Norman "zEh" Fuchs, hitwork, Zahlii, johnrembo, Nick Callen,
Steven Levithan (stevenlevithan.com), ejsanders, Scott Baker, Brian Tafoya
(http://www.premasolutions.com/), Philippe Jausions
(http://pear.php.net/user/jausions), Aidan Lister
(http://aidanlister.com/), Rob, e-mike, HKM, ChaosNo1, metjay, strcasecmp,
strcmp, Taras Bogach, jpfle, Alexander Ermolaev
(http://snippets.dzone.com/user/AlexanderErmolaev), DxGx, kilops, Orlando,
dptr1988, Le Torbi, James (http://www.james-bell.co.uk/), Pedro Tainha
(http://www.pedrotainha.com), James, Arnout Kazemier
(http://www.3rd-Eden.com), Chris McMacken, gabriel paderni, Yannoo,
FGFEmperor, baris ozdil, Tod Gentille, Greg Frazier, jakes, 3D-GRAF, Allan
Jensen (http://www.winternet.no), Howard Yeend, Benjamin Lupton, davook,
daniel airton wermann (http://wermann.com.br), Atli T¨®r, Maximusya, Ryan
W Tenney (http://ryan.10e.us), Alexander M Beedie, fearphage
(http://http/my.opera.com/fearphage/), Nathan Sepulveda, Victor, Matteo,
Billy, stensi, Cord, Manish, T.J. Leahy, Riddler
(http://www.frontierwebdev.com/), Rafa? Kukawski, FremyCompany, Matt
Bradley, Tim de Koning, Luis Salazar (http://www.freaky-media.com/), Diogo
Resende, Rival, Andrej Pavlovic, Garagoth, Le Torbi
(http://www.letorbi.de/), Dino, Josep Sanz (http://www.ws3.es/), rem,
Russell Walker (http://www.nbill.co.uk/), Jamie Beck
(http://www.terabit.ca/), setcookie, Michael, YUI Library:
http://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Blues at
http://hacks.bluesmoon.info/strftime/strftime.js, Ben
(http://benblume.co.uk/), DtTvB
(http://dt.in.th/2008-09-16.string-length-in-bytes.html), Andreas, William,
meo, incidence, Cagri Ekin, Amirouche, Amir Habibi
(http://www.residence-mixte.com/), Luke Smith (http://lucassmith.name),
Kheang Hok Chin (http://www.distantia.ca/), Jay Klehr, Lorenzo Pisani,
Tony, Yen-Wei Liu, Greenseed, mk.keck, Leslie Hoare, dude, booeyOH, Ben
Bryan

Licensed under the MIT (MIT-LICENSE.txt) license.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

/*global define*/
$__System.registerDynamic('6a', [], false, function ($__require, $__exports, $__module) {
  return (function () {

    function sprintf() {
      // http://kevin.vanzonneveld.net
      // +   original by: Ash Searle (http://hexmen.com/blog/)
      // + namespaced by: Michael White (http://getsprink.com)
      // +    tweaked by: Jack
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +      input by: Paulo Freitas
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +      input by: Brett Zamir (http://brett-zamir.me)
      // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
      // +   improved by: Dj
      // +   improved by: Allidylls
      // *     example 1: sprintf("%01.2f", 123.1);
      // *     returns 1: 123.10
      // *     example 2: sprintf("[%10s]", 'monkey');
      // *     returns 2: '[    monkey]'
      // *     example 3: sprintf("[%'#10s]", 'monkey');
      // *     returns 3: '[####monkey]'
      // *     example 4: sprintf("%d", 123456789012345);
      // *     returns 4: '123456789012345'
      var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
      var a = arguments,
          i = 0,
          format = a[i++];

      // pad()
      var pad = function (str, len, chr, leftJustify) {
        if (!chr) {
          chr = ' ';
        }

        var padding = str.length >= len ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
      };

      // justify()
      var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
        var diff = minWidth - value.length;
        if (diff > 0) {
          if (leftJustify || !zeroPad) {
            value = pad(value, minWidth, customPadChar, leftJustify);
          } else {
            value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
          }
        }
        return value;
      };

      // formatBaseX()
      var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        // Note: casts negative numbers to positive ones
        var number = value >>> 0;
        prefix = prefix && number && {
          '2': '0b',
          '8': '0',
          '16': '0x'
        }[base] || '';
        value = prefix + pad(number.toString(base), precision || 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
      };

      // formatString()
      var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
        if (precision != null) {
          value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
      };

      // doFormat()
      var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
        var number;
        var prefix;
        var method;
        var textTransform;
        var value;

        if (substring == '%%') {
          return '%';
        }

        // parse flags
        var leftJustify = false,
            positivePrefix = '',
            zeroPad = false,
            prefixBaseX = false,
            customPadChar = ' ';
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) {
          switch (flags.charAt(j)) {
            case ' ':
              positivePrefix = ' ';
              break;
            case '+':
              positivePrefix = '+';
              break;
            case '-':
              leftJustify = true;
              break;
            case "'":
              customPadChar = flags.charAt(j + 1);
              break;
            case '0':
              zeroPad = true;
              break;
            case '#':
              prefixBaseX = true;
              break;
          }
        }

        // parameters may be null, undefined, empty-string or real valued
        // we want to ignore null, undefined and empty-string values
        if (!minWidth) {
          minWidth = 0;
        } else if (minWidth == '*') {
          minWidth = +a[i++];
        } else if (minWidth.charAt(0) == '*') {
          minWidth = +a[minWidth.slice(1, -1)];
        } else {
          minWidth = +minWidth;
        }

        // Note: undocumented perl feature:
        if (minWidth < 0) {
          minWidth = -minWidth;
          leftJustify = true;
        }

        if (!isFinite(minWidth)) {
          throw new Error('sprintf: (minimum-)width must be finite');
        }

        if (!precision) {
          precision = 'fFeE'.indexOf(type) > -1 ? 6 : type == 'd' ? 0 : undefined;
        } else if (precision == '*') {
          precision = +a[i++];
        } else if (precision.charAt(0) == '*') {
          precision = +a[precision.slice(1, -1)];
        } else {
          precision = +precision;
        }

        // grab value using valueIndex if required?
        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

        switch (type) {
          case 's':
            return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
          case 'c':
            return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
          case 'b':
            return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
          case 'o':
            return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
          case 'x':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
          case 'X':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
          case 'u':
            return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
          case 'i':
          case 'd':
            number = +value || 0;
            number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate
            prefix = number < 0 ? '-' : positivePrefix;
            value = prefix + pad(String(Math.abs(number)), precision, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
          case 'e':
          case 'E':
          case 'f': // Should handle locales (as per setlocale)
          case 'F':
          case 'g':
          case 'G':
            number = +value;
            prefix = number < 0 ? '-' : positivePrefix;
            method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
            textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
            value = prefix + Math.abs(number)[method](precision);
            return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
          default:
            return substring;
        }
      };

      return format.replace(regex, doFormat);
    }

    return sprintf;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('55', ['23', '25'], false, function ($__require, $__exports, $__module) {
    return (function (defined, DeveloperError) {
        'use strict';

        /**
         * Finds an item in a sorted array.
         *
         * @exports binarySearch
         *
         * @param {Array} array The sorted array to search.
         * @param {Object} itemToFind The item to find in the array.
         * @param {binarySearch~Comparator} comparator The function to use to compare the item to
         *        elements in the array.
         * @returns {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
         *        does not exist, the return value is a negative number which is the bitwise complement (~)
         *        of the index before which the itemToFind should be inserted in order to maintain the
         *        sorted order of the array.
         *
         * @example
         * // Create a comparator function to search through an array of numbers.
         * function comparator(a, b) {
         *     return a - b;
         * };
         * var numbers = [0, 2, 4, 6, 8];
         * var index = Cesium.binarySearch(numbers, 6, comparator); // 3
         */

        function binarySearch(array, itemToFind, comparator) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required.');
            }
            if (!defined(itemToFind)) {
                throw new DeveloperError('itemToFind is required.');
            }
            if (!defined(comparator)) {
                throw new DeveloperError('comparator is required.');
            }
            //>>includeEnd('debug');

            var low = 0;
            var high = array.length - 1;
            var i;
            var comparison;

            while (low <= high) {
                i = ~~((low + high) / 2);
                comparison = comparator(array[i], itemToFind);
                if (comparison < 0) {
                    low = i + 1;
                    continue;
                }
                if (comparison > 0) {
                    high = i - 1;
                    continue;
                }
                return i;
            }
            return ~(high + 1);
        }

        /**
         * A function used to compare two items while performing a binary search.
         * @callback binarySearch~Comparator
         *
         * @param {Object} a An item in the array.
         * @param {Object} b The item being searched for.
         * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,
         *          a positive value if <code>a</code> is greater than <code>b</code>, or
         *          0 if <code>a</code> is equal to <code>b</code>.
         *
         * @example
         * function compareNumbers(a, b) {
         *     return a - b;
         * }
         */

        return binarySearch;
    }).call(this, $__require('23'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('6b', [], false, function ($__require, $__exports, $__module) {
  return (function () {
    'use strict';

    /**
     * Represents a Gregorian date in a more precise format than the JavaScript Date object.
     * In addition to submillisecond precision, this object can also represent leap seconds.
     * @alias GregorianDate
     * @constructor
     *
     * @see JulianDate#toGregorianDate
     */

    function GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond) {
      /**
       * Gets or sets the year as a whole number.
       * @type {Number}
       */
      this.year = year;
      /**
       * Gets or sets the month as a whole number with range [1, 12].
       * @type {Number}
       */
      this.month = month;
      /**
       * Gets or sets the day of the month as a whole number starting at 1.
       * @type {Number}
       */
      this.day = day;
      /**
       * Gets or sets the hour as a whole number with range [0, 23].
       * @type {Number}
       */
      this.hour = hour;
      /**
       * Gets or sets the minute of the hour as a whole number with range [0, 59].
       * @type {Number}
       */
      this.minute = minute;
      /**
       * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
       * @type {Number}
       */
      this.second = second;
      /**
       * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
       * @type {Number}
       */
      this.millisecond = millisecond;
      /**
       * Gets or sets whether this time is during a leap second.
       * @type {Boolean}
       */
      this.isLeapSecond = isLeapSecond;
    }

    return GregorianDate;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('6c', ['25'], false, function ($__require, $__exports, $__module) {
    return (function (DeveloperError) {
        'use strict';

        /**
         * Determines if a given date is a leap year.
         *
         * @exports isLeapYear
         *
         * @param {Number} year The year to be tested.
         * @returns {Boolean} True if <code>year</code> is a leap year.
         *
         * @example
         * var leapYear = Cesium.isLeapYear(2000); // true
         */

        function isLeapYear(year) {
            //>>includeStart('debug', pragmas.debug);
            if (year === null || isNaN(year)) {
                throw new DeveloperError('year is required and must be a number.');
            }
            //>>includeEnd('debug');

            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }

        return isLeapYear;
    }).call(this, $__require('25'));
});
/*global define*/
$__System.registerDynamic('59', [], false, function ($__require, $__exports, $__module) {
  return (function () {
    'use strict';

    /**
     * Describes a single leap second, which is constructed from a {@link JulianDate} and a
     * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
     * @alias LeapSecond
     * @constructor
     *
     * @param {JulianDate} [date] A Julian date representing the time of the leap second.
     * @param {Number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.
     */

    function LeapSecond(date, offset) {
      /**
       * Gets or sets the date at which this leap second occurs.
       * @type {JulianDate}
       */
      this.julianDate = date;

      /**
       * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
       * of this leap second.
       * @type {Number}
       */
      this.offset = offset;
    }

    return LeapSecond;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('2d', ['6a', '55', '2c', '23', '25', '6b', '6c', '59', '5b', '5c'], false, function ($__require, $__exports, $__module) {
    return (function (sprintf, binarySearch, defaultValue, defined, DeveloperError, GregorianDate, isLeapYear, LeapSecond, TimeConstants, TimeStandard) {
        'use strict';

        var gregorianDateScratch = new GregorianDate();
        var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var daysInLeapFeburary = 29;

        function compareLeapSecondDates(leapSecond, dateToFind) {
            return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
        }

        // we don't really need a leap second instance, anything with a julianDate property will do
        var binarySearchScratchLeapSecond = new LeapSecond();

        function convertUtcToTai(julianDate) {
            //Even though julianDate is in UTC, we'll treat it as TAI and
            //search the leap second table for it.
            binarySearchScratchLeapSecond.julianDate = julianDate;
            var leapSeconds = JulianDate.leapSeconds;
            var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);

            if (index < 0) {
                index = ~index;
            }

            if (index >= leapSeconds.length) {
                index = leapSeconds.length - 1;
            }

            var offset = leapSeconds[index].offset;
            if (index > 0) {
                //Now we have the index of the closest leap second that comes on or after our UTC time.
                //However, if the difference between the UTC date being converted and the TAI
                //defined leap second is greater than the offset, we are off by one and need to use
                //the previous leap second.
                var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
                if (difference > offset) {
                    index--;
                    offset = leapSeconds[index].offset;
                }
            }

            JulianDate.addSeconds(julianDate, offset, julianDate);
        }

        function convertTaiToUtc(julianDate, result) {
            binarySearchScratchLeapSecond.julianDate = julianDate;
            var leapSeconds = JulianDate.leapSeconds;
            var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
            if (index < 0) {
                index = ~index;
            }

            //All times before our first leap second get the first offset.
            if (index === 0) {
                return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
            }

            //All times after our leap second get the last offset.
            if (index >= leapSeconds.length) {
                return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);
            }

            //Compute the difference between the found leap second and the time we are converting.
            var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);

            if (difference === 0) {
                //The date is in our leap second table.
                return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);
            }

            if (difference <= 1.0) {
                //The requested date is during the moment of a leap second, then we cannot convert to UTC
                return undefined;
            }

            //The time is in between two leap seconds, index is the leap second after the date
            //we're converting, so we subtract one to get the correct LeapSecond instance.
            return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);
        }

        function setComponents(wholeDays, secondsOfDay, julianDate) {
            var extraDays = secondsOfDay / TimeConstants.SECONDS_PER_DAY | 0;
            wholeDays += extraDays;
            secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;

            if (secondsOfDay < 0) {
                wholeDays--;
                secondsOfDay += TimeConstants.SECONDS_PER_DAY;
            }

            julianDate.dayNumber = wholeDays;
            julianDate.secondsOfDay = secondsOfDay;
            return julianDate;
        }

        function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
            // Algorithm from page 604 of the Explanatory Supplement to the
            // Astronomical Almanac (Seidelmann 1992).

            var a = (month - 14) / 12 | 0;
            var b = year + 4800 + a;
            var dayNumber = (1461 * b / 4 | 0) + (367 * (month - 2 - 12 * a) / 12 | 0) - (3 * ((b + 100) / 100 | 0) / 4 | 0) + day - 32075;

            // JulianDates are noon-based
            hour = hour - 12;
            if (hour < 0) {
                hour += 24;
            }

            var secondsOfDay = second + (hour * TimeConstants.SECONDS_PER_HOUR + minute * TimeConstants.SECONDS_PER_MINUTE + millisecond * TimeConstants.SECONDS_PER_MILLISECOND);

            if (secondsOfDay >= 43200.0) {
                dayNumber -= 1;
            }

            return [dayNumber, secondsOfDay];
        }

        //Regular expressions used for ISO8601 date parsing.
        //YYYY
        var matchCalendarYear = /^(\d{4})$/;
        //YYYY-MM (YYYYMM is invalid)
        var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
        //YYYY-DDD or YYYYDDD
        var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
        //YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD
        var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
        //YYYY-MM-DD or YYYYMMDD
        var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
        // Match utc offset
        var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
        // Match hours HH or HH.xxxxx
        var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
        // Match hours/minutes HH:MM HHMM.xxxxx
        var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
        // Match hours/minutes HH:MM:SS HHMMSS.xxxxx
        var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;

        var iso8601ErrorMessage = 'Invalid ISO 8601 date.';

        /**
         * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
         * For increased precision, this class stores the whole number part of the date and the seconds
         * part of the date in separate components.  In order to be safe for arithmetic and represent
         * leap seconds, the date is always stored in the International Atomic Time standard
         * {@link TimeStandard.TAI}.
         * @alias JulianDate
         * @constructor
         *
         * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
         * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
         * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.
         */
        function JulianDate(julianDayNumber, secondsOfDay, timeStandard) {
            /**
             * Gets or sets the number of whole days.
             * @type {Number}
             */
            this.dayNumber = undefined;

            /**
             * Gets or sets the number of seconds into the current day.
             * @type {Number}
             */
            this.secondsOfDay = undefined;

            julianDayNumber = defaultValue(julianDayNumber, 0.0);
            secondsOfDay = defaultValue(secondsOfDay, 0.0);
            timeStandard = defaultValue(timeStandard, TimeStandard.UTC);

            //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.
            var wholeDays = julianDayNumber | 0;
            secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;

            setComponents(wholeDays, secondsOfDay, this);

            if (timeStandard === TimeStandard.UTC) {
                convertUtcToTai(this);
            }
        }

        /**
         * Creates a new instance from a JavaScript Date.
         *
         * @param {Date} date A JavaScript Date.
         * @param {JulianDate} [result] An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
         *
         * @exception {DeveloperError} date must be a valid JavaScript Date.
         */
        JulianDate.fromDate = function (date, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!(date instanceof Date) || isNaN(date.getTime())) {
                throw new DeveloperError('date must be a valid JavaScript Date.');
            }
            //>>includeEnd('debug');

            var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
            if (!defined(result)) {
                return new JulianDate(components[0], components[1], TimeStandard.UTC);
            }
            setComponents(components[0], components[1], result);
            convertUtcToTai(result);
            return result;
        };

        /**
         * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
         * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
         * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
         *
         * @param {String} iso8601String An ISO 8601 date.
         * @param {JulianDate} [result] An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
         *
         * @exception {DeveloperError} Invalid ISO 8601 date.
         */
        JulianDate.fromIso8601 = function (iso8601String, result) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof iso8601String !== 'string') {
                throw new DeveloperError(iso8601ErrorMessage);
            }
            //>>includeEnd('debug');

            //Comma and decimal point both indicate a fractional number according to ISO 8601,
            //start out by blanket replacing , with . which is the only valid such symbol in JS.
            iso8601String = iso8601String.replace(',', '.');

            //Split the string into its date and time components, denoted by a mandatory T
            var tokens = iso8601String.split('T');
            var year;
            var month = 1;
            var day = 1;
            var hour = 0;
            var minute = 0;
            var second = 0;
            var millisecond = 0;

            //Lacking a time is okay, but a missing date is illegal.
            var date = tokens[0];
            var time = tokens[1];
            var tmp;
            var inLeapYear;
            if (!defined(date)) {
                throw new DeveloperError(iso8601ErrorMessage);
            }

            var dashCount;

            //First match the date against possible regular expressions.
            tokens = date.match(matchCalendarDate);
            if (tokens !== null) {
                dashCount = date.split('-').length - 1;
                if (dashCount > 0 && dashCount !== 2) {
                    throw new DeveloperError(iso8601ErrorMessage);
                }
                year = +tokens[1];
                month = +tokens[2];
                day = +tokens[3];
            } else {
                tokens = date.match(matchCalendarMonth);
                if (tokens !== null) {
                    year = +tokens[1];
                    month = +tokens[2];
                } else {
                    tokens = date.match(matchCalendarYear);
                    if (tokens !== null) {
                        year = +tokens[1];
                    } else {
                        //Not a year/month/day so it must be an ordinal date.
                        var dayOfYear;
                        tokens = date.match(matchOrdinalDate);
                        if (tokens !== null) {

                            year = +tokens[1];
                            dayOfYear = +tokens[2];
                            inLeapYear = isLeapYear(year);

                            //This validation is only applicable for this format.
                            if (dayOfYear < 1 || inLeapYear && dayOfYear > 366 || !inLeapYear && dayOfYear > 365) {
                                throw new DeveloperError(iso8601ErrorMessage);
                            }
                        } else {
                            tokens = date.match(matchWeekDate);
                            if (tokens !== null) {
                                //ISO week date to ordinal date from
                                //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775
                                year = +tokens[1];
                                var weekNumber = +tokens[2];
                                var dayOfWeek = +tokens[3] || 0;

                                dashCount = date.split('-').length - 1;
                                if (dashCount > 0 && (!defined(tokens[3]) && dashCount !== 1 || defined(tokens[3]) && dashCount !== 2)) {
                                    throw new DeveloperError(iso8601ErrorMessage);
                                }

                                var january4 = new Date(Date.UTC(year, 0, 4));
                                dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;
                            } else {
                                //None of our regular expressions succeeded in parsing the date properly.
                                throw new DeveloperError(iso8601ErrorMessage);
                            }
                        }
                        //Split an ordinal date into month/day.
                        tmp = new Date(Date.UTC(year, 0, 1));
                        tmp.setUTCDate(dayOfYear);
                        month = tmp.getUTCMonth() + 1;
                        day = tmp.getUTCDate();
                    }
                }
            }

            //Now that we have all of the date components, validate them to make sure nothing is out of range.
            inLeapYear = isLeapYear(year);
            if (month < 1 || month > 12 || day < 1 || (month !== 2 || !inLeapYear) && day > daysInMonth[month - 1] || inLeapYear && month === 2 && day > daysInLeapFeburary) {
                throw new DeveloperError(iso8601ErrorMessage);
            }

            //Not move onto the time string, which is much simpler.
            var offsetIndex;
            if (defined(time)) {
                tokens = time.match(matchHoursMinutesSeconds);
                if (tokens !== null) {
                    dashCount = time.split(':').length - 1;
                    if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }

                    hour = +tokens[1];
                    minute = +tokens[2];
                    second = +tokens[3];
                    millisecond = +(tokens[4] || 0) * 1000.0;
                    offsetIndex = 5;
                } else {
                    tokens = time.match(matchHoursMinutes);
                    if (tokens !== null) {
                        dashCount = time.split(':').length - 1;
                        if (dashCount > 2) {
                            throw new DeveloperError(iso8601ErrorMessage);
                        }

                        hour = +tokens[1];
                        minute = +tokens[2];
                        second = +(tokens[3] || 0) * 60.0;
                        offsetIndex = 4;
                    } else {
                        tokens = time.match(matchHours);
                        if (tokens !== null) {
                            hour = +tokens[1];
                            minute = +(tokens[2] || 0) * 60.0;
                            offsetIndex = 3;
                        } else {
                            throw new DeveloperError(iso8601ErrorMessage);
                        }
                    }
                }

                //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.
                if (minute >= 60 || second >= 61 || hour > 24 || hour === 24 && (minute > 0 || second > 0 || millisecond > 0)) {
                    throw new DeveloperError(iso8601ErrorMessage);
                }

                //Check the UTC offset value, if no value exists, use local time
                //a Z indicates UTC, + or - are offsets.
                var offset = tokens[offsetIndex];
                var offsetHours = +tokens[offsetIndex + 1];
                var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
                switch (offset) {
                    case '+':
                        hour = hour - offsetHours;
                        minute = minute - offsetMinutes;
                        break;
                    case '-':
                        hour = hour + offsetHours;
                        minute = minute + offsetMinutes;
                        break;
                    case 'Z':
                        break;
                    default:
                        minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();
                        break;
                }
            } else {
                //If no time is specified, it is considered the beginning of the day, local time.
                minute = minute + new Date(year, month - 1, day).getTimezoneOffset();
            }

            //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.
            //If that's the case, we need to temporarily subtract a second in order to build a UTC date.
            //Then we add it back in after converting to TAI.
            var isLeapSecond = second === 60;
            if (isLeapSecond) {
                second--;
            }

            //Even if we successfully parsed the string into its components, after applying UTC offset or
            //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.

            //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes
            while (minute >= 60) {
                minute -= 60;
                hour++;
            }

            while (hour >= 24) {
                hour -= 24;
                day++;
            }

            tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
            while (day > tmp) {
                day -= tmp;
                month++;

                if (month > 12) {
                    month -= 12;
                    year++;
                }

                tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
            }

            //If UTC offset is at the beginning/end of the day, minutes can be negative.
            while (minute < 0) {
                minute += 60;
                hour--;
            }

            while (hour < 0) {
                hour += 24;
                day--;
            }

            while (day < 1) {
                month--;
                if (month < 1) {
                    month += 12;
                    year--;
                }

                tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
                day += tmp;
            }

            //Now create the JulianDate components from the Gregorian date and actually create our instance.
            var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);

            if (!defined(result)) {
                result = new JulianDate(components[0], components[1], TimeStandard.UTC);
            } else {
                setComponents(components[0], components[1], result);
                convertUtcToTai(result);
            }

            //If we were on a leap second, add it back.
            if (isLeapSecond) {
                JulianDate.addSeconds(result, 1, result);
            }

            return result;
        };

        /**
         * Creates a new instance that represents the current system time.
         * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
         *
         * @param {JulianDate} [result] An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
         */
        JulianDate.now = function (result) {
            return JulianDate.fromDate(new Date(), result);
        };

        var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);

        /**
         * Creates a {@link GregorianDate} from the provided instance.
         *
         * @param {JulianDate} julianDate The date to be converted.
         * @param {GregorianDate} [result] An existing instance to use for the result.
         * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.
         */
        JulianDate.toGregorianDate = function (julianDate, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            //>>includeEnd('debug');

            var isLeapSecond = false;
            var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
            if (!defined(thisUtc)) {
                //Conversion to UTC will fail if we are during a leap second.
                //If that's the case, subtract a second and convert again.
                //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.
                JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
                thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
                isLeapSecond = true;
            }

            var julianDayNumber = thisUtc.dayNumber;
            var secondsOfDay = thisUtc.secondsOfDay;

            if (secondsOfDay >= 43200.0) {
                julianDayNumber += 1;
            }

            // Algorithm from page 604 of the Explanatory Supplement to the
            // Astronomical Almanac (Seidelmann 1992).
            var L = julianDayNumber + 68569 | 0;
            var N = 4 * L / 146097 | 0;
            L = L - ((146097 * N + 3) / 4 | 0) | 0;
            var I = 4000 * (L + 1) / 1461001 | 0;
            L = L - (1461 * I / 4 | 0) + 31 | 0;
            var J = 80 * L / 2447 | 0;
            var day = L - (2447 * J / 80 | 0) | 0;
            L = J / 11 | 0;
            var month = J + 2 - 12 * L | 0;
            var year = 100 * (N - 49) + I + L | 0;

            var hour = secondsOfDay / TimeConstants.SECONDS_PER_HOUR | 0;
            var remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;
            var minute = remainingSeconds / TimeConstants.SECONDS_PER_MINUTE | 0;
            remainingSeconds = remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;
            var second = remainingSeconds | 0;
            var millisecond = (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;

            // JulianDates are noon-based
            hour += 12;
            if (hour > 23) {
                hour -= 24;
            }

            //If we were on a leap second, add it back.
            if (isLeapSecond) {
                second += 1;
            }

            if (!defined(result)) {
                return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);
            }

            result.year = year;
            result.month = month;
            result.day = day;
            result.hour = hour;
            result.minute = minute;
            result.second = second;
            result.millisecond = millisecond;
            result.isLeapSecond = isLeapSecond;
            return result;
        };

        /**
         * Creates a JavaScript Date from the provided instance.
         * Since JavaScript dates are only accurate to the nearest millisecond and
         * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
         * If the provided JulianDate is during a leap second, the previous second is used.
         *
         * @param {JulianDate} julianDate The date to be converted.
         * @returns {Date} A new instance representing the provided date.
         */
        JulianDate.toDate = function (julianDate) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            //>>includeEnd('debug');

            var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
            var second = gDate.second;
            if (gDate.isLeapSecond) {
                second -= 1;
            }
            return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));
        };

        /**
         * Creates an ISO8601 representation of the provided date.
         *
         * @param {JulianDate} julianDate The date to be converted.
         * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
         * @returns {String} The ISO8601 representation of the provided date.
         */
        JulianDate.toIso8601 = function (julianDate, precision) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            //>>includeEnd('debug');

            var gDate = JulianDate.toGregorianDate(julianDate, gDate);
            var millisecondStr;

            if (!defined(precision) && gDate.millisecond !== 0) {
                //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.
                millisecondStr = (gDate.millisecond * 0.01).toString().replace('.', '');
                return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
            }

            //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely
            if (!defined(precision) || precision === 0) {
                return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second);
            }

            //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.
            millisecondStr = (gDate.millisecond * 0.01).toFixed(precision).replace('.', '').slice(0, precision);
            return sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
        };

        /**
         * Duplicates a JulianDate instance.
         *
         * @param {JulianDate} julianDate The date to duplicate.
         * @param {JulianDate} [result] An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.
         */
        JulianDate.clone = function (julianDate, result) {
            if (!defined(julianDate)) {
                return undefined;
            }
            if (!defined(result)) {
                return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);
            }
            result.dayNumber = julianDate.dayNumber;
            result.secondsOfDay = julianDate.secondsOfDay;
            return result;
        };

        /**
         * Compares two instances.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.
         */
        JulianDate.compare = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required.');
            }
            //>>includeEnd('debug');

            var julianDayNumberDifference = left.dayNumber - right.dayNumber;
            if (julianDayNumberDifference !== 0) {
                return julianDayNumberDifference;
            }
            return left.secondsOfDay - right.secondsOfDay;
        };

        /**
         * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {JulianDate} [left] The first instance.
         * @param {JulianDate} [right] The second instance.
         * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
         */
        JulianDate.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay;
        };

        /**
         * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
         * each other.  That is, in order for the dates to be considered equal (and for
         * this function to return <code>true</code>), the absolute value of the difference between them, in
         * seconds, must be less than <code>epsilon</code>.
         *
         * @param {JulianDate} [left] The first instance.
         * @param {JulianDate} [right] The second instance.
         * @param {Number} epsilon The maximum number of seconds that should separate the two instances.
         * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
         */
        JulianDate.equalsEpsilon = function (left, right, epsilon) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(epsilon)) {
                throw new DeveloperError('epsilon is required.');
            }
            //>>includeEnd('debug');

            return left === right || defined(left) && defined(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon;
        };

        /**
         * Computes the total number of whole and fractional days represented by the provided instance.
         *
         * @param {JulianDate} julianDate The date.
         * @returns {Number} The Julian date as single floating point number.
         */
        JulianDate.totalDays = function (julianDate) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            //>>includeEnd('debug');
            return julianDate.dayNumber + julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY;
        };

        /**
         * Computes the difference in seconds between the provided instance.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.
         */
        JulianDate.secondsDifference = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required.');
            }
            //>>includeEnd('debug');

            var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;
            return dayDifference + (left.secondsOfDay - right.secondsOfDay);
        };

        /**
         * Computes the difference in days between the provided instance.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.
         */
        JulianDate.daysDifference = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required.');
            }
            //>>includeEnd('debug');

            var dayDifference = left.dayNumber - right.dayNumber;
            var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
            return dayDifference + secondDifference;
        };

        /**
         * Computes the number of seconds the provided instance is ahead of UTC.
         *
         * @param {JulianDate} julianDate The date.
         * @returns {Number} The number of seconds the provided instance is ahead of UTC
         */
        JulianDate.computeTaiMinusUtc = function (julianDate) {
            binarySearchScratchLeapSecond.julianDate = julianDate;
            var leapSeconds = JulianDate.leapSeconds;
            var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
            if (index < 0) {
                index = ~index;
                --index;
                if (index < 0) {
                    index = 0;
                }
            }
            return leapSeconds[index].offset;
        };

        /**
         * Adds the provided number of seconds to the provided date instance.
         *
         * @param {JulianDate} julianDate The date.
         * @param {Number} seconds The number of seconds to add or subtract.
         * @param {JulianDate} result An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter.
         */
        JulianDate.addSeconds = function (julianDate, seconds, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            if (!defined(seconds)) {
                throw new DeveloperError('seconds is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);
        };

        /**
         * Adds the provided number of minutes to the provided date instance.
         *
         * @param {JulianDate} julianDate The date.
         * @param {Number} minutes The number of minutes to add or subtract.
         * @param {JulianDate} result An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter.
         */
        JulianDate.addMinutes = function (julianDate, minutes, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            if (!defined(minutes)) {
                throw new DeveloperError('minutes is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var newSecondsOfDay = julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;
            return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
        };

        /**
         * Adds the provided number of hours to the provided date instance.
         *
         * @param {JulianDate} julianDate The date.
         * @param {Number} hours The number of hours to add or subtract.
         * @param {JulianDate} result An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter.
         */
        JulianDate.addHours = function (julianDate, hours, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            if (!defined(hours)) {
                throw new DeveloperError('hours is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var newSecondsOfDay = julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;
            return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
        };

        /**
         * Adds the provided number of days to the provided date instance.
         *
         * @param {JulianDate} julianDate The date.
         * @param {Number} days The number of days to add or subtract.
         * @param {JulianDate} result An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter.
         */
        JulianDate.addDays = function (julianDate, days, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(julianDate)) {
                throw new DeveloperError('julianDate is required.');
            }
            if (!defined(days)) {
                throw new DeveloperError('days is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var newJulianDayNumber = julianDate.dayNumber + days;
            return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
        };

        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
         */
        JulianDate.lessThan = function (left, right) {
            return JulianDate.compare(left, right) < 0;
        };

        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
         */
        JulianDate.lessThanOrEquals = function (left, right) {
            return JulianDate.compare(left, right) <= 0;
        };

        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
         */
        JulianDate.greaterThan = function (left, right) {
            return JulianDate.compare(left, right) > 0;
        };

        /**
         * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
         *
         * @param {JulianDate} left The first instance.
         * @param {JulianDate} right The second instance.
         * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
         */
        JulianDate.greaterThanOrEquals = function (left, right) {
            return JulianDate.compare(left, right) >= 0;
        };

        /**
         * Duplicates this instance.
         *
         * @param {JulianDate} [result] An existing instance to use for the result.
         * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
         */
        JulianDate.prototype.clone = function (result) {
            return JulianDate.clone(this, result);
        };

        /**
         * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {JulianDate} [right] The second instance.
         * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
         */
        JulianDate.prototype.equals = function (right) {
            return JulianDate.equals(this, right);
        };

        /**
         * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
         * each other.  That is, in order for the dates to be considered equal (and for
         * this function to return <code>true</code>), the absolute value of the difference between them, in
         * seconds, must be less than <code>epsilon</code>.
         *
         * @param {JulianDate} [right] The second instance.
         * @param {Number} epsilon The maximum number of seconds that should separate the two instances.
         * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
         */
        JulianDate.prototype.equalsEpsilon = function (right, epsilon) {
            return JulianDate.equalsEpsilon(this, right, epsilon);
        };

        /**
         * Creates a string representing this date in ISO8601 format.
         *
         * @returns {String} A string representing this date in ISO8601 format.
         */
        JulianDate.prototype.toString = function () {
            return JulianDate.toIso8601(this);
        };

        /**
         * Gets or sets the list of leap seconds used throughout Cesium.
         * @memberof JulianDate
         * @type {LeapSecond[]}
         */
        JulianDate.leapSeconds = [new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC
        new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC
        new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC
        new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC
        new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC
        new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC
        new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC
        new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC
        new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC
        new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC
        new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC
        new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC
        new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC
        new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC
        new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC
        new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC
        new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC
        new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC
        new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC
        new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC
        new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC
        new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC
        new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC
        new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC
        new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC
        new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC
        new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36) // July 1, 2015 00:00:00 UTC
        ];

        return JulianDate;
    }).call(this, $__require('6a'), $__require('55'), $__require('2c'), $__require('23'), $__require('25'), $__require('6b'), $__require('6c'), $__require('59'), $__require('5b'), $__require('5c'));
});
/*global define*/
$__System.registerDynamic('5b', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * Constants for time conversions like those done by {@link JulianDate}.
     *
     * @exports TimeConstants
     *
     * @see JulianDate
     *
     * @private
     */

    var TimeConstants = {
      /**
       * The number of seconds in one millisecond: <code>0.001</code>
       * @type {Number}
       * @constant
       */
      SECONDS_PER_MILLISECOND: 0.001,

      /**
       * The number of seconds in one minute: <code>60</code>.
       * @type {Number}
       * @constant
       */
      SECONDS_PER_MINUTE: 60.0,

      /**
       * The number of minutes in one hour: <code>60</code>.
       * @type {Number}
       * @constant
       */
      MINUTES_PER_HOUR: 60.0,

      /**
       * The number of hours in one day: <code>24</code>.
       * @type {Number}
       * @constant
       */
      HOURS_PER_DAY: 24.0,

      /**
       * The number of seconds in one hour: <code>3600</code>.
       * @type {Number}
       * @constant
       */
      SECONDS_PER_HOUR: 3600.0,

      /**
       * The number of minutes in one day: <code>1440</code>.
       * @type {Number}
       * @constant
       */
      MINUTES_PER_DAY: 1440.0,

      /**
       * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.
       * @type {Number}
       * @constant
       */
      SECONDS_PER_DAY: 86400.0,

      /**
       * The number of days in one Julian century: <code>36525</code>.
       * @type {Number}
       * @constant
       */
      DAYS_PER_JULIAN_CENTURY: 36525.0,

      /**
       * One trillionth of a second.
       * @type {Number}
       * @constant
       */
      PICOSECOND: 0.000000001,

      /**
       * The number of days to subtract from a Julian date to determine the
       * modified Julian date, which gives the number of days since midnight
       * on November 17, 1858.
       * @type {Number}
       * @constant
       */
      MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5
    };

    return freezeObject(TimeConstants);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('5c', ['28'], false, function ($__require, $__exports, $__module) {
  return (function (freezeObject) {
    'use strict';

    /**
     * Provides the type of time standards which JulianDate can take as input.
     *
     * @exports TimeStandard
     *
     * @see JulianDate
     */

    var TimeStandard = {
      /**
       * Represents the coordinated Universal Time (UTC) time standard.
       *
       * UTC is related to TAI according to the relationship
       * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
       * seconds which have been introduced as of the time in TAI.
       *
       */
      UTC: 0,

      /**
       * Represents the International Atomic Time (TAI) time standard.
       * TAI is the principal time standard to which the other time standards are related.
       */
      TAI: 1
    };

    return freezeObject(TimeStandard);
  }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('6d', ['35', '23', '25', '2d', '30', '3b', '5b', '5c'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defined, DeveloperError, JulianDate, CesiumMath, Matrix3, TimeConstants, TimeStandard) {
        'use strict';

        /**
         * Contains functions for finding the Cartesian coordinates of the sun and the moon in the
         * Earth-centered inertial frame.
         *
         * @exports Simon1994PlanetaryPositions
         */

        var Simon1994PlanetaryPositions = {};

        function computeTdbMinusTtSpice(daysSinceJ2000InTerrestrialTime) {
            /* STK Comments ------------------------------------------------------
             * This function uses constants designed to be consistent with
             * the SPICE Toolkit from JPL version N0051 (unitim.c)
             * M0 = 6.239996
             * M0Dot = 1.99096871e-7 rad/s = 0.01720197 rad/d
             * EARTH_ECC = 1.671e-2
             * TDB_AMPL = 1.657e-3 secs
             *--------------------------------------------------------------------*/

            //* Values taken as specified in STK Comments except: 0.01720197 rad/day = 1.99096871e-7 rad/sec
            //* Here we use the more precise value taken from the SPICE value 1.99096871e-7 rad/sec converted to rad/day
            //* All other constants are consistent with the SPICE implementation of the TDB conversion
            //* except where we treat the independent time parameter to be in TT instead of TDB.
            //* This is an approximation made to facilitate performance due to the higher prevalance of
            //* the TT2TDB conversion over TDB2TT in order to avoid having to iterate when converting to TDB for the JPL ephemeris.
            //* Days are used instead of seconds to provide a slight improvement in numerical precision.

            //* For more information see:
            //* http://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB
            //* ftp://ssd.jpl.nasa.gov/pub/eph/planets/ioms/ExplSupplChap8.pdf

            var g = 6.239996 + 0.0172019696544 * daysSinceJ2000InTerrestrialTime;
            return 1.657e-3 * Math.sin(g + 1.671e-2 * Math.sin(g));
        }

        var TdtMinusTai = 32.184;
        var J2000d = 2451545;
        function taiToTdb(date, result) {
            //Converts TAI to TT
            result = JulianDate.addSeconds(date, TdtMinusTai, result);

            //Converts TT to TDB
            var days = JulianDate.totalDays(result) - J2000d;
            result = JulianDate.addSeconds(result, computeTdbMinusTtSpice(days), result);

            return result;
        }

        var epoch = new JulianDate(2451545, 0, TimeStandard.TAI); //Actually TDB (not TAI)
        var GravitationalParameterOfEarth = 3.98600435e14;
        var GravitationalParameterOfSun = GravitationalParameterOfEarth * (1.0 + 0.012300034) * 328900.56;
        var MetersPerKilometer = 1000.0;
        var RadiansPerDegree = CesiumMath.RADIANS_PER_DEGREE;
        var RadiansPerArcSecond = CesiumMath.RADIANS_PER_ARCSECOND;
        var MetersPerAstronomicalUnit = 1.49597870e+11; // IAU 1976 value

        var perifocalToEquatorial = new Matrix3();
        function elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, gravitationalParameter, result) {
            if (inclination < 0.0) {
                inclination = -inclination;
                longitudeOfNode += CesiumMath.PI;
            }
            if (inclination < 0 || inclination > CesiumMath.PI) {
                throw new DeveloperError('The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.');
            }

            var radiusOfPeriapsis = semimajorAxis * (1.0 - eccentricity);
            var argumentOfPeriapsis = longitudeOfPerigee - longitudeOfNode;
            var rightAscensionOfAscendingNode = longitudeOfNode;
            var trueAnomaly = meanAnomalyToTrueAnomaly(meanLongitude - longitudeOfPerigee, eccentricity);
            var type = chooseOrbit(eccentricity, 0.0);
            if (type === 'Hyperbolic' && Math.abs(CesiumMath.negativePiToPi(trueAnomaly)) >= Math.acos(-1.0 / eccentricity)) {
                throw new DeveloperError('The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.');
            }
            perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscensionOfAscendingNode, perifocalToEquatorial);
            var semilatus = radiusOfPeriapsis * (1.0 + eccentricity);
            var costheta = Math.cos(trueAnomaly);
            var sintheta = Math.sin(trueAnomaly);

            var denom = 1.0 + eccentricity * costheta;
            if (denom <= CesiumMath.Epsilon10) {
                throw new DeveloperError('elements cannot be converted to cartesian');
            }

            var radius = semilatus / denom;
            if (!defined(result)) {
                result = new Cartesian3(radius * costheta, radius * sintheta, 0.0);
            } else {
                result.x = radius * costheta;
                result.y = radius * sintheta;
                result.z = 0.0;
            }

            return Matrix3.multiplyByVector(perifocalToEquatorial, result, result);
        }

        function chooseOrbit(eccentricity, tolerance) {
            if (eccentricity < 0) {
                throw new DeveloperError('eccentricity cannot be negative.');
            } else if (eccentricity <= tolerance) {
                return 'Circular';
            } else if (eccentricity < 1.0 - tolerance) {
                return 'Elliptical';
            } else if (eccentricity <= 1.0 + tolerance) {
                return 'Parabolic';
            } else {
                return 'Hyperbolic';
            }
        }

        // Calculates the true anomaly given the mean anomaly and the eccentricity.
        function meanAnomalyToTrueAnomaly(meanAnomaly, eccentricity) {
            if (eccentricity < 0.0 || eccentricity >= 1.0) {
                throw new DeveloperError('eccentricity out of range.');
            }
            var eccentricAnomaly = meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity);
            return eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity);
        }

        var maxIterationCount = 50;
        var keplerEqConvergence = CesiumMath.EPSILON8;
        // Calculates the eccentric anomaly given the mean anomaly and the eccentricity.
        function meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity) {
            if (eccentricity < 0.0 || eccentricity >= 1.0) {
                throw new DeveloperError('eccentricity out of range.');
            }
            var revs = Math.floor(meanAnomaly / CesiumMath.TWO_PI);

            // Find angle in current revolution
            meanAnomaly -= revs * CesiumMath.TWO_PI;

            // calculate starting value for iteration sequence
            var iterationValue = meanAnomaly + eccentricity * Math.sin(meanAnomaly) / (1.0 - Math.sin(meanAnomaly + eccentricity) + Math.sin(meanAnomaly));

            // Perform Newton-Raphson iteration on Kepler's equation
            var eccentricAnomaly = Number.MAX_VALUE;

            var count;
            for (count = 0; count < maxIterationCount && Math.abs(eccentricAnomaly - iterationValue) > keplerEqConvergence; ++count) {
                eccentricAnomaly = iterationValue;
                var NRfunction = eccentricAnomaly - eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;
                var dNRfunction = 1 - eccentricity * Math.cos(eccentricAnomaly);
                iterationValue = eccentricAnomaly - NRfunction / dNRfunction;
            }

            if (count >= maxIterationCount) {
                throw new DeveloperError('Kepler equation did not converge');
                // STK Components uses a numerical method to find the eccentric anomaly in the case that Kepler's
                // equation does not converge. We don't expect that to ever be necessary for the reasonable orbits used here.
            }

            eccentricAnomaly = iterationValue + revs * CesiumMath.TWO_PI;
            return eccentricAnomaly;
        }

        // Calculates the true anomaly given the eccentric anomaly and the eccentricity.
        function eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity) {
            if (eccentricity < 0.0 || eccentricity >= 1.0) {
                throw new DeveloperError('eccentricity out of range.');
            }

            // Calculate the number of previous revolutions
            var revs = Math.floor(eccentricAnomaly / CesiumMath.TWO_PI);

            // Find angle in current revolution
            eccentricAnomaly -= revs * CesiumMath.TWO_PI;

            // Calculate true anomaly from eccentric anomaly
            var trueAnomalyX = Math.cos(eccentricAnomaly) - eccentricity;
            var trueAnomalyY = Math.sin(eccentricAnomaly) * Math.sqrt(1 - eccentricity * eccentricity);

            var trueAnomaly = Math.atan2(trueAnomalyY, trueAnomalyX);

            // Ensure the correct quadrant
            trueAnomaly = CesiumMath.zeroToTwoPi(trueAnomaly);
            if (eccentricAnomaly < 0) {
                trueAnomaly -= CesiumMath.TWO_PI;
            }

            // Add on previous revolutions
            trueAnomaly += revs * CesiumMath.TWO_PI;

            return trueAnomaly;
        }

        // Calculates the transformation matrix to convert from the perifocal (PQW) coordinate
        // system to inertial cartesian coordinates.
        function perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscension, result) {
            if (inclination < 0 || inclination > CesiumMath.PI) {
                throw new DeveloperError('inclination out of range');
            }
            var cosap = Math.cos(argumentOfPeriapsis);
            var sinap = Math.sin(argumentOfPeriapsis);

            var cosi = Math.cos(inclination);
            var sini = Math.sin(inclination);

            var cosraan = Math.cos(rightAscension);
            var sinraan = Math.sin(rightAscension);
            if (!defined(result)) {
                result = new Matrix3(cosraan * cosap - sinraan * sinap * cosi, -cosraan * sinap - sinraan * cosap * cosi, sinraan * sini, sinraan * cosap + cosraan * sinap * cosi, -sinraan * sinap + cosraan * cosap * cosi, -cosraan * sini, sinap * sini, cosap * sini, cosi);
            } else {
                result[0] = cosraan * cosap - sinraan * sinap * cosi;
                result[1] = sinraan * cosap + cosraan * sinap * cosi;
                result[2] = sinap * sini;
                result[3] = -cosraan * sinap - sinraan * cosap * cosi;
                result[4] = -sinraan * sinap + cosraan * cosap * cosi;
                result[5] = cosap * sini;
                result[6] = sinraan * sini;
                result[7] = -cosraan * sini;
                result[8] = cosi;
            }
            return result;
        }

        // From section 5.8
        var semiMajorAxis0 = 1.0000010178 * MetersPerAstronomicalUnit;
        var meanLongitude0 = 100.46645683 * RadiansPerDegree;
        var meanLongitude1 = 1295977422.83429 * RadiansPerArcSecond;

        // From table 6
        var p1u = 16002;
        var p2u = 21863;
        var p3u = 32004;
        var p4u = 10931;
        var p5u = 14529;
        var p6u = 16368;
        var p7u = 15318;
        var p8u = 32794;

        var Ca1 = 64 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca2 = -152 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca3 = 62 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca4 = -8 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca5 = 32 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca6 = -41 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca7 = 19 * 1e-7 * MetersPerAstronomicalUnit;
        var Ca8 = -11 * 1e-7 * MetersPerAstronomicalUnit;

        var Sa1 = -150 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa2 = -46 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa3 = 68 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa4 = 54 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa5 = 14 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa6 = 24 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa7 = -28 * 1e-7 * MetersPerAstronomicalUnit;
        var Sa8 = 22 * 1e-7 * MetersPerAstronomicalUnit;

        var q1u = 10;
        var q2u = 16002;
        var q3u = 21863;
        var q4u = 10931;
        var q5u = 1473;
        var q6u = 32004;
        var q7u = 4387;
        var q8u = 73;

        var Cl1 = -325 * 1e-7;
        var Cl2 = -322 * 1e-7;
        var Cl3 = -79 * 1e-7;
        var Cl4 = 232 * 1e-7;
        var Cl5 = -52 * 1e-7;
        var Cl6 = 97 * 1e-7;
        var Cl7 = 55 * 1e-7;
        var Cl8 = -41 * 1e-7;

        var Sl1 = -105 * 1e-7;
        var Sl2 = -137 * 1e-7;
        var Sl3 = 258 * 1e-7;
        var Sl4 = 35 * 1e-7;
        var Sl5 = -116 * 1e-7;
        var Sl6 = -88 * 1e-7;
        var Sl7 = -112 * 1e-7;
        var Sl8 = -80 * 1e-7;

        var scratchDate = new JulianDate(0, 0.0, TimeStandard.TAI);
        /**
         * Gets a point describing the motion of the Earth-Moon barycenter according to the equations
         * described in section 6.
         */

        function computeSimonEarthMoonBarycenter(date, result) {

            // t is thousands of years from J2000 TDB
            taiToTdb(date, scratchDate);
            var x = scratchDate.dayNumber - epoch.dayNumber + (scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
            var t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY * 10.0);

            var u = 0.35953620 * t;
            var semimajorAxis = semiMajorAxis0 + Ca1 * Math.cos(p1u * u) + Sa1 * Math.sin(p1u * u) + Ca2 * Math.cos(p2u * u) + Sa2 * Math.sin(p2u * u) + Ca3 * Math.cos(p3u * u) + Sa3 * Math.sin(p3u * u) + Ca4 * Math.cos(p4u * u) + Sa4 * Math.sin(p4u * u) + Ca5 * Math.cos(p5u * u) + Sa5 * Math.sin(p5u * u) + Ca6 * Math.cos(p6u * u) + Sa6 * Math.sin(p6u * u) + Ca7 * Math.cos(p7u * u) + Sa7 * Math.sin(p7u * u) + Ca8 * Math.cos(p8u * u) + Sa8 * Math.sin(p8u * u);
            var meanLongitude = meanLongitude0 + meanLongitude1 * t + Cl1 * Math.cos(q1u * u) + Sl1 * Math.sin(q1u * u) + Cl2 * Math.cos(q2u * u) + Sl2 * Math.sin(q2u * u) + Cl3 * Math.cos(q3u * u) + Sl3 * Math.sin(q3u * u) + Cl4 * Math.cos(q4u * u) + Sl4 * Math.sin(q4u * u) + Cl5 * Math.cos(q5u * u) + Sl5 * Math.sin(q5u * u) + Cl6 * Math.cos(q6u * u) + Sl6 * Math.sin(q6u * u) + Cl7 * Math.cos(q7u * u) + Sl7 * Math.sin(q7u * u) + Cl8 * Math.cos(q8u * u) + Sl8 * Math.sin(q8u * u);

            // All constants in this part are from section 5.8
            var eccentricity = 0.0167086342 - 0.0004203654 * t;
            var longitudeOfPerigee = 102.93734808 * RadiansPerDegree + 11612.35290 * RadiansPerArcSecond * t;
            var inclination = 469.97289 * RadiansPerArcSecond * t;
            var longitudeOfNode = 174.87317577 * RadiansPerDegree - 8679.27034 * RadiansPerArcSecond * t;

            return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, GravitationalParameterOfSun, result);
        }

        /**
         * Gets a point describing the position of the moon according to the equations described in section 4.
         */
        function computeSimonMoon(date, result) {
            taiToTdb(date, scratchDate);
            var x = scratchDate.dayNumber - epoch.dayNumber + (scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
            var t = x / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            var t2 = t * t;
            var t3 = t2 * t;
            var t4 = t3 * t;

            // Terms from section 3.4 (b.1)
            var semimajorAxis = 383397.7725 + 0.0040 * t;
            var eccentricity = 0.055545526 - 0.000000016 * t;
            var inclinationConstant = 5.15668983 * RadiansPerDegree;
            var inclinationSecPart = -0.00008 * t + 0.02966 * t2 - 0.000042 * t3 - 0.00000013 * t4;
            var longitudeOfPerigeeConstant = 83.35324312 * RadiansPerDegree;
            var longitudeOfPerigeeSecPart = 14643420.2669 * t - 38.2702 * t2 - 0.045047 * t3 + 0.00021301 * t4;
            var longitudeOfNodeConstant = 125.04455501 * RadiansPerDegree;
            var longitudeOfNodeSecPart = -6967919.3631 * t + 6.3602 * t2 + 0.007625 * t3 - 0.00003586 * t4;
            var meanLongitudeConstant = 218.31664563 * RadiansPerDegree;
            var meanLongitudeSecPart = 1732559343.48470 * t - 6.3910 * t2 + 0.006588 * t3 - 0.00003169 * t4;

            // Delaunay arguments from section 3.5 b
            var D = 297.85019547 * RadiansPerDegree + RadiansPerArcSecond * (1602961601.2090 * t - 6.3706 * t2 + 0.006593 * t3 - 0.00003169 * t4);
            var F = 93.27209062 * RadiansPerDegree + RadiansPerArcSecond * (1739527262.8478 * t - 12.7512 * t2 - 0.001037 * t3 + 0.00000417 * t4);
            var l = 134.96340251 * RadiansPerDegree + RadiansPerArcSecond * (1717915923.2178 * t + 31.8792 * t2 + 0.051635 * t3 - 0.00024470 * t4);
            var lprime = 357.52910918 * RadiansPerDegree + RadiansPerArcSecond * (129596581.0481 * t - 0.5532 * t2 + 0.000136 * t3 - 0.00001149 * t4);
            var psi = 310.17137918 * RadiansPerDegree - RadiansPerArcSecond * (6967051.4360 * t + 6.2068 * t2 + 0.007618 * t3 - 0.00003219 * t4);

            // Add terms from Table 4
            var twoD = 2.0 * D;
            var fourD = 4.0 * D;
            var sixD = 6.0 * D;
            var twol = 2.0 * l;
            var threel = 3.0 * l;
            var fourl = 4.0 * l;
            var twoF = 2.0 * F;
            semimajorAxis += 3400.4 * Math.cos(twoD) - 635.6 * Math.cos(twoD - l) - 235.6 * Math.cos(l) + 218.1 * Math.cos(twoD - lprime) + 181.0 * Math.cos(twoD + l);
            eccentricity += 0.014216 * Math.cos(twoD - l) + 0.008551 * Math.cos(twoD - twol) - 0.001383 * Math.cos(l) + 0.001356 * Math.cos(twoD + l) - 0.001147 * Math.cos(fourD - threel) - 0.000914 * Math.cos(fourD - twol) + 0.000869 * Math.cos(twoD - lprime - l) - 0.000627 * Math.cos(twoD) - 0.000394 * Math.cos(fourD - fourl) + 0.000282 * Math.cos(twoD - lprime - twol) - 0.000279 * Math.cos(D - l) - 0.000236 * Math.cos(twol) + 0.000231 * Math.cos(fourD) + 0.000229 * Math.cos(sixD - fourl) - 0.000201 * Math.cos(twol - twoF);
            inclinationSecPart += 486.26 * Math.cos(twoD - twoF) - 40.13 * Math.cos(twoD) + 37.51 * Math.cos(twoF) + 25.73 * Math.cos(twol - twoF) + 19.97 * Math.cos(twoD - lprime - twoF);
            longitudeOfPerigeeSecPart += -55609 * Math.sin(twoD - l) - 34711 * Math.sin(twoD - twol) - 9792 * Math.sin(l) + 9385 * Math.sin(fourD - threel) + 7505 * Math.sin(fourD - twol) + 5318 * Math.sin(twoD + l) + 3484 * Math.sin(fourD - fourl) - 3417 * Math.sin(twoD - lprime - l) - 2530 * Math.sin(sixD - fourl) - 2376 * Math.sin(twoD) - 2075 * Math.sin(twoD - threel) - 1883 * Math.sin(twol) - 1736 * Math.sin(sixD - 5.0 * l) + 1626 * Math.sin(lprime) - 1370 * Math.sin(sixD - threel);
            longitudeOfNodeSecPart += -5392 * Math.sin(twoD - twoF) - 540 * Math.sin(lprime) - 441 * Math.sin(twoD) + 423 * Math.sin(twoF) - 288 * Math.sin(twol - twoF);
            meanLongitudeSecPart += -3332.9 * Math.sin(twoD) + 1197.4 * Math.sin(twoD - l) - 662.5 * Math.sin(lprime) + 396.3 * Math.sin(l) - 218.0 * Math.sin(twoD - lprime);

            // Add terms from Table 5
            var twoPsi = 2.0 * psi;
            var threePsi = 3.0 * psi;
            inclinationSecPart += 46.997 * Math.cos(psi) * t - 0.614 * Math.cos(twoD - twoF + psi) * t + 0.614 * Math.cos(twoD - twoF - psi) * t - 0.0297 * Math.cos(twoPsi) * t2 - 0.0335 * Math.cos(psi) * t2 + 0.0012 * Math.cos(twoD - twoF + twoPsi) * t2 - 0.00016 * Math.cos(psi) * t3 + 0.00004 * Math.cos(threePsi) * t3 + 0.00004 * Math.cos(twoPsi) * t3;
            var perigeeAndMean = 2.116 * Math.sin(psi) * t - 0.111 * Math.sin(twoD - twoF - psi) * t - 0.0015 * Math.sin(psi) * t2;
            longitudeOfPerigeeSecPart += perigeeAndMean;
            meanLongitudeSecPart += perigeeAndMean;
            longitudeOfNodeSecPart += -520.77 * Math.sin(psi) * t + 13.66 * Math.sin(twoD - twoF + psi) * t + 1.12 * Math.sin(twoD - psi) * t - 1.06 * Math.sin(twoF - psi) * t + 0.660 * Math.sin(twoPsi) * t2 + 0.371 * Math.sin(psi) * t2 - 0.035 * Math.sin(twoD - twoF + twoPsi) * t2 - 0.015 * Math.sin(twoD - twoF + psi) * t2 + 0.0014 * Math.sin(psi) * t3 - 0.0011 * Math.sin(threePsi) * t3 - 0.0009 * Math.sin(twoPsi) * t3;

            // Add constants and convert units
            semimajorAxis *= MetersPerKilometer;
            var inclination = inclinationConstant + inclinationSecPart * RadiansPerArcSecond;
            var longitudeOfPerigee = longitudeOfPerigeeConstant + longitudeOfPerigeeSecPart * RadiansPerArcSecond;
            var meanLongitude = meanLongitudeConstant + meanLongitudeSecPart * RadiansPerArcSecond;
            var longitudeOfNode = longitudeOfNodeConstant + longitudeOfNodeSecPart * RadiansPerArcSecond;

            return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, GravitationalParameterOfEarth, result);
        }

        /**
         * Gets a point describing the motion of the Earth.  This point uses the Moon point and
         * the 1992 mu value (ratio between Moon and Earth masses) in Table 2 of the paper in order
         * to determine the position of the Earth relative to the Earth-Moon barycenter.
         */
        var moonEarthMassRatio = 0.012300034; // From 1992 mu value in Table 2
        var factor = moonEarthMassRatio / (moonEarthMassRatio + 1.0) * -1;
        function computeSimonEarth(date, result) {
            result = computeSimonMoon(date, result);
            return Cartesian3.multiplyByScalar(result, factor, result);
        }

        // Values for the <code>axesTransformation</code> needed for the rotation were found using the STK Components
        // GreographicTransformer on the position of the sun center of mass point and the earth J2000 frame.

        var axesTransformation = new Matrix3(1.0000000000000002, 5.619723173785822e-16, 4.690511510146299e-19, -5.154129427414611e-16, 0.9174820620691819, -0.39777715593191376, -2.23970096136568e-16, 0.39777715593191376, 0.9174820620691819);
        var translation = new Cartesian3();
        /**
         * Computes the position of the Sun in the Earth-centered inertial frame
         *
         * @param {JulianDate} [julianDate] The time at which to compute the Sun's position, if not provided the current system time is used.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} Calculated sun position
         */
        Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame = function (date, result) {
            if (!defined(date)) {
                date = JulianDate.now();
            }

            if (!defined(result)) {
                result = new Cartesian3();
            }

            //first forward transformation
            translation = computeSimonEarthMoonBarycenter(date, translation);
            result = Cartesian3.negate(translation, result);

            //second forward transformation
            computeSimonEarth(date, translation);

            Cartesian3.subtract(result, translation, result);
            Matrix3.multiplyByVector(axesTransformation, result, result);

            return result;
        };

        /**
         * Computes the position of the Moon in the Earth-centered inertial frame
         *
         * @param {JulianDate} [julianDate] The time at which to compute the Sun's position, if not provided the current system time is used.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} Calculated moon position
         */
        Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame = function (date, result) {
            if (!defined(date)) {
                date = JulianDate.now();
            }

            result = computeSimonMoon(date, result);
            Matrix3.multiplyByVector(axesTransformation, result, result);

            return result;
        };

        return Simon1994PlanetaryPositions;
    }).call(this, $__require('35'), $__require('23'), $__require('25'), $__require('2d'), $__require('30'), $__require('3b'), $__require('5b'), $__require('5c'));
});
/*global define*/
$__System.registerDynamic('45', ['35', '44', '2c', '23', '24', '25', '28', '30', '6e'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath, scaleToGeodeticSurface) {
        'use strict';

        function initialize(ellipsoid, x, y, z) {
            x = defaultValue(x, 0.0);
            y = defaultValue(y, 0.0);
            z = defaultValue(z, 0.0);

            //>>includeStart('debug', pragmas.debug);
            if (x < 0.0 || y < 0.0 || z < 0.0) {
                throw new DeveloperError('All radii components must be greater than or equal to zero.');
            }
            //>>includeEnd('debug');

            ellipsoid._radii = new Cartesian3(x, y, z);

            ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);

            ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);

            ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);

            ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));

            ellipsoid._minimumRadius = Math.min(x, y, z);

            ellipsoid._maximumRadius = Math.max(x, y, z);

            ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;
        }

        /**
         * A quadratic surface defined in Cartesian coordinates by the equation
         * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
         * by Cesium to represent the shape of planetary bodies.
         *
         * Rather than constructing this object directly, one of the provided
         * constants is normally used.
         * @alias Ellipsoid
         * @constructor
         *
         * @param {Number} [x=0] The radius in the x direction.
         * @param {Number} [y=0] The radius in the y direction.
         * @param {Number} [z=0] The radius in the z direction.
         *
         * @exception {DeveloperError} All radii components must be greater than or equal to zero.
         *
         * @see Ellipsoid.fromCartesian3
         * @see Ellipsoid.WGS84
         * @see Ellipsoid.UNIT_SPHERE
         */
        function Ellipsoid(x, y, z) {
            this._radii = undefined;
            this._radiiSquared = undefined;
            this._radiiToTheFourth = undefined;
            this._oneOverRadii = undefined;
            this._oneOverRadiiSquared = undefined;
            this._minimumRadius = undefined;
            this._maximumRadius = undefined;
            this._centerToleranceSquared = undefined;

            initialize(this, x, y, z);
        }

        defineProperties(Ellipsoid.prototype, {
            /**
             * Gets the radii of the ellipsoid.
             * @memberof Ellipsoid.prototype
             * @type {Cartesian3}
             * @readonly
             */
            radii: {
                get: function () {
                    return this._radii;
                }
            },
            /**
             * Gets the squared radii of the ellipsoid.
             * @memberof Ellipsoid.prototype
             * @type {Cartesian3}
             * @readonly
             */
            radiiSquared: {
                get: function () {
                    return this._radiiSquared;
                }
            },
            /**
             * Gets the radii of the ellipsoid raise to the fourth power.
             * @memberof Ellipsoid.prototype
             * @type {Cartesian3}
             * @readonly
             */
            radiiToTheFourth: {
                get: function () {
                    return this._radiiToTheFourth;
                }
            },
            /**
             * Gets one over the radii of the ellipsoid.
             * @memberof Ellipsoid.prototype
             * @type {Cartesian3}
             * @readonly
             */
            oneOverRadii: {
                get: function () {
                    return this._oneOverRadii;
                }
            },
            /**
             * Gets one over the squared radii of the ellipsoid.
             * @memberof Ellipsoid.prototype
             * @type {Cartesian3}
             * @readonly
             */
            oneOverRadiiSquared: {
                get: function () {
                    return this._oneOverRadiiSquared;
                }
            },
            /**
             * Gets the minimum radius of the ellipsoid.
             * @memberof Ellipsoid.prototype
             * @type {Number}
             * @readonly
             */
            minimumRadius: {
                get: function () {
                    return this._minimumRadius;
                }
            },
            /**
             * Gets the maximum radius of the ellipsoid.
             * @memberof Ellipsoid.prototype
             * @type {Number}
             * @readonly
             */
            maximumRadius: {
                get: function () {
                    return this._maximumRadius;
                }
            }
        });

        /**
         * Duplicates an Ellipsoid instance.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.
         * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
         *                    instance should be created.
         * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)
         */
        Ellipsoid.clone = function (ellipsoid, result) {
            if (!defined(ellipsoid)) {
                return undefined;
            }
            var radii = ellipsoid._radii;

            if (!defined(result)) {
                return new Ellipsoid(radii.x, radii.y, radii.z);
            }

            Cartesian3.clone(radii, result._radii);
            Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
            Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
            Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
            Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
            result._minimumRadius = ellipsoid._minimumRadius;
            result._maximumRadius = ellipsoid._maximumRadius;
            result._centerToleranceSquared = ellipsoid._centerToleranceSquared;

            return result;
        };

        /**
         * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
         *
         * @param {Cartesian3} [radii=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.
         * @returns {Ellipsoid} A new Ellipsoid instance.
         *
         * @exception {DeveloperError} All radii components must be greater than or equal to zero.
         *
         * @see Ellipsoid.WGS84
         * @see Ellipsoid.UNIT_SPHERE
         */
        Ellipsoid.fromCartesian3 = function (cartesian, result) {
            if (!defined(result)) {
                result = new Ellipsoid();
            }

            if (!defined(cartesian)) {
                return result;
            }

            initialize(result, cartesian.x, cartesian.y, cartesian.z);
            return result;
        };

        /**
         * An Ellipsoid instance initialized to the WGS84 standard.
         *
         * @type {Ellipsoid}
         * @constant
         */
        Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));

        /**
         * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
         *
         * @type {Ellipsoid}
         * @constant
         */
        Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1.0, 1.0, 1.0));

        /**
         * An Ellipsoid instance initialized to a sphere with the lunar radius.
         *
         * @type {Ellipsoid}
         * @constant
         */
        Ellipsoid.MOON = freezeObject(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));

        /**
         * Duplicates an Ellipsoid instance.
         *
         * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
         *                    instance should be created.
         * @returns {Ellipsoid} The cloned Ellipsoid.
         */
        Ellipsoid.prototype.clone = function (result) {
            return Ellipsoid.clone(this, result);
        };

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Ellipsoid.packedLength = Cartesian3.packedLength;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Ellipsoid} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Ellipsoid.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            Cartesian3.pack(value._radii, array, startingIndex);
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Ellipsoid} [result] The object into which to store the result.
         * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.
         */
        Ellipsoid.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            var radii = Cartesian3.unpack(array, startingIndex);
            return Ellipsoid.fromCartesian3(radii, result);
        };

        /**
         * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
         * @function
         *
         * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
         */
        Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;

        /**
         * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
         *
         * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
         */
        Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function (cartographic, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartographic)) {
                throw new DeveloperError('cartographic is required.');
            }
            //>>includeEnd('debug');

            var longitude = cartographic.longitude;
            var latitude = cartographic.latitude;
            var cosLatitude = Math.cos(latitude);

            var x = cosLatitude * Math.cos(longitude);
            var y = cosLatitude * Math.sin(longitude);
            var z = Math.sin(latitude);

            if (!defined(result)) {
                result = new Cartesian3();
            }
            result.x = x;
            result.y = y;
            result.z = z;
            return Cartesian3.normalize(result, result);
        };

        /**
         * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
         *
         * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
         */
        Ellipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {
            if (!defined(result)) {
                result = new Cartesian3();
            }
            result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
            return Cartesian3.normalize(result, result);
        };

        var cartographicToCartesianNormal = new Cartesian3();
        var cartographicToCartesianK = new Cartesian3();

        /**
         * Converts the provided cartographic to Cartesian representation.
         *
         * @param {Cartographic} cartographic The cartographic position.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
         *
         * @example
         * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
         * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);
         * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);
         */
        Ellipsoid.prototype.cartographicToCartesian = function (cartographic, result) {
            //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.
            var n = cartographicToCartesianNormal;
            var k = cartographicToCartesianK;
            this.geodeticSurfaceNormalCartographic(cartographic, n);
            Cartesian3.multiplyComponents(this._radiiSquared, n, k);
            var gamma = Math.sqrt(Cartesian3.dot(n, k));
            Cartesian3.divideByScalar(k, gamma, k);
            Cartesian3.multiplyByScalar(n, cartographic.height, n);

            if (!defined(result)) {
                result = new Cartesian3();
            }
            return Cartesian3.add(k, n, result);
        };

        /**
         * Converts the provided array of cartographics to an array of Cartesians.
         *
         * @param {Cartographic[]} cartographics An array of cartographic positions.
         * @param {Cartesian3[]} [result] The object onto which to store the result.
         * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.
         *
         * @example
         * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
         * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),
         *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),
         *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];
         * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
         */
        Ellipsoid.prototype.cartographicArrayToCartesianArray = function (cartographics, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartographics)) {
                throw new DeveloperError('cartographics is required.');
            }
            //>>includeEnd('debug');

            var length = cartographics.length;
            if (!defined(result)) {
                result = new Array(length);
            } else {
                result.length = length;
            }
            for (var i = 0; i < length; i++) {
                result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
            }
            return result;
        };

        var cartesianToCartographicN = new Cartesian3();
        var cartesianToCartographicP = new Cartesian3();
        var cartesianToCartographicH = new Cartesian3();

        /**
         * Converts the provided cartesian to cartographic representation.
         * The cartesian is undefined at the center of the ellipsoid.
         *
         * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
         * @param {Cartographic} [result] The object onto which to store the result.
         * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
         *
         * @example
         * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
         * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);
         * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
         */
        Ellipsoid.prototype.cartesianToCartographic = function (cartesian, result) {
            //`cartesian is required.` is thrown from scaleToGeodeticSurface
            var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);

            if (!defined(p)) {
                return undefined;
            }

            var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
            var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);

            var longitude = Math.atan2(n.y, n.x);
            var latitude = Math.asin(n.z);
            var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

            if (!defined(result)) {
                return new Cartographic(longitude, latitude, height);
            }
            result.longitude = longitude;
            result.latitude = latitude;
            result.height = height;
            return result;
        };

        /**
         * Converts the provided array of cartesians to an array of cartographics.
         *
         * @param {Cartesian3[]} cartesians An array of Cartesian positions.
         * @param {Cartographic[]} [result] The object onto which to store the result.
         * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.
         *
         * @example
         * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
         * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),
         *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),
         *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]
         * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
         */
        Ellipsoid.prototype.cartesianArrayToCartographicArray = function (cartesians, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesians)) {
                throw new DeveloperError('cartesians is required.');
            }
            //>>includeEnd('debug');

            var length = cartesians.length;
            if (!defined(result)) {
                result = new Array(length);
            } else {
                result.length = length;
            }
            for (var i = 0; i < length; ++i) {
                result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
            }
            return result;
        };

        /**
         * Scales the provided Cartesian position along the geodetic surface normal
         * so that it is on the surface of this ellipsoid.  If the position is
         * at the center of the ellipsoid, this function returns undefined.
         *
         * @param {Cartesian3} cartesian The Cartesian position to scale.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
         */
        Ellipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {
            return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);
        };

        /**
         * Scales the provided Cartesian position along the geocentric surface normal
         * so that it is on the surface of this ellipsoid.
         *
         * @param {Cartesian3} cartesian The Cartesian position to scale.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
         */
        Ellipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Cartesian3();
            }

            var positionX = cartesian.x;
            var positionY = cartesian.y;
            var positionZ = cartesian.z;
            var oneOverRadiiSquared = this._oneOverRadiiSquared;

            var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);

            return Cartesian3.multiplyByScalar(cartesian, beta, result);
        };

        /**
         * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
         * its components by the result of {@link Ellipsoid#oneOverRadii}.
         *
         * @param {Cartesian3} position The position to transform.
         * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
         *        return a new instance.
         * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the
         *          one passed as the result parameter if it is not undefined, or a new instance of it is.
         */
        Ellipsoid.prototype.transformPositionToScaledSpace = function (position, result) {
            if (!defined(result)) {
                result = new Cartesian3();
            }

            return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
        };

        /**
         * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
         * its components by the result of {@link Ellipsoid#radii}.
         *
         * @param {Cartesian3} position The position to transform.
         * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
         *        return a new instance.
         * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the
         *          one passed as the result parameter if it is not undefined, or a new instance of it is.
         */
        Ellipsoid.prototype.transformPositionFromScaledSpace = function (position, result) {
            if (!defined(result)) {
                result = new Cartesian3();
            }

            return Cartesian3.multiplyComponents(position, this._radii, result);
        };

        /**
         * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Ellipsoid} [right] The other Ellipsoid.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        Ellipsoid.prototype.equals = function (right) {
            return this === right || defined(right) && Cartesian3.equals(this._radii, right._radii);
        };

        /**
         * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
         *
         * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
         */
        Ellipsoid.prototype.toString = function () {
            return this._radii.toString();
        };

        return Ellipsoid;
    }).call(this, $__require('35'), $__require('44'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('28'), $__require('30'), $__require('6e'));
});
/*global define*/
$__System.registerDynamic('6f', ['35', '44', '2c', '23', '24', '25', '45', '30'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartographic, defaultValue, defined, defineProperties, DeveloperError, Ellipsoid, CesiumMath) {
        'use strict';

        function setConstants(ellipsoidGeodesic) {
            var uSquared = ellipsoidGeodesic._uSquared;
            var a = ellipsoidGeodesic._ellipsoid.maximumRadius;
            var b = ellipsoidGeodesic._ellipsoid.minimumRadius;
            var f = (a - b) / a;

            var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);
            var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);

            var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);

            var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);
            var sineU = cosineU * tanU;

            var sigma = Math.atan2(tanU, cosineHeading);

            var sineAlpha = cosineU * sineHeading;
            var sineSquaredAlpha = sineAlpha * sineAlpha;

            var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;
            var cosineAlpha = Math.sqrt(cosineSquaredAlpha);

            var u2Over4 = uSquared / 4.0;
            var u4Over16 = u2Over4 * u2Over4;
            var u6Over64 = u4Over16 * u2Over4;
            var u8Over256 = u4Over16 * u4Over16;

            var a0 = 1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0;
            var a1 = 1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0;
            var a2 = 1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0;
            var a3 = 1.0 - 5.0 * u2Over4;

            var distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 - a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;

            var constants = ellipsoidGeodesic._constants;

            constants.a = a;
            constants.b = b;
            constants.f = f;
            constants.cosineHeading = cosineHeading;
            constants.sineHeading = sineHeading;
            constants.tanU = tanU;
            constants.cosineU = cosineU;
            constants.sineU = sineU;
            constants.sigma = sigma;
            constants.sineAlpha = sineAlpha;
            constants.sineSquaredAlpha = sineSquaredAlpha;
            constants.cosineSquaredAlpha = cosineSquaredAlpha;
            constants.cosineAlpha = cosineAlpha;
            constants.u2Over4 = u2Over4;
            constants.u4Over16 = u4Over16;
            constants.u6Over64 = u6Over64;
            constants.u8Over256 = u8Over256;
            constants.a0 = a0;
            constants.a1 = a1;
            constants.a2 = a2;
            constants.a3 = a3;
            constants.distanceRatio = distanceRatio;
        }

        function computeC(f, cosineSquaredAlpha) {
            return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;
        }

        function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {
            var C = computeC(f, cosineSquaredAlpha);

            return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));
        }

        function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
            var eff = (major - minor) / major;
            var l = secondLongitude - firstLongitude;

            var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));
            var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));

            var cosineU1 = Math.cos(u1);
            var sineU1 = Math.sin(u1);
            var cosineU2 = Math.cos(u2);
            var sineU2 = Math.sin(u2);

            var cc = cosineU1 * cosineU2;
            var cs = cosineU1 * sineU2;
            var ss = sineU1 * sineU2;
            var sc = sineU1 * cosineU2;

            var lambda = l;
            var lambdaDot = CesiumMath.TWO_PI;

            var cosineLambda = Math.cos(lambda);
            var sineLambda = Math.sin(lambda);

            var sigma;
            var cosineSigma;
            var sineSigma;
            var cosineSquaredAlpha;
            var cosineTwiceSigmaMidpoint;

            do {
                cosineLambda = Math.cos(lambda);
                sineLambda = Math.sin(lambda);

                var temp = cs - sc * cosineLambda;
                sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);
                cosineSigma = ss + cc * cosineLambda;

                sigma = Math.atan2(sineSigma, cosineSigma);

                var sineAlpha;

                if (sineSigma === 0.0) {
                    sineAlpha = 0.0;
                    cosineSquaredAlpha = 1.0;
                } else {
                    sineAlpha = cc * sineLambda / sineSigma;
                    cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;
                }

                lambdaDot = lambda;

                cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;

                if (isNaN(cosineTwiceSigmaMidpoint)) {
                    cosineTwiceSigmaMidpoint = 0.0;
                }

                lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
            } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);

            var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);
            var A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;
            var B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;

            var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;
            var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint * (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);

            var distance = minor * A * (sigma - deltaSigma);

            var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);
            var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);

            ellipsoidGeodesic._distance = distance;
            ellipsoidGeodesic._startHeading = startHeading;
            ellipsoidGeodesic._endHeading = endHeading;
            ellipsoidGeodesic._uSquared = uSquared;
        }

        function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {
            var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);
            var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);

            //>>includeStart('debug', pragmas.debug);
            if (Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI) < 0.0125) {
                throw new DeveloperError('geodesic position is not unique');
            }
            //>>includeEnd('debug');

            vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius, start.longitude, start.latitude, end.longitude, end.latitude);

            ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);
            ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);
            ellipsoidGeodesic._start.height = 0;
            ellipsoidGeodesic._end.height = 0;

            setConstants(ellipsoidGeodesic);
        }

        var scratchCart1 = new Cartesian3();
        var scratchCart2 = new Cartesian3();
        /**
         * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.
         *
         * @alias EllipsoidGeodesic
         * @constructor
         *
         * @param {Cartographic} [start] The initial planetodetic point on the path.
         * @param {Cartographic} [end] The final planetodetic point on the path.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.
         */
        function EllipsoidGeodesic(start, end, ellipsoid) {
            var e = defaultValue(ellipsoid, Ellipsoid.WGS84);
            this._ellipsoid = e;
            this._start = new Cartographic();
            this._end = new Cartographic();

            this._constants = {};
            this._startHeading = undefined;
            this._endHeading = undefined;
            this._distance = undefined;
            this._uSquared = undefined;

            if (defined(start) && defined(end)) {
                computeProperties(this, start, end, e);
            }
        }

        defineProperties(EllipsoidGeodesic.prototype, {
            /**
             * Gets the ellipsoid.
             * @memberof EllipsoidGeodesic.prototype
             * @type {Ellipsoid}
             * @readonly
             */
            ellipsoid: {
                get: function () {
                    return this._ellipsoid;
                }
            },

            /**
             * Gets the surface distance between the start and end point
             * @memberof EllipsoidGeodesic.prototype
             * @type {Number}
             * @readonly
             */
            surfaceDistance: {
                get: function () {
                    //>>includeStart('debug', pragmas.debug);
                    if (!defined(this._distance)) {
                        throw new DeveloperError('set end positions before getting surfaceDistance');
                    }
                    //>>includeEnd('debug');

                    return this._distance;
                }
            },

            /**
             * Gets the initial planetodetic point on the path.
             * @memberof EllipsoidGeodesic.prototype
             * @type {Cartographic}
             * @readonly
             */
            start: {
                get: function () {
                    return this._start;
                }
            },

            /**
             * Gets the final planetodetic point on the path.
             * @memberof EllipsoidGeodesic.prototype
             * @type {Cartographic}
             * @readonly
             */
            end: {
                get: function () {
                    return this._end;
                }
            },

            /**
             * Gets the heading at the initial point.
             * @memberof EllipsoidGeodesic.prototype
             * @type {Number}
             * @readonly
             */
            startHeading: {
                get: function () {
                    //>>includeStart('debug', pragmas.debug);
                    if (!defined(this._distance)) {
                        throw new DeveloperError('set end positions before getting startHeading');
                    }
                    //>>includeEnd('debug');

                    return this._startHeading;
                }
            },

            /**
             * Gets the heading at the final point.
             * @memberof EllipsoidGeodesic.prototype
             * @type {Number}
             * @readonly
             */
            endHeading: {
                get: function () {
                    //>>includeStart('debug', pragmas.debug);
                    if (!defined(this._distance)) {
                        throw new DeveloperError('set end positions before getting endHeading');
                    }
                    //>>includeEnd('debug');

                    return this._endHeading;
                }
            }
        });

        /**
         * Sets the start and end points of the geodesic
         *
         * @param {Cartographic} start The initial planetodetic point on the path.
         * @param {Cartographic} end The final planetodetic point on the path.
         */
        EllipsoidGeodesic.prototype.setEndPoints = function (start, end) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start cartographic position is required');
            }
            if (!defined(end)) {
                throw new DeveloperError('end cartgraphic position is required');
            }
            //>>includeEnd('debug');

            computeProperties(this, start, end, this._ellipsoid);
        };

        /**
         * Provides the location of a point at the indicated portion along the geodesic.
         *
         * @param {Number} fraction The portion of the distance between the initial and final points.
         * @returns {Cartographic} The location of the point along the geodesic.
         */
        EllipsoidGeodesic.prototype.interpolateUsingFraction = function (fraction, result) {
            return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);
        };

        /**
         * Provides the location of a point at the indicated distance along the geodesic.
         *
         * @param {Number} distance The distance from the inital point to the point of interest along the geodesic
         * @returns {Cartographic} The location of the point along the geodesic.
         *
         * @exception {DeveloperError} start and end must be set before calling funciton interpolateUsingSurfaceDistance
         */
        EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (distance, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(this._distance)) {
                throw new DeveloperError('start and end must be set before calling funciton interpolateUsingSurfaceDistance');
            }
            //>>includeEnd('debug');

            var constants = this._constants;

            var s = constants.distanceRatio + distance / constants.b;

            var cosine2S = Math.cos(2.0 * s);
            var cosine4S = Math.cos(4.0 * s);
            var cosine6S = Math.cos(6.0 * s);
            var sine2S = Math.sin(2.0 * s);
            var sine4S = Math.sin(4.0 * s);
            var sine6S = Math.sin(6.0 * s);
            var sine8S = Math.sin(8.0 * s);

            var s2 = s * s;
            var s3 = s * s2;

            var u8Over256 = constants.u8Over256;
            var u2Over4 = constants.u2Over4;
            var u6Over64 = constants.u6Over64;
            var u4Over16 = constants.u4Over16;
            var sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 + s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 - (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S - (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S - 29.0 * u8Over256 * cosine6S / 16.0) + (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S + (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S - s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) + (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S + 539.0 * u8Over256 * sine8S / 1536.0;

            var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);
            var latitude = Math.atan(constants.a / constants.b * Math.tan(theta));

            // Redefine in terms of relative argument of latitude.
            sigma = sigma - constants.sigma;

            var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);

            var sineSigma = Math.sin(sigma);
            var cosineSigma = Math.cos(sigma);

            var cc = constants.cosineU * cosineSigma;
            var ss = constants.sineU * sineSigma;

            var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);

            var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);

            if (defined(result)) {
                result.longitude = this._start.longitude + l;
                result.latitude = latitude;
                result.height = 0.0;
                return result;
            }

            return new Cartographic(this._start.longitude + l, latitude, 0.0);
        };

        return EllipsoidGeodesic;
    }).call(this, $__require('35'), $__require('44'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('45'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('6e', ['35', '23', '25', '30'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defined, DeveloperError, CesiumMath) {
        'use strict';

        var scaleToGeodeticSurfaceIntersection = new Cartesian3();
        var scaleToGeodeticSurfaceGradient = new Cartesian3();

        /**
         * Scales the provided Cartesian position along the geodetic surface normal
         * so that it is on the surface of this ellipsoid.  If the position is
         * at the center of the ellipsoid, this function returns undefined.
         *
         * @param {Cartesian3} cartesian The Cartesian position to scale.
         * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.
         * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.
         * @param {Number} centerToleranceSquared Tolerance for closeness to the center.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
         *
         * @exports scaleToGeodeticSurface
         *
         * @private
         */
        function scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required.');
            }
            if (!defined(oneOverRadii)) {
                throw new DeveloperError('oneOverRadii is required.');
            }
            if (!defined(oneOverRadiiSquared)) {
                throw new DeveloperError('oneOverRadiiSquared is required.');
            }
            if (!defined(centerToleranceSquared)) {
                throw new DeveloperError('centerToleranceSquared is required.');
            }
            //>>includeEnd('debug');

            var positionX = cartesian.x;
            var positionY = cartesian.y;
            var positionZ = cartesian.z;

            var oneOverRadiiX = oneOverRadii.x;
            var oneOverRadiiY = oneOverRadii.y;
            var oneOverRadiiZ = oneOverRadii.z;

            var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
            var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
            var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;

            // Compute the squared ellipsoid norm.
            var squaredNorm = x2 + y2 + z2;
            var ratio = Math.sqrt(1.0 / squaredNorm);

            // As an initial approximation, assume that the radial intersection is the projection point.
            var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);

            // If the position is near the center, the iteration will not converge.
            if (squaredNorm < centerToleranceSquared) {
                return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);
            }

            var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
            var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
            var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

            // Use the gradient at the intersection point in place of the true unit normal.
            // The difference in magnitude will be absorbed in the multiplier.
            var gradient = scaleToGeodeticSurfaceGradient;
            gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
            gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
            gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;

            // Compute the initial guess at the normal vector multiplier, lambda.
            var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));
            var correction = 0.0;

            var func;
            var denominator;
            var xMultiplier;
            var yMultiplier;
            var zMultiplier;
            var xMultiplier2;
            var yMultiplier2;
            var zMultiplier2;
            var xMultiplier3;
            var yMultiplier3;
            var zMultiplier3;

            do {
                lambda -= correction;

                xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
                yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
                zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);

                xMultiplier2 = xMultiplier * xMultiplier;
                yMultiplier2 = yMultiplier * yMultiplier;
                zMultiplier2 = zMultiplier * zMultiplier;

                xMultiplier3 = xMultiplier2 * xMultiplier;
                yMultiplier3 = yMultiplier2 * yMultiplier;
                zMultiplier3 = zMultiplier2 * zMultiplier;

                func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;

                // "denominator" here refers to the use of this expression in the velocity and acceleration
                // computations in the sections to follow.
                denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;

                var derivative = -2.0 * denominator;

                correction = func / derivative;
            } while (Math.abs(func) > CesiumMath.EPSILON12);

            if (!defined(result)) {
                return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
            }
            result.x = positionX * xMultiplier;
            result.y = positionY * yMultiplier;
            result.z = positionZ * zMultiplier;
            return result;
        }

        return scaleToGeodeticSurface;
    }).call(this, $__require('35'), $__require('23'), $__require('25'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('44', ['35', '2c', '23', '25', '28', '30', '6e'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defaultValue, defined, DeveloperError, freezeObject, CesiumMath, scaleToGeodeticSurface) {
        'use strict';

        /**
         * A position defined by longitude, latitude, and height.
         * @alias Cartographic
         * @constructor
         *
         * @param {Number} [longitude=0.0] The longitude, in radians.
         * @param {Number} [latitude=0.0] The latitude, in radians.
         * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
         *
         * @see Ellipsoid
         */

        function Cartographic(longitude, latitude, height) {
            /**
             * The longitude, in radians.
             * @type {Number}
             * @default 0.0
             */
            this.longitude = defaultValue(longitude, 0.0);

            /**
             * The latitude, in radians.
             * @type {Number}
             * @default 0.0
             */
            this.latitude = defaultValue(latitude, 0.0);

            /**
             * The height, in meters, above the ellipsoid.
             * @type {Number}
             * @default 0.0
             */
            this.height = defaultValue(height, 0.0);
        }

        /**
         * Creates a new Cartographic instance from longitude and latitude
         * specified in radians.
         *
         * @param {Number} longitude The longitude, in radians.
         * @param {Number} latitude The latitude, in radians.
         * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
         * @param {Cartographic} [result] The object onto which to store the result.
         * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
         */
        Cartographic.fromRadians = function (longitude, latitude, height, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(longitude)) {
                throw new DeveloperError('longitude is required.');
            }
            if (!defined(latitude)) {
                throw new DeveloperError('latitude is required.');
            }
            //>>includeEnd('debug');

            height = defaultValue(height, 0.0);

            if (!defined(result)) {
                return new Cartographic(longitude, latitude, height);
            }

            result.longitude = longitude;
            result.latitude = latitude;
            result.height = height;
            return result;
        };

        /**
         * Creates a new Cartographic instance from longitude and latitude
         * specified in degrees.  The values in the resulting object will
         * be in radians.
         *
         * @param {Number} longitude The longitude, in degrees.
         * @param {Number} latitude The latitude, in degrees.
         * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
         * @param {Cartographic} [result] The object onto which to store the result.
         * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
         */
        Cartographic.fromDegrees = function (longitude, latitude, height, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(longitude)) {
                throw new DeveloperError('longitude is required.');
            }
            if (!defined(latitude)) {
                throw new DeveloperError('latitude is required.');
            }
            //>>includeEnd('debug');
            longitude = CesiumMath.toRadians(longitude);
            latitude = CesiumMath.toRadians(latitude);

            return Cartographic.fromRadians(longitude, latitude, height, result);
        };

        var cartesianToCartographicN = new Cartesian3();
        var cartesianToCartographicP = new Cartesian3();
        var cartesianToCartographicH = new Cartesian3();
        var wgs84OneOverRadii = new Cartesian3(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);
        var wgs84OneOverRadiiSquared = new Cartesian3(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));
        var wgs84CenterToleranceSquared = CesiumMath.EPSILON1;

        /**
         * Creates a new Cartographic instance from a Cartesian position. The values in the
         * resulting object will be in radians.
         *
         * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
         * @param {Cartographic} [result] The object onto which to store the result.
         * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
         */
        Cartographic.fromCartesian = function (cartesian, ellipsoid, result) {
            var oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : wgs84OneOverRadii;
            var oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : wgs84OneOverRadiiSquared;
            var centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : wgs84CenterToleranceSquared;

            //`cartesian is required.` is thrown from scaleToGeodeticSurface
            var p = scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP);

            if (!defined(p)) {
                return undefined;
            }

            var n = Cartesian3.multiplyComponents(cartesian, oneOverRadiiSquared, cartesianToCartographicN);
            n = Cartesian3.normalize(n, n);

            var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);

            var longitude = Math.atan2(n.y, n.x);
            var latitude = Math.asin(n.z);
            var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);

            if (!defined(result)) {
                return new Cartographic(longitude, latitude, height);
            }
            result.longitude = longitude;
            result.latitude = latitude;
            result.height = height;
            return result;
        };

        /**
         * Duplicates a Cartographic instance.
         *
         * @param {Cartographic} cartographic The cartographic to duplicate.
         * @param {Cartographic} [result] The object onto which to store the result.
         * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)
         */
        Cartographic.clone = function (cartographic, result) {
            if (!defined(cartographic)) {
                return undefined;
            }
            if (!defined(result)) {
                return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
            }
            result.longitude = cartographic.longitude;
            result.latitude = cartographic.latitude;
            result.height = cartographic.height;
            return result;
        };

        /**
         * Compares the provided cartographics componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartographic} [left] The first cartographic.
         * @param {Cartographic} [right] The second cartographic.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Cartographic.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left.longitude === right.longitude && left.latitude === right.latitude && left.height === right.height;
        };

        /**
         * Compares the provided cartographics componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Cartographic} [left] The first cartographic.
         * @param {Cartographic} [right] The second cartographic.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartographic.equalsEpsilon = function (left, right, epsilon) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof epsilon !== 'number') {
                throw new DeveloperError('epsilon is required and must be a number.');
            }
            //>>includeEnd('debug');

            return left === right || defined(left) && defined(right) && Math.abs(left.longitude - right.longitude) <= epsilon && Math.abs(left.latitude - right.latitude) <= epsilon && Math.abs(left.height - right.height) <= epsilon;
        };

        /**
         * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
         *
         * @type {Cartographic}
         * @constant
         */
        Cartographic.ZERO = freezeObject(new Cartographic(0.0, 0.0, 0.0));

        /**
         * Duplicates this instance.
         *
         * @param {Cartographic} [result] The object onto which to store the result.
         * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
         */
        Cartographic.prototype.clone = function (result) {
            return Cartographic.clone(this, result);
        };

        /**
         * Compares the provided against this cartographic componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartographic} [right] The second cartographic.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Cartographic.prototype.equals = function (right) {
            return Cartographic.equals(this, right);
        };

        /**
         * Compares the provided against this cartographic componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Cartographic} [right] The second cartographic.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartographic.prototype.equalsEpsilon = function (right, epsilon) {
            return Cartographic.equalsEpsilon(this, right, epsilon);
        };

        /**
         * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
         *
         * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
         */
        Cartographic.prototype.toString = function () {
            return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';
        };

        return Cartographic;
    }).call(this, $__require('35'), $__require('2c'), $__require('23'), $__require('25'), $__require('28'), $__require('30'), $__require('6e'));
});
/*global define*/
$__System.registerDynamic('70', ['25', '71'], false, function ($__require, $__exports, $__module) {
    return (function (DeveloperError, QuadraticRealPolynomial) {
        'use strict';

        /**
         * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.
         *
         * @exports CubicRealPolynomial
         */

        var CubicRealPolynomial = {};

        /**
         * Provides the discriminant of the cubic equation from the supplied coefficients.
         *
         * @param {Number} a The coefficient of the 3rd order monomial.
         * @param {Number} b The coefficient of the 2nd order monomial.
         * @param {Number} c The coefficient of the 1st order monomial.
         * @param {Number} d The coefficient of the 0th order monomial.
         * @returns {Number} The value of the discriminant.
         */
        CubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof a !== 'number') {
                throw new DeveloperError('a is a required number.');
            }
            if (typeof b !== 'number') {
                throw new DeveloperError('b is a required number.');
            }
            if (typeof c !== 'number') {
                throw new DeveloperError('c is a required number.');
            }
            if (typeof d !== 'number') {
                throw new DeveloperError('d is a required number.');
            }
            //>>includeEnd('debug');

            var a2 = a * a;
            var b2 = b * b;
            var c2 = c * c;
            var d2 = d * d;

            var discriminant = 18.0 * a * b * c * d + b2 * c2 - 27.0 * a2 * d2 - 4.0 * (a * c2 * c + b2 * b * d);
            return discriminant;
        };

        function computeRealRoots(a, b, c, d) {
            var A = a;
            var B = b / 3.0;
            var C = c / 3.0;
            var D = d;

            var AC = A * C;
            var BD = B * D;
            var B2 = B * B;
            var C2 = C * C;
            var delta1 = A * C - B2;
            var delta2 = A * D - B * C;
            var delta3 = B * D - C2;

            var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;
            var temp;
            var temp1;

            if (discriminant < 0.0) {
                var ABar;
                var CBar;
                var DBar;

                if (B2 * BD >= AC * C2) {
                    ABar = A;
                    CBar = delta1;
                    DBar = -2.0 * B * delta1 + A * delta2;
                } else {
                    ABar = D;
                    CBar = delta3;
                    DBar = -D * delta2 + 2.0 * C * delta3;
                }

                var s = DBar < 0.0 ? -1.0 : 1.0; // This is not Math.Sign()!
                var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
                temp1 = -DBar + temp0;

                var x = temp1 / 2.0;
                var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);
                var q = temp1 === temp0 ? -p : -CBar / p;

                temp = CBar <= 0.0 ? p + q : -DBar / (p * p + q * q + CBar);

                if (B2 * BD >= AC * C2) {
                    return [(temp - B) / A];
                }

                return [-D / (temp + C)];
            }

            var CBarA = delta1;
            var DBarA = -2.0 * B * delta1 + A * delta2;

            var CBarD = delta3;
            var DBarD = -D * delta2 + 2.0 * C * delta3;

            var squareRootOfDiscriminant = Math.sqrt(discriminant);
            var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;

            var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);
            temp = 2.0 * Math.sqrt(-CBarA);
            var cosine = Math.cos(theta);
            temp1 = temp * cosine;
            var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));

            var numeratorLarge = temp1 + temp3 > 2.0 * B ? temp1 - B : temp3 - B;
            var denominatorLarge = A;

            var root1 = numeratorLarge / denominatorLarge;

            theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);
            temp = 2.0 * Math.sqrt(-CBarD);
            cosine = Math.cos(theta);
            temp1 = temp * cosine;
            temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));

            var numeratorSmall = -D;
            var denominatorSmall = temp1 + temp3 < 2.0 * C ? temp1 + C : temp3 + C;

            var root3 = numeratorSmall / denominatorSmall;

            var E = denominatorLarge * denominatorSmall;
            var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
            var G = numeratorLarge * numeratorSmall;

            var root2 = (C * F - B * G) / (-B * F + C * E);

            if (root1 <= root2) {
                if (root1 <= root3) {
                    if (root2 <= root3) {
                        return [root1, root2, root3];
                    }
                    return [root1, root3, root2];
                }
                return [root3, root1, root2];
            }
            if (root1 <= root3) {
                return [root2, root1, root3];
            }
            if (root2 <= root3) {
                return [root2, root3, root1];
            }
            return [root3, root2, root1];
        }

        /**
         * Provides the real valued roots of the cubic polynomial with the provided coefficients.
         *
         * @param {Number} a The coefficient of the 3rd order monomial.
         * @param {Number} b The coefficient of the 2nd order monomial.
         * @param {Number} c The coefficient of the 1st order monomial.
         * @param {Number} d The coefficient of the 0th order monomial.
         * @returns {Number[]} The real valued roots.
         */
        CubicRealPolynomial.computeRealRoots = function (a, b, c, d) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof a !== 'number') {
                throw new DeveloperError('a is a required number.');
            }
            if (typeof b !== 'number') {
                throw new DeveloperError('b is a required number.');
            }
            if (typeof c !== 'number') {
                throw new DeveloperError('c is a required number.');
            }
            if (typeof d !== 'number') {
                throw new DeveloperError('d is a required number.');
            }
            //>>includeEnd('debug');

            var roots;
            var ratio;
            if (a === 0.0) {
                // Quadratic function: b * x^2 + c * x + d = 0.
                return QuadraticRealPolynomial.computeRealRoots(b, c, d);
            } else if (b === 0.0) {
                if (c === 0.0) {
                    if (d === 0.0) {
                        // 3rd order monomial: a * x^3 = 0.
                        return [0.0, 0.0, 0.0];
                    }

                    // a * x^3 + d = 0
                    ratio = -d / a;
                    var root = ratio < 0.0 ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);
                    return [root, root, root];
                } else if (d === 0.0) {
                    // x * (a * x^2 + c) = 0.
                    roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);

                    // Return the roots in ascending order.
                    if (roots.Length === 0) {
                        return [0.0];
                    }
                    return [roots[0], 0.0, roots[1]];
                }

                // Deflated cubic polynomial: a * x^3 + c * x + d= 0.
                return computeRealRoots(a, 0, c, d);
            } else if (c === 0.0) {
                if (d === 0.0) {
                    // x^2 * (a * x + b) = 0.
                    ratio = -b / a;
                    if (ratio < 0.0) {
                        return [ratio, 0.0, 0.0];
                    }
                    return [0.0, 0.0, ratio];
                }
                // a * x^3 + b * x^2 + d = 0.
                return computeRealRoots(a, b, 0, d);
            } else if (d === 0.0) {
                // x * (a * x^2 + b * x + c) = 0
                roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);

                // Return the roots in ascending order.
                if (roots.length === 0) {
                    return [0.0];
                } else if (roots[1] <= 0.0) {
                    return [roots[0], roots[1], 0.0];
                } else if (roots[0] >= 0.0) {
                    return [0.0, roots[0], roots[1]];
                }
                return [roots[0], 0.0, roots[1]];
            }

            return computeRealRoots(a, b, c, d);
        };

        return CubicRealPolynomial;
    }).call(this, $__require('25'), $__require('71'));
});
/*global define*/
$__System.registerDynamic('71', ['25', '30'], false, function ($__require, $__exports, $__module) {
    return (function (DeveloperError, CesiumMath) {
        'use strict';

        /**
         * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.
         *
         * @exports QuadraticRealPolynomial
         */

        var QuadraticRealPolynomial = {};

        /**
         * Provides the discriminant of the quadratic equation from the supplied coefficients.
         *
         * @param {Number} a The coefficient of the 2nd order monomial.
         * @param {Number} b The coefficient of the 1st order monomial.
         * @param {Number} c The coefficient of the 0th order monomial.
         * @returns {Number} The value of the discriminant.
         */
        QuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof a !== 'number') {
                throw new DeveloperError('a is a required number.');
            }
            if (typeof b !== 'number') {
                throw new DeveloperError('b is a required number.');
            }
            if (typeof c !== 'number') {
                throw new DeveloperError('c is a required number.');
            }
            //>>includeEnd('debug');

            var discriminant = b * b - 4.0 * a * c;
            return discriminant;
        };

        function addWithCancellationCheck(left, right, tolerance) {
            var difference = left + right;
            if (CesiumMath.sign(left) !== CesiumMath.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
                return 0.0;
            }

            return difference;
        }

        /**
         * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
         *
         * @param {Number} a The coefficient of the 2nd order monomial.
         * @param {Number} b The coefficient of the 1st order monomial.
         * @param {Number} c The coefficient of the 0th order monomial.
         * @returns {Number[]} The real valued roots.
         */
        QuadraticRealPolynomial.computeRealRoots = function (a, b, c) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof a !== 'number') {
                throw new DeveloperError('a is a required number.');
            }
            if (typeof b !== 'number') {
                throw new DeveloperError('b is a required number.');
            }
            if (typeof c !== 'number') {
                throw new DeveloperError('c is a required number.');
            }
            //>>includeEnd('debug');

            var ratio;
            if (a === 0.0) {
                if (b === 0.0) {
                    // Constant function: c = 0.
                    return [];
                }

                // Linear function: b * x + c = 0.
                return [-c / b];
            } else if (b === 0.0) {
                if (c === 0.0) {
                    // 2nd order monomial: a * x^2 = 0.
                    return [0.0, 0.0];
                }

                var cMagnitude = Math.abs(c);
                var aMagnitude = Math.abs(a);

                if (cMagnitude < aMagnitude && cMagnitude / aMagnitude < CesiumMath.EPSILON14) {
                    // c ~= 0.0.
                    // 2nd order monomial: a * x^2 = 0.
                    return [0.0, 0.0];
                } else if (cMagnitude > aMagnitude && aMagnitude / cMagnitude < CesiumMath.EPSILON14) {
                    // a ~= 0.0.
                    // Constant function: c = 0.
                    return [];
                }

                // a * x^2 + c = 0
                ratio = -c / a;

                if (ratio < 0.0) {
                    // Both roots are complex.
                    return [];
                }

                // Both roots are real.
                var root = Math.sqrt(ratio);
                return [-root, root];
            } else if (c === 0.0) {
                // a * x^2 + b * x = 0
                ratio = -b / a;
                if (ratio < 0.0) {
                    return [ratio, 0.0];
                }

                return [0.0, ratio];
            }

            // a * x^2 + b * x + c = 0
            var b2 = b * b;
            var four_ac = 4.0 * a * c;
            var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);

            if (radicand < 0.0) {
                // Both roots are complex.
                return [];
            }

            var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);
            if (b > 0.0) {
                return [q / a, c / q];
            }

            return [c / q, q / a];
        };

        return QuadraticRealPolynomial;
    }).call(this, $__require('25'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('72', ['70', '25', '30', '71'], false, function ($__require, $__exports, $__module) {
    return (function (CubicRealPolynomial, DeveloperError, CesiumMath, QuadraticRealPolynomial) {
        'use strict';

        /**
         * Defines functions for 4th order polynomial functions of one variable with only real coefficients.
         *
         * @exports QuarticRealPolynomial
         */

        var QuarticRealPolynomial = {};

        /**
         * Provides the discriminant of the quartic equation from the supplied coefficients.
         *
         * @param {Number} a The coefficient of the 4th order monomial.
         * @param {Number} b The coefficient of the 3rd order monomial.
         * @param {Number} c The coefficient of the 2nd order monomial.
         * @param {Number} d The coefficient of the 1st order monomial.
         * @param {Number} e The coefficient of the 0th order monomial.
         * @returns {Number} The value of the discriminant.
         */
        QuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof a !== 'number') {
                throw new DeveloperError('a is a required number.');
            }
            if (typeof b !== 'number') {
                throw new DeveloperError('b is a required number.');
            }
            if (typeof c !== 'number') {
                throw new DeveloperError('c is a required number.');
            }
            if (typeof d !== 'number') {
                throw new DeveloperError('d is a required number.');
            }
            if (typeof e !== 'number') {
                throw new DeveloperError('e is a required number.');
            }
            //>>includeEnd('debug');

            var a2 = a * a;
            var a3 = a2 * a;
            var b2 = b * b;
            var b3 = b2 * b;
            var c2 = c * c;
            var c3 = c2 * c;
            var d2 = d * d;
            var d3 = d2 * d;
            var e2 = e * e;
            var e3 = e2 * e;

            var discriminant = b2 * c2 * d2 - 4.0 * b3 * d3 - 4.0 * a * c3 * d2 + 18 * a * b * c * d3 - 27.0 * a2 * d2 * d2 + 256.0 * a3 * e3 + e * (18.0 * b3 * c * d - 4.0 * b2 * c3 + 16.0 * a * c2 * c2 - 80.0 * a * b * c2 * d - 6.0 * a * b2 * d2 + 144.0 * a2 * c * d2) + e2 * (144.0 * a * b2 * c - 27.0 * b2 * b2 - 128.0 * a2 * c2 - 192.0 * a2 * b * d);
            return discriminant;
        };

        function original(a3, a2, a1, a0) {
            var a3Squared = a3 * a3;

            var p = a2 - 3.0 * a3Squared / 8.0;
            var q = a1 - a2 * a3 / 2.0 + a3Squared * a3 / 8.0;
            var r = a0 - a1 * a3 / 4.0 + a2 * a3Squared / 16.0 - 3.0 * a3Squared * a3Squared / 256.0;

            // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.
            var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, 2.0 * p, p * p - 4.0 * r, -q * q);

            if (cubicRoots.length > 0) {
                var temp = -a3 / 4.0;

                // Use the largest positive root.
                var hSquared = cubicRoots[cubicRoots.length - 1];

                if (Math.abs(hSquared) < CesiumMath.EPSILON14) {
                    // y^4 + p y^2 + r = 0.
                    var roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);

                    if (roots.length === 2) {
                        var root0 = roots[0];
                        var root1 = roots[1];

                        var y;
                        if (root0 >= 0.0 && root1 >= 0.0) {
                            var y0 = Math.sqrt(root0);
                            var y1 = Math.sqrt(root1);

                            return [temp - y1, temp - y0, temp + y0, temp + y1];
                        } else if (root0 >= 0.0 && root1 < 0.0) {
                            y = Math.sqrt(root0);
                            return [temp - y, temp + y];
                        } else if (root0 < 0.0 && root1 >= 0.0) {
                            y = Math.sqrt(root1);
                            return [temp - y, temp + y];
                        }
                    }
                    return [];
                } else if (hSquared > 0.0) {
                    var h = Math.sqrt(hSquared);

                    var m = (p + hSquared - q / h) / 2.0;
                    var n = (p + hSquared + q / h) / 2.0;

                    // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);
                    var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);
                    var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);

                    if (roots1.length !== 0) {
                        roots1[0] += temp;
                        roots1[1] += temp;

                        if (roots2.length !== 0) {
                            roots2[0] += temp;
                            roots2[1] += temp;

                            if (roots1[1] <= roots2[0]) {
                                return [roots1[0], roots1[1], roots2[0], roots2[1]];
                            } else if (roots2[1] <= roots1[0]) {
                                return [roots2[0], roots2[1], roots1[0], roots1[1]];
                            } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
                                return [roots2[0], roots1[0], roots1[1], roots2[1]];
                            } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
                                return [roots1[0], roots2[0], roots2[1], roots1[1]];
                            } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
                                return [roots2[0], roots1[0], roots2[1], roots1[1]];
                            }
                            return [roots1[0], roots2[0], roots1[1], roots2[1]];
                        }
                        return roots1;
                    }

                    if (roots2.length !== 0) {
                        roots2[0] += temp;
                        roots2[1] += temp;

                        return roots2;
                    }
                    return [];
                }
            }
            return [];
        }

        function neumark(a3, a2, a1, a0) {
            var a1Squared = a1 * a1;
            var a2Squared = a2 * a2;
            var a3Squared = a3 * a3;

            var p = -2.0 * a2;
            var q = a1 * a3 + a2Squared - 4.0 * a0;
            var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;

            var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);

            if (cubicRoots.length > 0) {
                // Use the most positive root
                var y = cubicRoots[0];

                var temp = a2 - y;
                var tempSquared = temp * temp;

                var g1 = a3 / 2.0;
                var h1 = temp / 2.0;

                var m = tempSquared - 4.0 * a0;
                var mError = tempSquared + 4.0 * Math.abs(a0);

                var n = a3Squared - 4.0 * y;
                var nError = a3Squared + 4.0 * Math.abs(y);

                var g2;
                var h2;

                if (y < 0.0 || m * nError < n * mError) {
                    var squareRootOfN = Math.sqrt(n);
                    g2 = squareRootOfN / 2.0;
                    h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;
                } else {
                    var squareRootOfM = Math.sqrt(m);
                    g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;
                    h2 = squareRootOfM / 2.0;
                }

                var G;
                var g;
                if (g1 === 0.0 && g2 === 0.0) {
                    G = 0.0;
                    g = 0.0;
                } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {
                    G = g1 + g2;
                    g = y / G;
                } else {
                    g = g1 - g2;
                    G = y / g;
                }

                var H;
                var h;
                if (h1 === 0.0 && h2 === 0.0) {
                    H = 0.0;
                    h = 0.0;
                } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {
                    H = h1 + h2;
                    h = a0 / H;
                } else {
                    h = h1 - h2;
                    H = a0 / h;
                }

                // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);
                var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);
                var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);

                if (roots1.length !== 0) {
                    if (roots2.length !== 0) {
                        if (roots1[1] <= roots2[0]) {
                            return [roots1[0], roots1[1], roots2[0], roots2[1]];
                        } else if (roots2[1] <= roots1[0]) {
                            return [roots2[0], roots2[1], roots1[0], roots1[1]];
                        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
                            return [roots2[0], roots1[0], roots1[1], roots2[1]];
                        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
                            return [roots1[0], roots2[0], roots2[1], roots1[1]];
                        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
                            return [roots2[0], roots1[0], roots2[1], roots1[1]];
                        } else {
                            return [roots1[0], roots2[0], roots1[1], roots2[1]];
                        }
                    }
                    return roots1;
                }
                if (roots2.length !== 0) {
                    return roots2;
                }
            }
            return [];
        }

        /**
         * Provides the real valued roots of the quartic polynomial with the provided coefficients.
         *
         * @param {Number} a The coefficient of the 4th order monomial.
         * @param {Number} b The coefficient of the 3rd order monomial.
         * @param {Number} c The coefficient of the 2nd order monomial.
         * @param {Number} d The coefficient of the 1st order monomial.
         * @param {Number} e The coefficient of the 0th order monomial.
         * @returns {Number[]} The real valued roots.
         */
        QuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof a !== 'number') {
                throw new DeveloperError('a is a required number.');
            }
            if (typeof b !== 'number') {
                throw new DeveloperError('b is a required number.');
            }
            if (typeof c !== 'number') {
                throw new DeveloperError('c is a required number.');
            }
            if (typeof d !== 'number') {
                throw new DeveloperError('d is a required number.');
            }
            if (typeof e !== 'number') {
                throw new DeveloperError('e is a required number.');
            }
            //>>includeEnd('debug');

            if (Math.abs(a) < CesiumMath.EPSILON15) {
                return CubicRealPolynomial.computeRealRoots(b, c, d, e);
            }
            var a3 = b / a;
            var a2 = c / a;
            var a1 = d / a;
            var a0 = e / a;

            var k = a3 < 0.0 ? 1 : 0;
            k += a2 < 0.0 ? k + 1 : k;
            k += a1 < 0.0 ? k + 1 : k;
            k += a0 < 0.0 ? k + 1 : k;

            switch (k) {
                case 0:
                    return original(a3, a2, a1, a0);
                case 1:
                    return neumark(a3, a2, a1, a0);
                case 2:
                    return neumark(a3, a2, a1, a0);
                case 3:
                    return original(a3, a2, a1, a0);
                case 4:
                    return original(a3, a2, a1, a0);
                case 5:
                    return neumark(a3, a2, a1, a0);
                case 6:
                    return original(a3, a2, a1, a0);
                case 7:
                    return original(a3, a2, a1, a0);
                case 8:
                    return neumark(a3, a2, a1, a0);
                case 9:
                    return original(a3, a2, a1, a0);
                case 10:
                    return original(a3, a2, a1, a0);
                case 11:
                    return neumark(a3, a2, a1, a0);
                case 12:
                    return original(a3, a2, a1, a0);
                case 13:
                    return original(a3, a2, a1, a0);
                case 14:
                    return original(a3, a2, a1, a0);
                case 15:
                    return original(a3, a2, a1, a0);
                default:
                    return undefined;
            }
        };

        return QuarticRealPolynomial;
    }).call(this, $__require('70'), $__require('25'), $__require('30'), $__require('71'));
});
/*global define*/
$__System.registerDynamic('73', ['35', '2c', '23', '25'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defaultValue, defined, DeveloperError) {
        'use strict';

        /**
         * Represents a ray that extends infinitely from the provided origin in the provided direction.
         * @alias Ray
         * @constructor
         *
         * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.
         * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.
         */

        function Ray(origin, direction) {
            direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));
            if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {
                Cartesian3.normalize(direction, direction);
            }

            /**
             * The origin of the ray.
             * @type {Cartesian3}
             * @default {@link Cartesian3.ZERO}
             */
            this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));

            /**
             * The direction of the ray.
             * @type {Cartesian3}
             */
            this.direction = direction;
        }

        /**
         * Computes the point along the ray given by r(t) = o + t*d,
         * where o is the origin of the ray and d is the direction.
         *
         * @param {Ray} ray The ray.
         * @param {Number} t A scalar value.
         * @param {Cartesian3} [result] The object in which the result will be stored.
         * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.
         *
         * @example
         * //Get the first intersection point of a ray and an ellipsoid.
         * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
         * var point = Cesium.Ray.getPoint(ray, intersection.start);
         */
        Ray.getPoint = function (ray, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(ray)) {
                throw new DeveloperError('ray is requred');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is a required number');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Cartesian3();
            }

            result = Cartesian3.multiplyByScalar(ray.direction, t, result);
            return Cartesian3.add(ray.origin, result, result);
        };

        return Ray;
    }).call(this, $__require('35'), $__require('2c'), $__require('23'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('74', ['35', '44', '2c', '23', '25', '30', '3b', '71', '72', '73'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartographic, defaultValue, defined, DeveloperError, CesiumMath, Matrix3, QuadraticRealPolynomial, QuarticRealPolynomial, Ray) {
        'use strict';

        /**
         * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.
         *
         * @exports IntersectionTests
         */

        var IntersectionTests = {};

        /**
         * Computes the intersection of a ray and a plane.
         *
         * @param {Ray} ray The ray.
         * @param {Plane} plane The plane.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
         */
        IntersectionTests.rayPlane = function (ray, plane, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(ray)) {
                throw new DeveloperError('ray is required.');
            }
            if (!defined(plane)) {
                throw new DeveloperError('plane is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Cartesian3();
            }

            var origin = ray.origin;
            var direction = ray.direction;
            var normal = plane.normal;
            var denominator = Cartesian3.dot(normal, direction);

            if (Math.abs(denominator) < CesiumMath.EPSILON15) {
                // Ray is parallel to plane.  The ray may be in the polygon's plane.
                return undefined;
            }

            var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;

            if (t < 0) {
                return undefined;
            }

            result = Cartesian3.multiplyByScalar(direction, t, result);
            return Cartesian3.add(origin, result, result);
        };

        var scratchEdge0 = new Cartesian3();
        var scratchEdge1 = new Cartesian3();
        var scratchPVec = new Cartesian3();
        var scratchTVec = new Cartesian3();
        var scratchQVec = new Cartesian3();

        function rayTriangle(ray, p0, p1, p2, cullBackFaces) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(ray)) {
                throw new DeveloperError('ray is required.');
            }
            if (!defined(p0)) {
                throw new DeveloperError('p0 is required.');
            }
            if (!defined(p1)) {
                throw new DeveloperError('p1 is required.');
            }
            if (!defined(p2)) {
                throw new DeveloperError('p2 is required.');
            }
            //>>includeEnd('debug');

            cullBackFaces = defaultValue(cullBackFaces, false);

            var origin = ray.origin;
            var direction = ray.direction;

            var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);
            var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);

            var p = Cartesian3.cross(direction, edge1, scratchPVec);
            var det = Cartesian3.dot(edge0, p);

            var tvec;
            var q;

            var u;
            var v;
            var t;

            if (cullBackFaces) {
                if (det < CesiumMath.EPSILON6) {
                    return undefined;
                }

                tvec = Cartesian3.subtract(origin, p0, scratchTVec);
                u = Cartesian3.dot(tvec, p);
                if (u < 0.0 || u > det) {
                    return undefined;
                }

                q = Cartesian3.cross(tvec, edge0, scratchQVec);

                v = Cartesian3.dot(direction, q);
                if (v < 0.0 || u + v > det) {
                    return undefined;
                }

                t = Cartesian3.dot(edge1, q) / det;
            } else {
                if (Math.abs(det) < CesiumMath.EPSILON6) {
                    return undefined;
                }
                var invDet = 1.0 / det;

                tvec = Cartesian3.subtract(origin, p0, scratchTVec);
                u = Cartesian3.dot(tvec, p) * invDet;
                if (u < 0.0 || u > 1.0) {
                    return undefined;
                }

                q = Cartesian3.cross(tvec, edge0, scratchQVec);

                v = Cartesian3.dot(direction, q) * invDet;
                if (v < 0.0 || u + v > 1.0) {
                    return undefined;
                }

                t = Cartesian3.dot(edge1, q) * invDet;
            }

            return t;
        }

        /**
         * Computes the intersection of a ray and a triangle.
         * @memberof IntersectionTests
         *
         * @param {Ray} ray The ray.
         * @param {Cartesian3} p0 The first vertex of the triangle.
         * @param {Cartesian3} p1 The second vertex of the triangle.
         * @param {Cartesian3} p2 The third vertex of the triangle.
         * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle
         *                  and return undefined for intersections with the back face.
         * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.
         * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
         */
        IntersectionTests.rayTriangle = function (ray, p0, p1, p2, cullBackFaces, result) {
            var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);
            if (!defined(t) || t < 0.0) {
                return undefined;
            }

            if (!defined(result)) {
                result = new Cartesian3();
            }

            Cartesian3.multiplyByScalar(ray.direction, t, result);
            return Cartesian3.add(ray.origin, result, result);
        };

        var scratchLineSegmentTriangleRay = new Ray();

        /**
         * Computes the intersection of a line segment and a triangle.
         * @memberof IntersectionTests
         *
         * @param {Cartesian3} v0 The an end point of the line segment.
         * @param {Cartesian3} v1 The other end point of the line segment.
         * @param {Cartesian3} p0 The first vertex of the triangle.
         * @param {Cartesian3} p1 The second vertex of the triangle.
         * @param {Cartesian3} p2 The third vertex of the triangle.
         * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle
         *                  and return undefined for intersections with the back face.
         * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.
         * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
         */
        IntersectionTests.lineSegmentTriangle = function (v0, v1, p0, p1, p2, cullBackFaces, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(v0)) {
                throw new DeveloperError('v0 is required.');
            }
            if (!defined(v1)) {
                throw new DeveloperError('v1 is required.');
            }
            //>>includeEnd('debug');

            var ray = scratchLineSegmentTriangleRay;
            Cartesian3.clone(v0, ray.origin);
            Cartesian3.subtract(v1, v0, ray.direction);
            Cartesian3.normalize(ray.direction, ray.direction);

            var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);
            if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {
                return undefined;
            }

            if (!defined(result)) {
                result = new Cartesian3();
            }

            Cartesian3.multiplyByScalar(ray.direction, t, result);
            return Cartesian3.add(ray.origin, result, result);
        };

        function solveQuadratic(a, b, c, result) {
            var det = b * b - 4.0 * a * c;
            if (det < 0.0) {
                return undefined;
            } else if (det > 0.0) {
                var denom = 1.0 / (2.0 * a);
                var disc = Math.sqrt(det);
                var root0 = (-b + disc) * denom;
                var root1 = (-b - disc) * denom;

                if (root0 < root1) {
                    result.root0 = root0;
                    result.root1 = root1;
                } else {
                    result.root0 = root1;
                    result.root1 = root0;
                }

                return result;
            }

            var root = -b / (2.0 * a);
            if (root === 0.0) {
                return undefined;
            }

            result.root0 = result.root1 = root;
            return result;
        }

        var raySphereRoots = {
            root0: 0.0,
            root1: 0.0
        };

        function raySphere(ray, sphere, result) {
            if (!defined(result)) {
                result = {};
            }

            var origin = ray.origin;
            var direction = ray.direction;

            var center = sphere.center;
            var radiusSquared = sphere.radius * sphere.radius;

            var diff = Cartesian3.subtract(origin, center, scratchPVec);

            var a = Cartesian3.dot(direction, direction);
            var b = 2.0 * Cartesian3.dot(direction, diff);
            var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;

            var roots = solveQuadratic(a, b, c, raySphereRoots);
            if (!defined(roots)) {
                return undefined;
            }

            result.start = roots.root0;
            result.stop = roots.root1;
            return result;
        }

        /**
         * Computes the intersection points of a ray with a sphere.
         * @memberof IntersectionTests
         *
         * @param {Ray} ray The ray.
         * @param {BoundingSphere} sphere The sphere.
         * @param {Object} [result] The result onto which to store the result.
         * @returns {Object} An object with the first (<code>start</code>) and the second (<code>stop</code>) intersection scalars for points along the ray or undefined if there are no intersections.
         */
        IntersectionTests.raySphere = function (ray, sphere, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(ray)) {
                throw new DeveloperError('ray is required.');
            }
            if (!defined(sphere)) {
                throw new DeveloperError('sphere is required.');
            }
            //>>includeEnd('debug');

            result = raySphere(ray, sphere, result);
            if (!defined(result) || result.stop < 0.0) {
                return undefined;
            }

            result.start = Math.max(result.start, 0.0);
            return result;
        };

        var scratchLineSegmentRay = new Ray();

        /**
         * Computes the intersection points of a line segment with a sphere.
         * @memberof IntersectionTests
         *
         * @param {Cartesian3} p0 An end point of the line segment.
         * @param {Cartesian3} p1 The other end point of the line segment.
         * @param {BoundingSphere} sphere The sphere.
         * @param {Object} [result] The result onto which to store the result.
         * @returns {Object} An object with the first (<code>start</code>) and the second (<code>stop</code>) intersection scalars for points along the line segment or undefined if there are no intersections.
         */
        IntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(p0)) {
                throw new DeveloperError('p0 is required.');
            }
            if (!defined(p1)) {
                throw new DeveloperError('p1 is required.');
            }
            if (!defined(sphere)) {
                throw new DeveloperError('sphere is required.');
            }
            //>>includeEnd('debug');

            var ray = scratchLineSegmentRay;
            Cartesian3.clone(p0, ray.origin);
            var direction = Cartesian3.subtract(p1, p0, ray.direction);

            var maxT = Cartesian3.magnitude(direction);
            Cartesian3.normalize(direction, direction);

            result = raySphere(ray, sphere, result);
            if (!defined(result) || result.stop < 0.0 || result.start > maxT) {
                return undefined;
            }

            result.start = Math.max(result.start, 0.0);
            result.stop = Math.min(result.stop, maxT);
            return result;
        };

        var scratchQ = new Cartesian3();
        var scratchW = new Cartesian3();

        /**
         * Computes the intersection points of a ray with an ellipsoid.
         *
         * @param {Ray} ray The ray.
         * @param {Ellipsoid} ellipsoid The ellipsoid.
         * @returns {Object} An object with the first (<code>start</code>) and the second (<code>stop</code>) intersection scalars for points along the ray or undefined if there are no intersections.
         */
        IntersectionTests.rayEllipsoid = function (ray, ellipsoid) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(ray)) {
                throw new DeveloperError('ray is required.');
            }
            if (!defined(ellipsoid)) {
                throw new DeveloperError('ellipsoid is required.');
            }
            //>>includeEnd('debug');

            var inverseRadii = ellipsoid.oneOverRadii;
            var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);
            var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);

            var q2 = Cartesian3.magnitudeSquared(q);
            var qw = Cartesian3.dot(q, w);

            var difference, w2, product, discriminant, temp;

            if (q2 > 1.0) {
                // Outside ellipsoid.
                if (qw >= 0.0) {
                    // Looking outward or tangent (0 intersections).
                    return undefined;
                }

                // qw < 0.0.
                var qw2 = qw * qw;
                difference = q2 - 1.0; // Positively valued.
                w2 = Cartesian3.magnitudeSquared(w);
                product = w2 * difference;

                if (qw2 < product) {
                    // Imaginary roots (0 intersections).
                    return undefined;
                } else if (qw2 > product) {
                    // Distinct roots (2 intersections).
                    discriminant = qw * qw - product;
                    temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                    var root0 = temp / w2;
                    var root1 = difference / temp;
                    if (root0 < root1) {
                        return {
                            start: root0,
                            stop: root1
                        };
                    }

                    return {
                        start: root1,
                        stop: root0
                    };
                } else {
                    // qw2 == product.  Repeated roots (2 intersections).
                    var root = Math.sqrt(difference / w2);
                    return {
                        start: root,
                        stop: root
                    };
                }
            } else if (q2 < 1.0) {
                // Inside ellipsoid (2 intersections).
                difference = q2 - 1.0; // Negatively valued.
                w2 = Cartesian3.magnitudeSquared(w);
                product = w2 * difference; // Negatively valued.

                discriminant = qw * qw - product;
                temp = -qw + Math.sqrt(discriminant); // Positively valued.
                return {
                    start: 0.0,
                    stop: temp / w2
                };
            } else {
                // q2 == 1.0. On ellipsoid.
                if (qw < 0.0) {
                    // Looking inward.
                    w2 = Cartesian3.magnitudeSquared(w);
                    return {
                        start: 0.0,
                        stop: -qw / w2
                    };
                }

                // qw >= 0.0.  Looking outward or tangent.
                return undefined;
            }
        };

        function addWithCancellationCheck(left, right, tolerance) {
            var difference = left + right;
            if (CesiumMath.sign(left) !== CesiumMath.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
                return 0.0;
            }

            return difference;
        }

        function quadraticVectorExpression(A, b, c, x, w) {
            var xSquared = x * x;
            var wSquared = w * w;

            var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;
            var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);
            var l0 = A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared + x * b.x + c;

            var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);
            var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);

            var cosines;
            var solutions = [];
            if (r0 === 0.0 && r1 === 0.0) {
                cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);
                if (cosines.length === 0) {
                    return solutions;
                }

                var cosine0 = cosines[0];
                var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));
                solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));
                solutions.push(new Cartesian3(x, w * cosine0, w * sine0));

                if (cosines.length === 2) {
                    var cosine1 = cosines[1];
                    var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));
                    solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));
                    solutions.push(new Cartesian3(x, w * cosine1, w * sine1));
                }

                return solutions;
            }

            var r0Squared = r0 * r0;
            var r1Squared = r1 * r1;
            var l2Squared = l2 * l2;
            var r0r1 = r0 * r1;

            var c4 = l2Squared + r1Squared;
            var c3 = 2.0 * (l1 * l2 + r0r1);
            var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
            var c1 = 2.0 * (l0 * l1 - r0r1);
            var c0 = l0 * l0 - r0Squared;

            if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {
                return solutions;
            }

            cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);
            var length = cosines.length;
            if (length === 0) {
                return solutions;
            }

            for (var i = 0; i < length; ++i) {
                var cosine = cosines[i];
                var cosineSquared = cosine * cosine;
                var sineSquared = Math.max(1.0 - cosineSquared, 0.0);
                var sine = Math.sqrt(sineSquared);

                //var left = l2 * cosineSquared + l1 * cosine + l0;
                var left;
                if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {
                    left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);
                } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {
                    left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);
                } else {
                    left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);
                }

                var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);
                var product = left * right;

                if (product < 0.0) {
                    solutions.push(new Cartesian3(x, w * cosine, w * sine));
                } else if (product > 0.0) {
                    solutions.push(new Cartesian3(x, w * cosine, w * -sine));
                } else if (sine !== 0.0) {
                    solutions.push(new Cartesian3(x, w * cosine, w * -sine));
                    solutions.push(new Cartesian3(x, w * cosine, w * sine));
                    ++i;
                } else {
                    solutions.push(new Cartesian3(x, w * cosine, w * sine));
                }
            }

            return solutions;
        }

        var firstAxisScratch = new Cartesian3();
        var secondAxisScratch = new Cartesian3();
        var thirdAxisScratch = new Cartesian3();
        var referenceScratch = new Cartesian3();
        var bCart = new Cartesian3();
        var bScratch = new Matrix3();
        var btScratch = new Matrix3();
        var diScratch = new Matrix3();
        var dScratch = new Matrix3();
        var cScratch = new Matrix3();
        var tempMatrix = new Matrix3();
        var aScratch = new Matrix3();
        var sScratch = new Cartesian3();
        var closestScratch = new Cartesian3();
        var surfPointScratch = new Cartographic();

        /**
         * Provides the point along the ray which is nearest to the ellipsoid.
         *
         * @param {Ray} ray The ray.
         * @param {Ellipsoid} ellipsoid The ellipsoid.
         * @returns {Cartesian3} The nearest planetodetic point on the ray.
         */
        IntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(ray)) {
                throw new DeveloperError('ray is required.');
            }
            if (!defined(ellipsoid)) {
                throw new DeveloperError('ellipsoid is required.');
            }
            //>>includeEnd('debug');

            var position = ray.origin;
            var direction = ray.direction;

            var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);
            if (Cartesian3.dot(direction, normal) >= 0.0) {
                // The location provided is the closest point in altitude
                return position;
            }

            var intersects = defined(this.rayEllipsoid(ray, ellipsoid));

            // Compute the scaled direction vector.
            var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);

            // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.
            var firstAxis = Cartesian3.normalize(f, f);
            var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);
            var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);
            var thirdAxis = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);
            var B = bScratch;
            B[0] = firstAxis.x;
            B[1] = firstAxis.y;
            B[2] = firstAxis.z;
            B[3] = secondAxis.x;
            B[4] = secondAxis.y;
            B[5] = secondAxis.z;
            B[6] = thirdAxis.x;
            B[7] = thirdAxis.y;
            B[8] = thirdAxis.z;

            var B_T = Matrix3.transpose(B, btScratch);

            // Get the scaling matrix and its inverse.
            var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);
            var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);

            var C = cScratch;
            C[0] = 0.0;
            C[1] = -direction.z;
            C[2] = direction.y;
            C[3] = direction.z;
            C[4] = 0.0;
            C[5] = -direction.x;
            C[6] = -direction.y;
            C[7] = direction.x;
            C[8] = 0.0;

            var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);
            var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);
            var b = Matrix3.multiplyByVector(temp, position, bCart);

            // Solve for the solutions to the expression in standard form:
            var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);

            var s;
            var altitude;
            var length = solutions.length;
            if (length > 0) {
                var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);
                var maximumValue = Number.NEGATIVE_INFINITY;

                for (var i = 0; i < length; ++i) {
                    s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);
                    var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);
                    var dotProduct = Cartesian3.dot(v, direction);

                    if (dotProduct > maximumValue) {
                        maximumValue = dotProduct;
                        closest = Cartesian3.clone(s, closest);
                    }
                }

                var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);
                maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);
                altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);
                altitude = intersects ? -altitude : altitude;
                surfacePoint.height = altitude;
                return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());
            }

            return undefined;
        };

        var lineSegmentPlaneDifference = new Cartesian3();

        /**
         * Computes the intersection of a line segment and a plane.
         *
         * @param {Cartesian3} endPoint0 An end point of the line segment.
         * @param {Cartesian3} endPoint1 The other end point of the line segment.
         * @param {Plane} plane The plane.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The intersection point or undefined if there is no intersection.
         *
         * @example
         * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
         * var normal = ellipsoid.geodeticSurfaceNormal(origin);
         * var plane = Cesium.Plane.fromPointNormal(origin, normal);
         *
         * var p0 = new Cesium.Cartesian3(...);
         * var p1 = new Cesium.Cartesian3(...);
         *
         * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.
         * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);
         */
        IntersectionTests.lineSegmentPlane = function (endPoint0, endPoint1, plane, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(endPoint0)) {
                throw new DeveloperError('endPoint0 is required.');
            }
            if (!defined(endPoint1)) {
                throw new DeveloperError('endPoint1 is required.');
            }
            if (!defined(plane)) {
                throw new DeveloperError('plane is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Cartesian3();
            }

            var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);
            var normal = plane.normal;
            var nDotDiff = Cartesian3.dot(normal, difference);

            // check if the segment and plane are parallel
            if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {
                return undefined;
            }

            var nDotP0 = Cartesian3.dot(normal, endPoint0);
            var t = -(plane.distance + nDotP0) / nDotDiff;

            // intersection only if t is in [0, 1]
            if (t < 0.0 || t > 1.0) {
                return undefined;
            }

            // intersection is endPoint0 + t * (endPoint1 - endPoint0)
            Cartesian3.multiplyByScalar(difference, t, result);
            Cartesian3.add(endPoint0, result, result);
            return result;
        };

        /**
         * Computes the intersection of a triangle and a plane
         *
         * @param {Cartesian3} p0 First point of the triangle
         * @param {Cartesian3} p1 Second point of the triangle
         * @param {Cartesian3} p2 Third point of the triangle
         * @param {Plane} plane Intersection plane
         * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)
         *
         * @example
         * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
         * var normal = ellipsoid.geodeticSurfaceNormal(origin);
         * var plane = Cesium.Plane.fromPointNormal(origin, normal);
         *
         * var p0 = new Cesium.Cartesian3(...);
         * var p1 = new Cesium.Cartesian3(...);
         * var p2 = new Cesium.Cartesian3(...);
         *
         * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane
         * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);
         */
        IntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {
                throw new DeveloperError('p0, p1, p2, and plane are required.');
            }
            //>>includeEnd('debug');

            var planeNormal = plane.normal;
            var planeD = plane.distance;
            var p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;
            var p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;
            var p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;
            // Given these dots products, the calls to lineSegmentPlaneIntersection
            // always have defined results.

            var numBehind = 0;
            numBehind += p0Behind ? 1 : 0;
            numBehind += p1Behind ? 1 : 0;
            numBehind += p2Behind ? 1 : 0;

            var u1, u2;
            if (numBehind === 1 || numBehind === 2) {
                u1 = new Cartesian3();
                u2 = new Cartesian3();
            }

            if (numBehind === 1) {
                if (p0Behind) {
                    IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);
                    IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);

                    return {
                        positions: [p0, p1, p2, u1, u2],
                        indices: [
                        // Behind
                        0, 3, 4,

                        // In front
                        1, 2, 4, 1, 4, 3]
                    };
                } else if (p1Behind) {
                    IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);
                    IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);

                    return {
                        positions: [p0, p1, p2, u1, u2],
                        indices: [
                        // Behind
                        1, 3, 4,

                        // In front
                        2, 0, 4, 2, 4, 3]
                    };
                } else if (p2Behind) {
                    IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);
                    IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);

                    return {
                        positions: [p0, p1, p2, u1, u2],
                        indices: [
                        // Behind
                        2, 3, 4,

                        // In front
                        0, 1, 4, 0, 4, 3]
                    };
                }
            } else if (numBehind === 2) {
                if (!p0Behind) {
                    IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);
                    IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);

                    return {
                        positions: [p0, p1, p2, u1, u2],
                        indices: [
                        // Behind
                        1, 2, 4, 1, 4, 3,

                        // In front
                        0, 3, 4]
                    };
                } else if (!p1Behind) {
                    IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);
                    IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);

                    return {
                        positions: [p0, p1, p2, u1, u2],
                        indices: [
                        // Behind
                        2, 0, 4, 2, 4, 3,

                        // In front
                        1, 3, 4]
                    };
                } else if (!p2Behind) {
                    IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);
                    IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);

                    return {
                        positions: [p0, p1, p2, u1, u2],
                        indices: [
                        // Behind
                        0, 1, 4, 0, 4, 3,

                        // In front
                        2, 3, 4]
                    };
                }
            }

            // if numBehind is 3, the triangle is completely behind the plane;
            // otherwise, it is completely in front (numBehind is 0).
            return undefined;
        };

        return IntersectionTests;
    }).call(this, $__require('35'), $__require('44'), $__require('2c'), $__require('23'), $__require('25'), $__require('30'), $__require('3b'), $__require('71'), $__require('72'), $__require('73'));
});
/*global define*/
$__System.registerDynamic('75', ['23'], false, function ($__require, $__exports, $__module) {
    return (function (defined) {
        'use strict';

        /**
         * Tests an object to see if it is an array.
         * @exports isArray
         *
         * @param {Object} value The value to test.
         * @returns {Boolean} true if the value is an array, false otherwise.
         */

        var isArray = Array.isArray;
        if (!defined(isArray)) {
            isArray = function (value) {
                return Object.prototype.toString.call(value) === '[object Array]';
            };
        }

        return isArray;
    }).call(this, $__require('23'));
});
/*global define*/
$__System.registerDynamic('4c', ['2c', '23', '25', '28', '30'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
        'use strict';

        /**
         * A 4D Cartesian point.
         * @alias Cartesian4
         * @constructor
         *
         * @param {Number} [x=0.0] The X component.
         * @param {Number} [y=0.0] The Y component.
         * @param {Number} [z=0.0] The Z component.
         * @param {Number} [w=0.0] The W component.
         *
         * @see Cartesian2
         * @see Cartesian3
         * @see Packable
         */

        function Cartesian4(x, y, z, w) {
            /**
             * The X component.
             * @type {Number}
             * @default 0.0
             */
            this.x = defaultValue(x, 0.0);

            /**
             * The Y component.
             * @type {Number}
             * @default 0.0
             */
            this.y = defaultValue(y, 0.0);

            /**
             * The Z component.
             * @type {Number}
             * @default 0.0
             */
            this.z = defaultValue(z, 0.0);

            /**
             * The W component.
             * @type {Number}
             * @default 0.0
             */
            this.w = defaultValue(w, 0.0);
        }

        /**
         * Creates a Cartesian4 instance from x, y, z and w coordinates.
         *
         * @param {Number} x The x coordinate.
         * @param {Number} y The y coordinate.
         * @param {Number} z The z coordinate.
         * @param {Number} w The w coordinate.
         * @param {Cartesian4} [result] The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
         */
        Cartesian4.fromElements = function (x, y, z, w, result) {
            if (!defined(result)) {
                return new Cartesian4(x, y, z, w);
            }

            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        /**
         * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
         * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
         *
         * @param {Color} color The source color.
         * @param {Cartesian4} [result] The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
         */
        Cartesian4.fromColor = function (color, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(color)) {
                throw new DeveloperError('color is required');
            }
            //>>includeEnd('debug');
            if (!defined(result)) {
                return new Cartesian4(color.red, color.green, color.blue, color.alpha);
            }

            result.x = color.red;
            result.y = color.green;
            result.z = color.blue;
            result.w = color.alpha;
            return result;
        };

        /**
         * Duplicates a Cartesian4 instance.
         *
         * @param {Cartesian4} cartesian The Cartesian to duplicate.
         * @param {Cartesian4} [result] The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
         */
        Cartesian4.clone = function (cartesian, result) {
            if (!defined(cartesian)) {
                return undefined;
            }

            if (!defined(result)) {
                return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
            }

            result.x = cartesian.x;
            result.y = cartesian.y;
            result.z = cartesian.z;
            result.w = cartesian.w;
            return result;
        };

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Cartesian4.packedLength = 4;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Cartesian4} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Cartesian4.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            array[startingIndex++] = value.x;
            array[startingIndex++] = value.y;
            array[startingIndex++] = value.z;
            array[startingIndex] = value.w;
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Cartesian4} [result] The object into which to store the result.
         * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
         */
        Cartesian4.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Cartesian4();
            }
            result.x = array[startingIndex++];
            result.y = array[startingIndex++];
            result.z = array[startingIndex++];
            result.w = array[startingIndex];
            return result;
        };

        /**
         * Flattens an array of Cartesian4s into and array of components.
         *
         * @param {Cartesian4[]} array The array of cartesians to pack.
         * @param {Number[]} result The array onto which to store the result.
         * @returns {Number[]} The packed array.
         */
        Cartesian4.packArray = function (array, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            var length = array.length;
            if (!defined(result)) {
                result = new Array(length * 4);
            } else {
                result.length = length * 4;
            }

            for (var i = 0; i < length; ++i) {
                Cartesian4.pack(array[i], result, i * 4);
            }
            return result;
        };

        /**
         * Unpacks an array of cartesian components into and array of Cartesian4s.
         *
         * @param {Number[]} array The array of components to unpack.
         * @param {Cartesian4[]} result The array onto which to store the result.
         * @returns {Cartesian4[]} The unpacked array.
         */
        Cartesian4.unpackArray = function (array, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            var length = array.length;
            if (!defined(result)) {
                result = new Array(length / 4);
            } else {
                result.length = length / 4;
            }

            for (var i = 0; i < length; i += 4) {
                var index = i / 4;
                result[index] = Cartesian4.unpack(array, i, result[index]);
            }
            return result;
        };

        /**
         * Creates a Cartesian4 from four consecutive elements in an array.
         * @function
         *
         * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
         * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
         * @param {Cartesian4} [result] The object onto which to store the result.
         * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
         *
         * @example
         * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
         * var v = [1.0, 2.0, 3.0, 4.0];
         * var p = Cesium.Cartesian4.fromArray(v);
         *
         * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
         * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
         * var p2 = Cesium.Cartesian4.fromArray(v2, 2);
         */
        Cartesian4.fromArray = Cartesian4.unpack;

        /**
         * Computes the value of the maximum component for the supplied Cartesian.
         *
         * @param {Cartesian4} cartesian The cartesian to use.
         * @returns {Number} The value of the maximum component.
         */
        Cartesian4.maximumComponent = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
        };

        /**
         * Computes the value of the minimum component for the supplied Cartesian.
         *
         * @param {Cartesian4} cartesian The cartesian to use.
         * @returns {Number} The value of the minimum component.
         */
        Cartesian4.minimumComponent = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
        };

        /**
         * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
         *
         * @param {Cartesian4} first A cartesian to compare.
         * @param {Cartesian4} second A cartesian to compare.
         * @param {Cartesian4} result The object into which to store the result.
         * @returns {Cartesian4} A cartesian with the minimum components.
         */
        Cartesian4.minimumByComponent = function (first, second, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required.');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            result.x = Math.min(first.x, second.x);
            result.y = Math.min(first.y, second.y);
            result.z = Math.min(first.z, second.z);
            result.w = Math.min(first.w, second.w);

            return result;
        };

        /**
         * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
         *
         * @param {Cartesian4} first A cartesian to compare.
         * @param {Cartesian4} second A cartesian to compare.
         * @param {Cartesian4} result The object into which to store the result.
         * @returns {Cartesian4} A cartesian with the maximum components.
         */
        Cartesian4.maximumByComponent = function (first, second, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required.');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            result.x = Math.max(first.x, second.x);
            result.y = Math.max(first.y, second.y);
            result.z = Math.max(first.z, second.z);
            result.w = Math.max(first.w, second.w);

            return result;
        };

        /**
         * Computes the provided Cartesian's squared magnitude.
         *
         * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
         * @returns {Number} The squared magnitude.
         */
        Cartesian4.magnitudeSquared = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
        };

        /**
         * Computes the Cartesian's magnitude (length).
         *
         * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
         * @returns {Number} The magnitude.
         */
        Cartesian4.magnitude = function (cartesian) {
            return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
        };

        var distanceScratch = new Cartesian4();

        /**
         * Computes the 4-space distance between two points.
         *
         * @param {Cartesian4} left The first point to compute the distance from.
         * @param {Cartesian4} right The second point to compute the distance to.
         * @returns {Number} The distance between two points.
         *
         * @example
         * // Returns 1.0
         * var d = Cesium.Cartesian4.distance(
         *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
         *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
         */
        Cartesian4.distance = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left) || !defined(right)) {
                throw new DeveloperError('left and right are required.');
            }
            //>>includeEnd('debug');

            Cartesian4.subtract(left, right, distanceScratch);
            return Cartesian4.magnitude(distanceScratch);
        };

        /**
         * Computes the squared distance between two points.  Comparing squared distances
         * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
         *
         * @param {Cartesian4} left The first point to compute the distance from.
         * @param {Cartesian4} right The second point to compute the distance to.
         * @returns {Number} The distance between two points.
         *
         * @example
         * // Returns 4.0, not 2.0
         * var d = Cesium.Cartesian4.distance(
         *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
         *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
         */
        Cartesian4.distanceSquared = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left) || !defined(right)) {
                throw new DeveloperError('left and right are required.');
            }
            //>>includeEnd('debug');

            Cartesian4.subtract(left, right, distanceScratch);
            return Cartesian4.magnitudeSquared(distanceScratch);
        };

        /**
         * Computes the normalized form of the supplied Cartesian.
         *
         * @param {Cartesian4} cartesian The Cartesian to be normalized.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.normalize = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var magnitude = Cartesian4.magnitude(cartesian);

            result.x = cartesian.x / magnitude;
            result.y = cartesian.y / magnitude;
            result.z = cartesian.z / magnitude;
            result.w = cartesian.w / magnitude;
            return result;
        };

        /**
         * Computes the dot (scalar) product of two Cartesians.
         *
         * @param {Cartesian4} left The first Cartesian.
         * @param {Cartesian4} right The second Cartesian.
         * @returns {Number} The dot product.
         */
        Cartesian4.dot = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            //>>includeEnd('debug');

            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        };

        /**
         * Computes the componentwise product of two Cartesians.
         *
         * @param {Cartesian4} left The first Cartesian.
         * @param {Cartesian4} right The second Cartesian.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.multiplyComponents = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x * right.x;
            result.y = left.y * right.y;
            result.z = left.z * right.z;
            result.w = left.w * right.w;
            return result;
        };

        /**
         * Computes the componentwise sum of two Cartesians.
         *
         * @param {Cartesian4} left The first Cartesian.
         * @param {Cartesian4} right The second Cartesian.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.add = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x + right.x;
            result.y = left.y + right.y;
            result.z = left.z + right.z;
            result.w = left.w + right.w;
            return result;
        };

        /**
         * Computes the componentwise difference of two Cartesians.
         *
         * @param {Cartesian4} left The first Cartesian.
         * @param {Cartesian4} right The second Cartesian.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.subtract = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x - right.x;
            result.y = left.y - right.y;
            result.z = left.z - right.z;
            result.w = left.w - right.w;
            return result;
        };

        /**
         * Multiplies the provided Cartesian componentwise by the provided scalar.
         *
         * @param {Cartesian4} cartesian The Cartesian to be scaled.
         * @param {Number} scalar The scalar to multiply with.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.multiplyByScalar = function (cartesian, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = cartesian.x * scalar;
            result.y = cartesian.y * scalar;
            result.z = cartesian.z * scalar;
            result.w = cartesian.w * scalar;
            return result;
        };

        /**
         * Divides the provided Cartesian componentwise by the provided scalar.
         *
         * @param {Cartesian4} cartesian The Cartesian to be divided.
         * @param {Number} scalar The scalar to divide by.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.divideByScalar = function (cartesian, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = cartesian.x / scalar;
            result.y = cartesian.y / scalar;
            result.z = cartesian.z / scalar;
            result.w = cartesian.w / scalar;
            return result;
        };

        /**
         * Negates the provided Cartesian.
         *
         * @param {Cartesian4} cartesian The Cartesian to be negated.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.negate = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = -cartesian.x;
            result.y = -cartesian.y;
            result.z = -cartesian.z;
            result.w = -cartesian.w;
            return result;
        };

        /**
         * Computes the absolute value of the provided Cartesian.
         *
         * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.abs = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = Math.abs(cartesian.x);
            result.y = Math.abs(cartesian.y);
            result.z = Math.abs(cartesian.z);
            result.w = Math.abs(cartesian.w);
            return result;
        };

        var lerpScratch = new Cartesian4();
        /**
         * Computes the linear interpolation or extrapolation at t using the provided cartesians.
         *
         * @param {Cartesian4} start The value corresponding to t at 0.0.
         * @param {Cartesian4}end The value corresponding to t at 1.0.
         * @param {Number} t The point along t at which to interpolate.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Cartesian4.lerp = function (start, end, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start is required.');
            }
            if (!defined(end)) {
                throw new DeveloperError('end is required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            Cartesian4.multiplyByScalar(end, t, lerpScratch);
            result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
            return Cartesian4.add(lerpScratch, result, result);
        };

        var mostOrthogonalAxisScratch = new Cartesian4();
        /**
         * Returns the axis that is most orthogonal to the provided Cartesian.
         *
         * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The most orthogonal axis.
         */
        Cartesian4.mostOrthogonalAxis = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
            Cartesian4.abs(f, f);

            if (f.x <= f.y) {
                if (f.x <= f.z) {
                    if (f.x <= f.w) {
                        result = Cartesian4.clone(Cartesian4.UNIT_X, result);
                    } else {
                        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
                    }
                } else if (f.z <= f.w) {
                    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
                } else {
                    result = Cartesian4.clone(Cartesian4.UNIT_W, result);
                }
            } else if (f.y <= f.z) {
                if (f.y <= f.w) {
                    result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
                } else {
                    result = Cartesian4.clone(Cartesian4.UNIT_W, result);
                }
            } else if (f.z <= f.w) {
                result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
            } else {
                result = Cartesian4.clone(Cartesian4.UNIT_W, result);
            }

            return result;
        };

        /**
         * Compares the provided Cartesians componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartesian4} [left] The first Cartesian.
         * @param {Cartesian4} [right] The second Cartesian.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Cartesian4.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
        };

        /**
         * @private
         */
        Cartesian4.equalsArray = function (cartesian, array, offset) {
            return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];
        };

        /**
         * Compares the provided Cartesians componentwise and returns
         * <code>true</code> if they pass an absolute or relative tolerance test,
         * <code>false</code> otherwise.
         *
         * @param {Cartesian4} [left] The first Cartesian.
         * @param {Cartesian4} [right] The second Cartesian.
         * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
         * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartesian4.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
            return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon);
        };

        /**
         * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
         *
         * @type {Cartesian4}
         * @constant
         */
        Cartesian4.ZERO = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 0.0));

        /**
         * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
         *
         * @type {Cartesian4}
         * @constant
         */
        Cartesian4.UNIT_X = freezeObject(new Cartesian4(1.0, 0.0, 0.0, 0.0));

        /**
         * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
         *
         * @type {Cartesian4}
         * @constant
         */
        Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0.0, 1.0, 0.0, 0.0));

        /**
         * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
         *
         * @type {Cartesian4}
         * @constant
         */
        Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0.0, 0.0, 1.0, 0.0));

        /**
         * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
         *
         * @type {Cartesian4}
         * @constant
         */
        Cartesian4.UNIT_W = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 1.0));

        /**
         * Duplicates this Cartesian4 instance.
         *
         * @param {Cartesian4} [result] The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
         */
        Cartesian4.prototype.clone = function (result) {
            return Cartesian4.clone(this, result);
        };

        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartesian4} [right] The right hand side Cartesian.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        Cartesian4.prototype.equals = function (right) {
            return Cartesian4.equals(this, right);
        };

        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
         * <code>true</code> if they pass an absolute or relative tolerance test,
         * <code>false</code> otherwise.
         *
         * @param {Cartesian4} [right] The right hand side Cartesian.
         * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
         * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
         * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartesian4.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
            return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
        };

        /**
         * Creates a string representing this Cartesian in the format '(x, y)'.
         *
         * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.
         */
        Cartesian4.prototype.toString = function () {
            return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
        };

        return Cartesian4;
    }).call(this, $__require('2c'), $__require('23'), $__require('25'), $__require('28'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('24', ['23'], false, function ($__require, $__exports, $__module) {
    return (function (defined) {
        'use strict';

        var definePropertyWorks = function () {
            try {
                return 'x' in Object.defineProperty({}, 'x', {});
            } catch (e) {
                return false;
            }
        }();

        /**
         * Defines properties on an object, using Object.defineProperties if available,
         * otherwise returns the object unchanged.  This function should be used in
         * setup code to prevent errors from completely halting JavaScript execution
         * in legacy browsers.
         *
         * @private
         *
         * @exports defineProperties
         */
        var defineProperties = Object.defineProperties;
        if (!definePropertyWorks || !defined(defineProperties)) {
            defineProperties = function (o) {
                return o;
            };
        }

        return defineProperties;
    }).call(this, $__require('23'));
});
/*global define*/
$__System.registerDynamic('3b', ['35', '2c', '23', '24', '25', '28', '30'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath) {
        'use strict';

        /**
         * A 3x3 matrix, indexable as a column-major order array.
         * Constructor parameters are in row-major order for code readability.
         * @alias Matrix3
         * @constructor
         *
         * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
         * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
         * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
         * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
         * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
         * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
         * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
         * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
         * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
         *
         * @see Matrix3.fromColumnMajorArray
         * @see Matrix3.fromRowMajorArray
         * @see Matrix3.fromQuaternion
         * @see Matrix3.fromScale
         * @see Matrix3.fromUniformScale
         * @see Matrix2
         * @see Matrix4
         */

        function Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {
            this[0] = defaultValue(column0Row0, 0.0);
            this[1] = defaultValue(column0Row1, 0.0);
            this[2] = defaultValue(column0Row2, 0.0);
            this[3] = defaultValue(column1Row0, 0.0);
            this[4] = defaultValue(column1Row1, 0.0);
            this[5] = defaultValue(column1Row2, 0.0);
            this[6] = defaultValue(column2Row0, 0.0);
            this[7] = defaultValue(column2Row1, 0.0);
            this[8] = defaultValue(column2Row2, 0.0);
        }

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Matrix3.packedLength = 9;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Matrix3} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Matrix3.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }

            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            array[startingIndex++] = value[0];
            array[startingIndex++] = value[1];
            array[startingIndex++] = value[2];
            array[startingIndex++] = value[3];
            array[startingIndex++] = value[4];
            array[startingIndex++] = value[5];
            array[startingIndex++] = value[6];
            array[startingIndex++] = value[7];
            array[startingIndex++] = value[8];
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Matrix3} [result] The object into which to store the result.
         * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
         */
        Matrix3.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Matrix3();
            }

            result[0] = array[startingIndex++];
            result[1] = array[startingIndex++];
            result[2] = array[startingIndex++];
            result[3] = array[startingIndex++];
            result[4] = array[startingIndex++];
            result[5] = array[startingIndex++];
            result[6] = array[startingIndex++];
            result[7] = array[startingIndex++];
            result[8] = array[startingIndex++];
            return result;
        };

        /**
         * Duplicates a Matrix3 instance.
         *
         * @param {Matrix3} matrix The matrix to duplicate.
         * @param {Matrix3} [result] The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)
         */
        Matrix3.clone = function (values, result) {
            if (!defined(values)) {
                return undefined;
            }
            if (!defined(result)) {
                return new Matrix3(values[0], values[3], values[6], values[1], values[4], values[7], values[2], values[5], values[8]);
            }
            result[0] = values[0];
            result[1] = values[1];
            result[2] = values[2];
            result[3] = values[3];
            result[4] = values[4];
            result[5] = values[5];
            result[6] = values[6];
            result[7] = values[7];
            result[8] = values[8];
            return result;
        };

        /**
         * Creates a Matrix3 from 9 consecutive elements in an array.
         *
         * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
         * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
         * @param {Matrix3} [result] The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Create the Matrix3:
         * // [1.0, 2.0, 3.0]
         * // [1.0, 2.0, 3.0]
         * // [1.0, 2.0, 3.0]
         *
         * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
         * var m = Cesium.Matrix3.fromArray(v);
         *
         * // Create same Matrix3 with using an offset into an array
         * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
         * var m2 = Cesium.Matrix3.fromArray(v2, 2);
         */
        Matrix3.fromArray = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Matrix3();
            }

            result[0] = array[startingIndex];
            result[1] = array[startingIndex + 1];
            result[2] = array[startingIndex + 2];
            result[3] = array[startingIndex + 3];
            result[4] = array[startingIndex + 4];
            result[5] = array[startingIndex + 5];
            result[6] = array[startingIndex + 6];
            result[7] = array[startingIndex + 7];
            result[8] = array[startingIndex + 8];
            return result;
        };

        /**
         * Creates a Matrix3 instance from a column-major order array.
         *
         * @param {Number[]} values The column-major order array.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         */
        Matrix3.fromColumnMajorArray = function (values, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(values)) {
                throw new DeveloperError('values parameter is required');
            }
            //>>includeEnd('debug');

            return Matrix3.clone(values, result);
        };

        /**
         * Creates a Matrix3 instance from a row-major order array.
         * The resulting matrix will be in column-major order.
         *
         * @param {Number[]} values The row-major order array.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         */
        Matrix3.fromRowMajorArray = function (values, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(values)) {
                throw new DeveloperError('values is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);
            }
            result[0] = values[0];
            result[1] = values[3];
            result[2] = values[6];
            result[3] = values[1];
            result[4] = values[4];
            result[5] = values[7];
            result[6] = values[2];
            result[7] = values[5];
            result[8] = values[8];
            return result;
        };

        /**
         * Computes a 3x3 rotation matrix from the provided quaternion.
         *
         * @param {Quaternion} quaternion the quaternion to use.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.
         */
        Matrix3.fromQuaternion = function (quaternion, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(quaternion)) {
                throw new DeveloperError('quaternion is required');
            }
            //>>includeEnd('debug');

            var x2 = quaternion.x * quaternion.x;
            var xy = quaternion.x * quaternion.y;
            var xz = quaternion.x * quaternion.z;
            var xw = quaternion.x * quaternion.w;
            var y2 = quaternion.y * quaternion.y;
            var yz = quaternion.y * quaternion.z;
            var yw = quaternion.y * quaternion.w;
            var z2 = quaternion.z * quaternion.z;
            var zw = quaternion.z * quaternion.w;
            var w2 = quaternion.w * quaternion.w;

            var m00 = x2 - y2 - z2 + w2;
            var m01 = 2.0 * (xy - zw);
            var m02 = 2.0 * (xz + yw);

            var m10 = 2.0 * (xy + zw);
            var m11 = -x2 + y2 - z2 + w2;
            var m12 = 2.0 * (yz - xw);

            var m20 = 2.0 * (xz - yw);
            var m21 = 2.0 * (yz + xw);
            var m22 = -x2 - y2 + z2 + w2;

            if (!defined(result)) {
                return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
            }
            result[0] = m00;
            result[1] = m10;
            result[2] = m20;
            result[3] = m01;
            result[4] = m11;
            result[5] = m21;
            result[6] = m02;
            result[7] = m12;
            result[8] = m22;
            return result;
        };

        /**
         * Computes a Matrix3 instance representing a non-uniform scale.
         *
         * @param {Cartesian3} scale The x, y, and z scale factors.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Creates
         * //   [7.0, 0.0, 0.0]
         * //   [0.0, 8.0, 0.0]
         * //   [0.0, 0.0, 9.0]
         * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
         */
        Matrix3.fromScale = function (scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(scale)) {
                throw new DeveloperError('scale is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);
            }

            result[0] = scale.x;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = scale.y;
            result[5] = 0.0;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = scale.z;
            return result;
        };

        /**
         * Computes a Matrix3 instance representing a uniform scale.
         *
         * @param {Number} scale The uniform scale factor.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Creates
         * //   [2.0, 0.0, 0.0]
         * //   [0.0, 2.0, 0.0]
         * //   [0.0, 0.0, 2.0]
         * var m = Cesium.Matrix3.fromUniformScale(2.0);
         */
        Matrix3.fromUniformScale = function (scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof scale !== 'number') {
                throw new DeveloperError('scale is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);
            }

            result[0] = scale;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = scale;
            result[5] = 0.0;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = scale;
            return result;
        };

        /**
         * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
         *
         * @param {Cartesian3} the vector on the left hand side of the cross product operation.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Creates
         * //   [0.0, -9.0,  8.0]
         * //   [9.0,  0.0, -7.0]
         * //   [-8.0, 7.0,  0.0]
         * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));
         */
        Matrix3.fromCrossProduct = function (vector, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(vector)) {
                throw new DeveloperError('vector is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix3(0.0, -vector.z, vector.y, vector.z, 0.0, -vector.x, -vector.y, vector.x, 0.0);
            }

            result[0] = 0.0;
            result[1] = vector.z;
            result[2] = -vector.y;
            result[3] = -vector.z;
            result[4] = 0.0;
            result[5] = vector.x;
            result[6] = vector.y;
            result[7] = -vector.x;
            result[8] = 0.0;
            return result;
        };

        /**
         * Creates a rotation matrix around the x-axis.
         *
         * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Rotate a point 45 degrees counterclockwise around the x-axis.
         * var p = new Cesium.Cartesian3(5, 6, 7);
         * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));
         * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
         */
        Matrix3.fromRotationX = function (angle, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(angle)) {
                throw new DeveloperError('angle is required.');
            }
            //>>includeEnd('debug');

            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);

            if (!defined(result)) {
                return new Matrix3(1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle);
            }

            result[0] = 1.0;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = cosAngle;
            result[5] = sinAngle;
            result[6] = 0.0;
            result[7] = -sinAngle;
            result[8] = cosAngle;

            return result;
        };

        /**
         * Creates a rotation matrix around the y-axis.
         *
         * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Rotate a point 45 degrees counterclockwise around the y-axis.
         * var p = new Cesium.Cartesian3(5, 6, 7);
         * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));
         * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
         */
        Matrix3.fromRotationY = function (angle, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(angle)) {
                throw new DeveloperError('angle is required.');
            }
            //>>includeEnd('debug');

            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);

            if (!defined(result)) {
                return new Matrix3(cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0, -sinAngle, 0.0, cosAngle);
            }

            result[0] = cosAngle;
            result[1] = 0.0;
            result[2] = -sinAngle;
            result[3] = 0.0;
            result[4] = 1.0;
            result[5] = 0.0;
            result[6] = sinAngle;
            result[7] = 0.0;
            result[8] = cosAngle;

            return result;
        };

        /**
         * Creates a rotation matrix around the z-axis.
         *
         * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
         * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
         *
         * @example
         * // Rotate a point 45 degrees counterclockwise around the z-axis.
         * var p = new Cesium.Cartesian3(5, 6, 7);
         * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));
         * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
         */
        Matrix3.fromRotationZ = function (angle, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(angle)) {
                throw new DeveloperError('angle is required.');
            }
            //>>includeEnd('debug');

            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);

            if (!defined(result)) {
                return new Matrix3(cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0);
            }

            result[0] = cosAngle;
            result[1] = sinAngle;
            result[2] = 0.0;
            result[3] = -sinAngle;
            result[4] = cosAngle;
            result[5] = 0.0;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 1.0;

            return result;
        };

        /**
         * Creates an Array from the provided Matrix3 instance.
         * The array will be in column-major order.
         *
         * @param {Matrix3} matrix The matrix to use..
         * @param {Number[]} [result] The Array onto which to store the result.
         * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
         */
        Matrix3.toArray = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
            }
            result[0] = matrix[0];
            result[1] = matrix[1];
            result[2] = matrix[2];
            result[3] = matrix[3];
            result[4] = matrix[4];
            result[5] = matrix[5];
            result[6] = matrix[6];
            result[7] = matrix[7];
            result[8] = matrix[8];
            return result;
        };

        /**
         * Computes the array index of the element at the provided row and column.
         *
         * @param {Number} row The zero-based index of the row.
         * @param {Number} column The zero-based index of the column.
         * @returns {Number} The index of the element at the provided row and column.
         *
         * @exception {DeveloperError} row must be 0, 1, or 2.
         * @exception {DeveloperError} column must be 0, 1, or 2.
         *
         * @example
         * var myMatrix = new Cesium.Matrix3();
         * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);
         * var column1Row0 = myMatrix[column1Row0Index]
         * myMatrix[column1Row0Index] = 10.0;
         */
        Matrix3.getElementIndex = function (column, row) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof row !== 'number' || row < 0 || row > 2) {
                throw new DeveloperError('row must be 0, 1, or 2.');
            }
            if (typeof column !== 'number' || column < 0 || column > 2) {
                throw new DeveloperError('column must be 0, 1, or 2.');
            }
            //>>includeEnd('debug');

            return column * 3 + row;
        };

        /**
         * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
         *
         * @param {Matrix3} matrix The matrix to use.
         * @param {Number} index The zero-based index of the column to retrieve.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, or 2.
         */
        Matrix3.getColumn = function (matrix, index, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }

            if (typeof index !== 'number' || index < 0 || index > 2) {
                throw new DeveloperError('index must be 0, 1, or 2.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var startIndex = index * 3;
            var x = matrix[startIndex];
            var y = matrix[startIndex + 1];
            var z = matrix[startIndex + 2];

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
         *
         * @param {Matrix3} matrix The matrix to use.
         * @param {Number} index The zero-based index of the column to set.
         * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, or 2.
         */
        Matrix3.setColumn = function (matrix, index, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof index !== 'number' || index < 0 || index > 2) {
                throw new DeveloperError('index must be 0, 1, or 2.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result = Matrix3.clone(matrix, result);
            var startIndex = index * 3;
            result[startIndex] = cartesian.x;
            result[startIndex + 1] = cartesian.y;
            result[startIndex + 2] = cartesian.z;
            return result;
        };

        /**
         * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
         *
         * @param {Matrix3} matrix The matrix to use.
         * @param {Number} index The zero-based index of the row to retrieve.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, or 2.
         */
        Matrix3.getRow = function (matrix, index, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }
            if (typeof index !== 'number' || index < 0 || index > 2) {
                throw new DeveloperError('index must be 0, 1, or 2.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var x = matrix[index];
            var y = matrix[index + 3];
            var z = matrix[index + 6];

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
         *
         * @param {Matrix3} matrix The matrix to use.
         * @param {Number} index The zero-based index of the row to set.
         * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, or 2.
         */
        Matrix3.setRow = function (matrix, index, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof index !== 'number' || index < 0 || index > 2) {
                throw new DeveloperError('index must be 0, 1, or 2.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result = Matrix3.clone(matrix, result);
            result[index] = cartesian.x;
            result[index + 3] = cartesian.y;
            result[index + 6] = cartesian.z;
            return result;
        };

        var scratchColumn = new Cartesian3();

        /**
         * Extracts the non-uniform scale assuming the matrix is an affine transformation.
         *
         * @param {Matrix3} matrix The matrix.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Matrix3.getScale = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
            result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));
            result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));
            return result;
        };

        var scratchScale = new Cartesian3();

        /**
         * Computes the maximum scale assuming the matrix is an affine transformation.
         * The maximum scale is the maximum length of the column vectors.
         *
         * @param {Matrix3} matrix The matrix.
         * @returns {Number} The maximum scale.
         */
        Matrix3.getMaximumScale = function (matrix) {
            Matrix3.getScale(matrix, scratchScale);
            return Cartesian3.maximumComponent(scratchScale);
        };

        /**
         * Computes the product of two matrices.
         *
         * @param {Matrix3} left The first matrix.
         * @param {Matrix3} right The second matrix.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.multiply = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
            var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
            var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];

            var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
            var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
            var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];

            var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
            var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
            var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];

            result[0] = column0Row0;
            result[1] = column0Row1;
            result[2] = column0Row2;
            result[3] = column1Row0;
            result[4] = column1Row1;
            result[5] = column1Row2;
            result[6] = column2Row0;
            result[7] = column2Row1;
            result[8] = column2Row2;
            return result;
        };

        /**
         * Computes the sum of two matrices.
         *
         * @param {Matrix3} left The first matrix.
         * @param {Matrix3} right The second matrix.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.add = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = left[0] + right[0];
            result[1] = left[1] + right[1];
            result[2] = left[2] + right[2];
            result[3] = left[3] + right[3];
            result[4] = left[4] + right[4];
            result[5] = left[5] + right[5];
            result[6] = left[6] + right[6];
            result[7] = left[7] + right[7];
            result[8] = left[8] + right[8];
            return result;
        };

        /**
         * Computes the difference of two matrices.
         *
         * @param {Matrix3} left The first matrix.
         * @param {Matrix3} right The second matrix.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.subtract = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = left[0] - right[0];
            result[1] = left[1] - right[1];
            result[2] = left[2] - right[2];
            result[3] = left[3] - right[3];
            result[4] = left[4] - right[4];
            result[5] = left[5] - right[5];
            result[6] = left[6] - right[6];
            result[7] = left[7] - right[7];
            result[8] = left[8] - right[8];
            return result;
        };

        /**
         * Computes the product of a matrix and a column vector.
         *
         * @param {Matrix3} matrix The matrix.
         * @param {Cartesian3} cartesian The column.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Matrix3.multiplyByVector = function (matrix, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var vX = cartesian.x;
            var vY = cartesian.y;
            var vZ = cartesian.z;

            var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
            var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
            var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Computes the product of a matrix and a scalar.
         *
         * @param {Matrix3} matrix The matrix.
         * @param {Number} scalar The number to multiply by.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.multiplyByScalar = function (matrix, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar must be a number');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = matrix[0] * scalar;
            result[1] = matrix[1] * scalar;
            result[2] = matrix[2] * scalar;
            result[3] = matrix[3] * scalar;
            result[4] = matrix[4] * scalar;
            result[5] = matrix[5] * scalar;
            result[6] = matrix[6] * scalar;
            result[7] = matrix[7] * scalar;
            result[8] = matrix[8] * scalar;
            return result;
        };

        /**
         * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
         *
         * @param {Matrix3} matrix The matrix on the left-hand side.
         * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         *
         *
         * @example
         * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);
         * Cesium.Matrix3.multiplyByScale(m, scale, m);
         * 
         * @see Matrix3.fromScale
         * @see Matrix3.multiplyByUniformScale
         */
        Matrix3.multiplyByScale = function (matrix, scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(scale)) {
                throw new DeveloperError('scale is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = matrix[0] * scale.x;
            result[1] = matrix[1] * scale.x;
            result[2] = matrix[2] * scale.x;
            result[3] = matrix[3] * scale.y;
            result[4] = matrix[4] * scale.y;
            result[5] = matrix[5] * scale.y;
            result[6] = matrix[6] * scale.z;
            result[7] = matrix[7] * scale.z;
            result[8] = matrix[8] * scale.z;
            return result;
        };

        /**
         * Creates a negated copy of the provided matrix.
         *
         * @param {Matrix3} matrix The matrix to negate.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.negate = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = -matrix[0];
            result[1] = -matrix[1];
            result[2] = -matrix[2];
            result[3] = -matrix[3];
            result[4] = -matrix[4];
            result[5] = -matrix[5];
            result[6] = -matrix[6];
            result[7] = -matrix[7];
            result[8] = -matrix[8];
            return result;
        };

        /**
         * Computes the transpose of the provided matrix.
         *
         * @param {Matrix3} matrix The matrix to transpose.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.transpose = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var column0Row0 = matrix[0];
            var column0Row1 = matrix[3];
            var column0Row2 = matrix[6];
            var column1Row0 = matrix[1];
            var column1Row1 = matrix[4];
            var column1Row2 = matrix[7];
            var column2Row0 = matrix[2];
            var column2Row1 = matrix[5];
            var column2Row2 = matrix[8];

            result[0] = column0Row0;
            result[1] = column0Row1;
            result[2] = column0Row2;
            result[3] = column1Row0;
            result[4] = column1Row1;
            result[5] = column1Row2;
            result[6] = column2Row0;
            result[7] = column2Row1;
            result[8] = column2Row2;
            return result;
        };

        function computeFrobeniusNorm(matrix) {
            var norm = 0.0;
            for (var i = 0; i < 9; ++i) {
                var temp = matrix[i];
                norm += temp * temp;
            }

            return Math.sqrt(norm);
        }

        var rowVal = [1, 0, 0];
        var colVal = [2, 2, 1];

        function offDiagonalFrobeniusNorm(matrix) {
            // Computes the "off-diagonal" Frobenius norm.
            // Assumes matrix is symmetric.

            var norm = 0.0;
            for (var i = 0; i < 3; ++i) {
                var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
                norm += 2.0 * temp * temp;
            }

            return Math.sqrt(norm);
        }

        function shurDecomposition(matrix, result) {
            // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
            // section 8.4.2 The 2by2 Symmetric Schur Decomposition.
            //
            // The routine takes a matrix, which is assumed to be symmetric, and
            // finds the largest off-diagonal term, and then creates
            // a matrix (result) which can be used to help reduce it

            var tolerance = CesiumMath.EPSILON15;

            var maxDiagonal = 0.0;
            var rotAxis = 1;

            // find pivot (rotAxis) based on max diagonal of matrix
            for (var i = 0; i < 3; ++i) {
                var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);
                if (temp > maxDiagonal) {
                    rotAxis = i;
                    maxDiagonal = temp;
                }
            }

            var c = 1.0;
            var s = 0.0;

            var p = rowVal[rotAxis];
            var q = colVal[rotAxis];

            if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
                var qq = matrix[Matrix3.getElementIndex(q, q)];
                var pp = matrix[Matrix3.getElementIndex(p, p)];
                var qp = matrix[Matrix3.getElementIndex(q, p)];

                var tau = (qq - pp) / 2.0 / qp;
                var t;

                if (tau < 0.0) {
                    t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));
                } else {
                    t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));
                }

                c = 1.0 / Math.sqrt(1.0 + t * t);
                s = t * c;
            }

            result = Matrix3.clone(Matrix3.IDENTITY, result);

            result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
            result[Matrix3.getElementIndex(q, p)] = s;
            result[Matrix3.getElementIndex(p, q)] = -s;

            return result;
        }

        var jMatrix = new Matrix3();
        var jMatrixTranspose = new Matrix3();

        /**
         * Computes the eigenvectors and eigenvalues of a symmetric matrix.
         * <p>
         * Returns a diagonal matrix and unitary matrix such that:
         * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
         * </p>
         * <p>
         * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
         * of the unitary matrix are the corresponding eigenvectors.
         * </p>
         *
         * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
         * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.
         * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.
         *
         * @example
         * var a = //... symetric matrix
         * var result = {
         *     unitary : new Cesium.Matrix3(),
         *     diagonal : new Cesium.Matrix3()
         * };
         * Cesium.Matrix3.computeEigenDecomposition(a, result);
         *
         * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());
         * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());
         * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
         *
         * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue
         * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector
         * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)
         */
        Matrix3.computeEigenDecomposition = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }
            //>>includeEnd('debug');

            // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,
            // section 8.4.3 The Classical Jacobi Algorithm

            var tolerance = CesiumMath.EPSILON20;
            var maxSweeps = 10;

            var count = 0;
            var sweep = 0;

            if (!defined(result)) {
                result = {};
            }

            var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);
            var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);

            var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);

            while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
                shurDecomposition(diagMatrix, jMatrix);
                Matrix3.transpose(jMatrix, jMatrixTranspose);
                Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
                Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
                Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);

                if (++count > 2) {
                    ++sweep;
                    count = 0;
                }
            }

            return result;
        };

        /**
         * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
         *
         * @param {Matrix3} matrix The matrix with signed elements.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         */
        Matrix3.abs = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = Math.abs(matrix[0]);
            result[1] = Math.abs(matrix[1]);
            result[2] = Math.abs(matrix[2]);
            result[3] = Math.abs(matrix[3]);
            result[4] = Math.abs(matrix[4]);
            result[5] = Math.abs(matrix[5]);
            result[6] = Math.abs(matrix[6]);
            result[7] = Math.abs(matrix[7]);
            result[8] = Math.abs(matrix[8]);

            return result;
        };

        /**
         * Computes the determinant of the provided matrix.
         *
         * @param {Matrix3} matrix The matrix to use.
         * @returns {Number} The value of the determinant of the matrix.
         */
        Matrix3.determinant = function (matrix) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            //>>includeEnd('debug');

            var m11 = matrix[0];
            var m21 = matrix[3];
            var m31 = matrix[6];
            var m12 = matrix[1];
            var m22 = matrix[4];
            var m32 = matrix[7];
            var m13 = matrix[2];
            var m23 = matrix[5];
            var m33 = matrix[8];

            return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
        };

        /**
         * Computes the inverse of the provided matrix.
         *
         * @param {Matrix3} matrix The matrix to invert.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         *
         * @exception {DeveloperError} matrix is not invertible.
         */
        Matrix3.inverse = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var m11 = matrix[0];
            var m21 = matrix[1];
            var m31 = matrix[2];
            var m12 = matrix[3];
            var m22 = matrix[4];
            var m32 = matrix[5];
            var m13 = matrix[6];
            var m23 = matrix[7];
            var m33 = matrix[8];

            var determinant = Matrix3.determinant(matrix);

            if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
                throw new DeveloperError('matrix is not invertible');
            }

            result[0] = m22 * m33 - m23 * m32;
            result[1] = m23 * m31 - m21 * m33;
            result[2] = m21 * m32 - m22 * m31;
            result[3] = m13 * m32 - m12 * m33;
            result[4] = m11 * m33 - m13 * m31;
            result[5] = m12 * m31 - m11 * m32;
            result[6] = m12 * m23 - m13 * m22;
            result[7] = m13 * m21 - m11 * m23;
            result[8] = m11 * m22 - m12 * m21;

            var scale = 1.0 / determinant;
            return Matrix3.multiplyByScalar(result, scale, result);
        };

        /**
         * Compares the provided matrices componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Matrix3} [left] The first matrix.
         * @param {Matrix3} [right] The second matrix.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Matrix3.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8];
        };

        /**
         * Compares the provided matrices componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Matrix3} [left] The first matrix.
         * @param {Matrix3} [right] The second matrix.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Matrix3.equalsEpsilon = function (left, right, epsilon) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof epsilon !== 'number') {
                throw new DeveloperError('epsilon must be a number');
            }
            //>>includeEnd('debug');

            return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon;
        };

        /**
         * An immutable Matrix3 instance initialized to the identity matrix.
         *
         * @type {Matrix3}
         * @constant
         */
        Matrix3.IDENTITY = freezeObject(new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0));

        /**
         * An immutable Matrix3 instance initialized to the zero matrix.
         *
         * @type {Matrix3}
         * @constant
         */
        Matrix3.ZERO = freezeObject(new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

        /**
         * The index into Matrix3 for column 0, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN0ROW0 = 0;

        /**
         * The index into Matrix3 for column 0, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN0ROW1 = 1;

        /**
         * The index into Matrix3 for column 0, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN0ROW2 = 2;

        /**
         * The index into Matrix3 for column 1, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN1ROW0 = 3;

        /**
         * The index into Matrix3 for column 1, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN1ROW1 = 4;

        /**
         * The index into Matrix3 for column 1, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN1ROW2 = 5;

        /**
         * The index into Matrix3 for column 2, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN2ROW0 = 6;

        /**
         * The index into Matrix3 for column 2, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN2ROW1 = 7;

        /**
         * The index into Matrix3 for column 2, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix3.COLUMN2ROW2 = 8;

        defineProperties(Matrix3.prototype, {
            /**
             * Gets the number of items in the collection.
             * @memberof Matrix3.prototype
             *
             * @type {Number}
             */
            length: {
                get: function () {
                    return Matrix3.packedLength;
                }
            }
        });

        /**
         * Duplicates the provided Matrix3 instance.
         *
         * @param {Matrix3} [result] The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
         */
        Matrix3.prototype.clone = function (result) {
            return Matrix3.clone(this, result);
        };

        /**
         * Compares this matrix to the provided matrix componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Matrix3} [right] The right hand side matrix.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        Matrix3.prototype.equals = function (right) {
            return Matrix3.equals(this, right);
        };

        /**
         * @private
         */
        Matrix3.equalsArray = function (matrix, array, offset) {
            return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];
        };

        /**
         * Compares this matrix to the provided matrix componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Matrix3} [right] The right hand side matrix.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
         */
        Matrix3.prototype.equalsEpsilon = function (right, epsilon) {
            return Matrix3.equalsEpsilon(this, right, epsilon);
        };

        /**
         * Creates a string representing this Matrix with each row being
         * on a separate line and in the format '(column0, column1, column2)'.
         *
         * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
         */
        Matrix3.prototype.toString = function () {
            return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' + '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' + '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
        };

        return Matrix3;
    }).call(this, $__require('35'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('28'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('41', ['23'], false, function ($__require, $__exports, $__module) {
    return (function (defined) {
        'use strict';

        /**
         * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
         * out of memory, could not compile shader, etc.  If a function may throw this
         * exception, the calling code should be prepared to catch it.
         * <br /><br />
         * On the other hand, a {@link DeveloperError} indicates an exception due
         * to a developer error, e.g., invalid argument, that usually indicates a bug in the
         * calling code.
         *
         * @alias RuntimeError
         * @constructor
         * @extends Error
         *
         * @param {String} [message] The error message for this exception.
         *
         * @see DeveloperError
         */

        function RuntimeError(message) {
            /**
             * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
             * @type {String}
             * @readonly
             */
            this.name = 'RuntimeError';

            /**
             * The explanation for why this exception was thrown.
             * @type {String}
             * @readonly
             */
            this.message = message;

            //Browsers such as IE don't have a stack property until you actually throw the error.
            var stack;
            try {
                throw new Error();
            } catch (e) {
                stack = e.stack;
            }

            /**
             * The stack trace of this exception, if available.
             * @type {String}
             * @readonly
             */
            this.stack = stack;
        }

        if (defined(Object.create)) {
            RuntimeError.prototype = Object.create(Error.prototype);
            RuntimeError.prototype.constructor = RuntimeError;
        }

        RuntimeError.prototype.toString = function () {
            var str = this.name + ': ' + this.message;

            if (defined(this.stack)) {
                str += '\n' + this.stack.toString();
            }

            return str;
        };

        return RuntimeError;
    }).call(this, $__require('23'));
});
/*global define*/
$__System.registerDynamic('3c', ['35', '4c', '2c', '23', '24', '25', '28', '30', '3b', '41'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartesian4, defaultValue, defined, defineProperties, DeveloperError, freezeObject, CesiumMath, Matrix3, RuntimeError) {
        'use strict';

        /**
         * A 4x4 matrix, indexable as a column-major order array.
         * Constructor parameters are in row-major order for code readability.
         * @alias Matrix4
         * @constructor
         *
         * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
         * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
         * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
         * @param {Number} [column3Row0=0.0] The value for column 3, row 0.
         * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
         * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
         * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
         * @param {Number} [column3Row1=0.0] The value for column 3, row 1.
         * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
         * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
         * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
         * @param {Number} [column3Row2=0.0] The value for column 3, row 2.
         * @param {Number} [column0Row3=0.0] The value for column 0, row 3.
         * @param {Number} [column1Row3=0.0] The value for column 1, row 3.
         * @param {Number} [column2Row3=0.0] The value for column 2, row 3.
         * @param {Number} [column3Row3=0.0] The value for column 3, row 3.
         *
         * @see Matrix4.fromColumnMajorArray
         * @see Matrix4.fromRowMajorArray
         * @see Matrix4.fromRotationTranslation
         * @see Matrix4.fromTranslationRotationScale
         * @see Matrix4.fromTranslationQuaternionRotationScale
         * @see Matrix4.fromTranslation
         * @see Matrix4.fromScale
         * @see Matrix4.fromUniformScale
         * @see Matrix4.fromCamera
         * @see Matrix4.computePerspectiveFieldOfView
         * @see Matrix4.computeOrthographicOffCenter
         * @see Matrix4.computePerspectiveOffCenter
         * @see Matrix4.computeInfinitePerspectiveOffCenter
         * @see Matrix4.computeViewportTransformation
         * @see Matrix4.computeView
         * @see Matrix2
         * @see Matrix3
         * @see Packable
         */

        function Matrix4(column0Row0, column1Row0, column2Row0, column3Row0, column0Row1, column1Row1, column2Row1, column3Row1, column0Row2, column1Row2, column2Row2, column3Row2, column0Row3, column1Row3, column2Row3, column3Row3) {
            this[0] = defaultValue(column0Row0, 0.0);
            this[1] = defaultValue(column0Row1, 0.0);
            this[2] = defaultValue(column0Row2, 0.0);
            this[3] = defaultValue(column0Row3, 0.0);
            this[4] = defaultValue(column1Row0, 0.0);
            this[5] = defaultValue(column1Row1, 0.0);
            this[6] = defaultValue(column1Row2, 0.0);
            this[7] = defaultValue(column1Row3, 0.0);
            this[8] = defaultValue(column2Row0, 0.0);
            this[9] = defaultValue(column2Row1, 0.0);
            this[10] = defaultValue(column2Row2, 0.0);
            this[11] = defaultValue(column2Row3, 0.0);
            this[12] = defaultValue(column3Row0, 0.0);
            this[13] = defaultValue(column3Row1, 0.0);
            this[14] = defaultValue(column3Row2, 0.0);
            this[15] = defaultValue(column3Row3, 0.0);
        }

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Matrix4.packedLength = 16;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Matrix4} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Matrix4.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }

            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            array[startingIndex++] = value[0];
            array[startingIndex++] = value[1];
            array[startingIndex++] = value[2];
            array[startingIndex++] = value[3];
            array[startingIndex++] = value[4];
            array[startingIndex++] = value[5];
            array[startingIndex++] = value[6];
            array[startingIndex++] = value[7];
            array[startingIndex++] = value[8];
            array[startingIndex++] = value[9];
            array[startingIndex++] = value[10];
            array[startingIndex++] = value[11];
            array[startingIndex++] = value[12];
            array[startingIndex++] = value[13];
            array[startingIndex++] = value[14];
            array[startingIndex] = value[15];
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Matrix4} [result] The object into which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
         */
        Matrix4.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Matrix4();
            }

            result[0] = array[startingIndex++];
            result[1] = array[startingIndex++];
            result[2] = array[startingIndex++];
            result[3] = array[startingIndex++];
            result[4] = array[startingIndex++];
            result[5] = array[startingIndex++];
            result[6] = array[startingIndex++];
            result[7] = array[startingIndex++];
            result[8] = array[startingIndex++];
            result[9] = array[startingIndex++];
            result[10] = array[startingIndex++];
            result[11] = array[startingIndex++];
            result[12] = array[startingIndex++];
            result[13] = array[startingIndex++];
            result[14] = array[startingIndex++];
            result[15] = array[startingIndex];
            return result;
        };

        /**
         * Duplicates a Matrix4 instance.
         *
         * @param {Matrix4} matrix The matrix to duplicate.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)
         */
        Matrix4.clone = function (matrix, result) {
            if (!defined(matrix)) {
                return undefined;
            }
            if (!defined(result)) {
                return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12], matrix[1], matrix[5], matrix[9], matrix[13], matrix[2], matrix[6], matrix[10], matrix[14], matrix[3], matrix[7], matrix[11], matrix[15]);
            }
            result[0] = matrix[0];
            result[1] = matrix[1];
            result[2] = matrix[2];
            result[3] = matrix[3];
            result[4] = matrix[4];
            result[5] = matrix[5];
            result[6] = matrix[6];
            result[7] = matrix[7];
            result[8] = matrix[8];
            result[9] = matrix[9];
            result[10] = matrix[10];
            result[11] = matrix[11];
            result[12] = matrix[12];
            result[13] = matrix[13];
            result[14] = matrix[14];
            result[15] = matrix[15];
            return result;
        };

        /**
         * Creates a Matrix4 from 16 consecutive elements in an array.
         * @function
         *
         * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
         * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
         *
         * @example
         * // Create the Matrix4:
         * // [1.0, 2.0, 3.0, 4.0]
         * // [1.0, 2.0, 3.0, 4.0]
         * // [1.0, 2.0, 3.0, 4.0]
         * // [1.0, 2.0, 3.0, 4.0]
         *
         * var v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
         * var m = Cesium.Matrix4.fromArray(v);
         *
         * // Create same Matrix4 with using an offset into an array
         * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
         * var m2 = Cesium.Matrix4.fromArray(v2, 2);
         */
        Matrix4.fromArray = Matrix4.unpack;

        /**
         * Computes a Matrix4 instance from a column-major order array.
         *
         * @param {Number[]} values The column-major order array.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         */
        Matrix4.fromColumnMajorArray = function (values, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(values)) {
                throw new DeveloperError('values is required');
            }
            //>>includeEnd('debug');

            return Matrix4.clone(values, result);
        };

        /**
         * Computes a Matrix4 instance from a row-major order array.
         * The resulting matrix will be in column-major order.
         *
         * @param {Number[]} values The row-major order array.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         */
        Matrix4.fromRowMajorArray = function (values, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(values)) {
                throw new DeveloperError('values is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix4(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15]);
            }
            result[0] = values[0];
            result[1] = values[4];
            result[2] = values[8];
            result[3] = values[12];
            result[4] = values[1];
            result[5] = values[5];
            result[6] = values[9];
            result[7] = values[13];
            result[8] = values[2];
            result[9] = values[6];
            result[10] = values[10];
            result[11] = values[14];
            result[12] = values[3];
            result[13] = values[7];
            result[14] = values[11];
            result[15] = values[15];
            return result;
        };

        /**
         * Computes a Matrix4 instance from a Matrix3 representing the rotation
         * and a Cartesian3 representing the translation.
         *
         * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.
         * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         */
        Matrix4.fromRotationTranslation = function (rotation, translation, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(rotation)) {
                throw new DeveloperError('rotation is required.');
            }
            //>>includeEnd('debug');

            translation = defaultValue(translation, Cartesian3.ZERO);

            if (!defined(result)) {
                return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x, rotation[1], rotation[4], rotation[7], translation.y, rotation[2], rotation[5], rotation[8], translation.z, 0.0, 0.0, 0.0, 1.0);
            }

            result[0] = rotation[0];
            result[1] = rotation[1];
            result[2] = rotation[2];
            result[3] = 0.0;
            result[4] = rotation[3];
            result[5] = rotation[4];
            result[6] = rotation[5];
            result[7] = 0.0;
            result[8] = rotation[6];
            result[9] = rotation[7];
            result[10] = rotation[8];
            result[11] = 0.0;
            result[12] = translation.x;
            result[13] = translation.y;
            result[14] = translation.z;
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
         * representation with the rotation represented as a quaternion.
         *
         * @param {Cartesian3} translation The translation transformation.
         * @param {Quaternion} rotation The rotation transformation.
         * @param {Cartesian3} scale The non-uniform scale transformation.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         *
         * @example
         * var result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(
         *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation
         *   Cesium.Quaternion.IDENTITY,           // rotation
         *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale
         *   result);
         */
        Matrix4.fromTranslationQuaternionRotationScale = function (translation, rotation, scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(translation)) {
                throw new DeveloperError('translation is required.');
            }
            if (!defined(rotation)) {
                throw new DeveloperError('rotation is required.');
            }
            if (!defined(scale)) {
                throw new DeveloperError('scale is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Matrix4();
            }

            var scaleX = scale.x;
            var scaleY = scale.y;
            var scaleZ = scale.z;

            var x2 = rotation.x * rotation.x;
            var xy = rotation.x * rotation.y;
            var xz = rotation.x * rotation.z;
            var xw = rotation.x * rotation.w;
            var y2 = rotation.y * rotation.y;
            var yz = rotation.y * rotation.z;
            var yw = rotation.y * rotation.w;
            var z2 = rotation.z * rotation.z;
            var zw = rotation.z * rotation.w;
            var w2 = rotation.w * rotation.w;

            var m00 = x2 - y2 - z2 + w2;
            var m01 = 2.0 * (xy - zw);
            var m02 = 2.0 * (xz + yw);

            var m10 = 2.0 * (xy + zw);
            var m11 = -x2 + y2 - z2 + w2;
            var m12 = 2.0 * (yz - xw);

            var m20 = 2.0 * (xz - yw);
            var m21 = 2.0 * (yz + xw);
            var m22 = -x2 - y2 + z2 + w2;

            result[0] = m00 * scaleX;
            result[1] = m10 * scaleX;
            result[2] = m20 * scaleX;
            result[3] = 0.0;
            result[4] = m01 * scaleY;
            result[5] = m11 * scaleY;
            result[6] = m21 * scaleY;
            result[7] = 0.0;
            result[8] = m02 * scaleZ;
            result[9] = m12 * scaleZ;
            result[10] = m22 * scaleZ;
            result[11] = 0.0;
            result[12] = translation.x;
            result[13] = translation.y;
            result[14] = translation.z;
            result[15] = 1.0;

            return result;
        };

        /**
         * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.
         *
         * @param {TranslationRotationScale} translationRotationScale The instance.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         */
        Matrix4.fromTranslationRotationScale = function (translationRotationScale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(translationRotationScale)) {
                throw new DeveloperError('translationRotationScale is required.');
            }
            //>>includeEnd('debug');

            return Matrix4.fromTranslationQuaternionRotationScale(translationRotationScale.translation, translationRotationScale.rotation, translationRotationScale.scale, result);
        };

        /**
         * Creates a Matrix4 instance from a Cartesian3 representing the translation.
         *
         * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         *
         * @see Matrix4.multiplyByTranslation
         */
        Matrix4.fromTranslation = function (translation, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(translation)) {
                throw new DeveloperError('translation is required.');
            }
            //>>includeEnd('debug');

            return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
        };

        /**
         * Computes a Matrix4 instance representing a non-uniform scale.
         *
         * @param {Cartesian3} scale The x, y, and z scale factors.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         *
         * @example
         * // Creates
         * //   [7.0, 0.0, 0.0, 0.0]
         * //   [0.0, 8.0, 0.0, 0.0]
         * //   [0.0, 0.0, 9.0, 0.0]
         * //   [0.0, 0.0, 0.0, 1.0]
         * var m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
         */
        Matrix4.fromScale = function (scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(scale)) {
                throw new DeveloperError('scale is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix4(scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, 0.0, 0.0, 0.0, 1.0);
            }

            result[0] = scale.x;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = scale.y;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 0.0;
            result[9] = 0.0;
            result[10] = scale.z;
            result[11] = 0.0;
            result[12] = 0.0;
            result[13] = 0.0;
            result[14] = 0.0;
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes a Matrix4 instance representing a uniform scale.
         *
         * @param {Number} scale The uniform scale factor.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         *
         * @example
         * // Creates
         * //   [2.0, 0.0, 0.0, 0.0]
         * //   [0.0, 2.0, 0.0, 0.0]
         * //   [0.0, 0.0, 2.0, 0.0]
         * //   [0.0, 0.0, 0.0, 1.0]
         * var m = Cesium.Matrix4.fromUniformScale(2.0);
         */
        Matrix4.fromUniformScale = function (scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof scale !== 'number') {
                throw new DeveloperError('scale is required.');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return new Matrix4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0);
            }

            result[0] = scale;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = scale;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 0.0;
            result[9] = 0.0;
            result[10] = scale;
            result[11] = 0.0;
            result[12] = 0.0;
            result[13] = 0.0;
            result[14] = 0.0;
            result[15] = 1.0;
            return result;
        };

        var fromCameraF = new Cartesian3();
        var fromCameraR = new Cartesian3();
        var fromCameraU = new Cartesian3();

        /**
         * Computes a Matrix4 instance from a Camera.
         *
         * @param {Camera} camera The camera to use.
         * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
         * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
         */
        Matrix4.fromCamera = function (camera, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(camera)) {
                throw new DeveloperError('camera is required.');
            }
            //>>includeEnd('debug');

            var position = camera.position;
            var direction = camera.direction;
            var up = camera.up;

            //>>includeStart('debug', pragmas.debug);
            if (!defined(position)) {
                throw new DeveloperError('camera.position is required.');
            }
            if (!defined(direction)) {
                throw new DeveloperError('camera.direction is required.');
            }
            if (!defined(up)) {
                throw new DeveloperError('camera.up is required.');
            }
            //>>includeEnd('debug');

            Cartesian3.normalize(direction, fromCameraF);
            Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraR), fromCameraR);
            Cartesian3.normalize(Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU), fromCameraU);

            var sX = fromCameraR.x;
            var sY = fromCameraR.y;
            var sZ = fromCameraR.z;
            var fX = fromCameraF.x;
            var fY = fromCameraF.y;
            var fZ = fromCameraF.z;
            var uX = fromCameraU.x;
            var uY = fromCameraU.y;
            var uZ = fromCameraU.z;
            var positionX = position.x;
            var positionY = position.y;
            var positionZ = position.z;
            var t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;
            var t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;
            var t2 = fX * positionX + fY * positionY + fZ * positionZ;

            // The code below this comment is an optimized
            // version of the commented lines.
            // Rather that create two matrices and then multiply,
            // we just bake in the multiplcation as part of creation.
            // var rotation = new Matrix4(
            //                 sX,  sY,  sZ, 0.0,
            //                 uX,  uY,  uZ, 0.0,
            //                -fX, -fY, -fZ, 0.0,
            //                 0.0,  0.0,  0.0, 1.0);
            // var translation = new Matrix4(
            //                 1.0, 0.0, 0.0, -position.x,
            //                 0.0, 1.0, 0.0, -position.y,
            //                 0.0, 0.0, 1.0, -position.z,
            //                 0.0, 0.0, 0.0, 1.0);
            // return rotation.multiply(translation);
            if (!defined(result)) {
                return new Matrix4(sX, sY, sZ, t0, uX, uY, uZ, t1, -fX, -fY, -fZ, t2, 0.0, 0.0, 0.0, 1.0);
            }
            result[0] = sX;
            result[1] = uX;
            result[2] = -fX;
            result[3] = 0.0;
            result[4] = sY;
            result[5] = uY;
            result[6] = -fY;
            result[7] = 0.0;
            result[8] = sZ;
            result[9] = uZ;
            result[10] = -fZ;
            result[11] = 0.0;
            result[12] = t0;
            result[13] = t1;
            result[14] = t2;
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes a Matrix4 instance representing a perspective transformation matrix.
         *
         * @param {Number} fovY The field of view along the Y axis in radians.
         * @param {Number} aspectRatio The aspect ratio.
         * @param {Number} near The distance to the near plane in meters.
         * @param {Number} far The distance to the far plane in meters.
         * @param {Matrix4} result The object in which the result will be stored.
         * @returns {Matrix4} The modified result parameter.
         *
         * @exception {DeveloperError} fovY must be in [0, PI).
         * @exception {DeveloperError} aspectRatio must be greater than zero.
         * @exception {DeveloperError} near must be greater than zero.
         * @exception {DeveloperError} far must be greater than zero.
         */
        Matrix4.computePerspectiveFieldOfView = function (fovY, aspectRatio, near, far, result) {
            //>>includeStart('debug', pragmas.debug);
            if (fovY <= 0.0 || fovY > Math.PI) {
                throw new DeveloperError('fovY must be in [0, PI).');
            }
            if (aspectRatio <= 0.0) {
                throw new DeveloperError('aspectRatio must be greater than zero.');
            }
            if (near <= 0.0) {
                throw new DeveloperError('near must be greater than zero.');
            }
            if (far <= 0.0) {
                throw new DeveloperError('far must be greater than zero.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var bottom = Math.tan(fovY * 0.5);

            var column1Row1 = 1.0 / bottom;
            var column0Row0 = column1Row1 / aspectRatio;
            var column2Row2 = (far + near) / (near - far);
            var column3Row2 = 2.0 * far * near / (near - far);

            result[0] = column0Row0;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = column1Row1;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 0.0;
            result[9] = 0.0;
            result[10] = column2Row2;
            result[11] = -1.0;
            result[12] = 0.0;
            result[13] = 0.0;
            result[14] = column3Row2;
            result[15] = 0.0;
            return result;
        };

        /**
        * Computes a Matrix4 instance representing an orthographic transformation matrix.
        *
        * @param {Number} left The number of meters to the left of the camera that will be in view.
        * @param {Number} right The number of meters to the right of the camera that will be in view.
        * @param {Number} bottom The number of meters below of the camera that will be in view.
        * @param {Number} top The number of meters above of the camera that will be in view.
        * @param {Number} near The distance to the near plane in meters.
        * @param {Number} far The distance to the far plane in meters.
        * @param {Matrix4} result The object in which the result will be stored.
        * @returns {Matrix4} The modified result parameter.
        */
        Matrix4.computeOrthographicOffCenter = function (left, right, bottom, top, near, far, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required.');
            }
            if (!defined(bottom)) {
                throw new DeveloperError('bottom is required.');
            }
            if (!defined(top)) {
                throw new DeveloperError('top is required.');
            }
            if (!defined(near)) {
                throw new DeveloperError('near is required.');
            }
            if (!defined(far)) {
                throw new DeveloperError('far is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var a = 1.0 / (right - left);
            var b = 1.0 / (top - bottom);
            var c = 1.0 / (far - near);

            var tx = -(right + left) * a;
            var ty = -(top + bottom) * b;
            var tz = -(far + near) * c;
            a *= 2.0;
            b *= 2.0;
            c *= -2.0;

            result[0] = a;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = b;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 0.0;
            result[9] = 0.0;
            result[10] = c;
            result[11] = 0.0;
            result[12] = tx;
            result[13] = ty;
            result[14] = tz;
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes a Matrix4 instance representing an off center perspective transformation.
         *
         * @param {Number} left The number of meters to the left of the camera that will be in view.
         * @param {Number} right The number of meters to the right of the camera that will be in view.
         * @param {Number} bottom The number of meters below of the camera that will be in view.
         * @param {Number} top The number of meters above of the camera that will be in view.
         * @param {Number} near The distance to the near plane in meters.
         * @param {Number} far The distance to the far plane in meters.
         * @param {Matrix4} result The object in which the result will be stored.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.computePerspectiveOffCenter = function (left, right, bottom, top, near, far, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required.');
            }
            if (!defined(bottom)) {
                throw new DeveloperError('bottom is required.');
            }
            if (!defined(top)) {
                throw new DeveloperError('top is required.');
            }
            if (!defined(near)) {
                throw new DeveloperError('near is required.');
            }
            if (!defined(far)) {
                throw new DeveloperError('far is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var column0Row0 = 2.0 * near / (right - left);
            var column1Row1 = 2.0 * near / (top - bottom);
            var column2Row0 = (right + left) / (right - left);
            var column2Row1 = (top + bottom) / (top - bottom);
            var column2Row2 = -(far + near) / (far - near);
            var column2Row3 = -1.0;
            var column3Row2 = -2.0 * far * near / (far - near);

            result[0] = column0Row0;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = column1Row1;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = column2Row0;
            result[9] = column2Row1;
            result[10] = column2Row2;
            result[11] = column2Row3;
            result[12] = 0.0;
            result[13] = 0.0;
            result[14] = column3Row2;
            result[15] = 0.0;
            return result;
        };

        /**
         * Computes a Matrix4 instance representing an infinite off center perspective transformation.
         *
         * @param {Number} left The number of meters to the left of the camera that will be in view.
         * @param {Number} right The number of meters to the right of the camera that will be in view.
         * @param {Number} bottom The number of meters below of the camera that will be in view.
         * @param {Number} top The number of meters above of the camera that will be in view.
         * @param {Number} near The distance to the near plane in meters.
         * @param {Matrix4} result The object in which the result will be stored.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.computeInfinitePerspectiveOffCenter = function (left, right, bottom, top, near, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required.');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required.');
            }
            if (!defined(bottom)) {
                throw new DeveloperError('bottom is required.');
            }
            if (!defined(top)) {
                throw new DeveloperError('top is required.');
            }
            if (!defined(near)) {
                throw new DeveloperError('near is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var column0Row0 = 2.0 * near / (right - left);
            var column1Row1 = 2.0 * near / (top - bottom);
            var column2Row0 = (right + left) / (right - left);
            var column2Row1 = (top + bottom) / (top - bottom);
            var column2Row2 = -1.0;
            var column2Row3 = -1.0;
            var column3Row2 = -2.0 * near;

            result[0] = column0Row0;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = column1Row1;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = column2Row0;
            result[9] = column2Row1;
            result[10] = column2Row2;
            result[11] = column2Row3;
            result[12] = 0.0;
            result[13] = 0.0;
            result[14] = column3Row2;
            result[15] = 0.0;
            return result;
        };

        /**
         * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
         *
         * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
         * @param {Number}[nearDepthRange=0.0] The near plane distance in window coordinates.
         * @param {Number}[farDepthRange=1.0] The far plane distance in window coordinates.
         * @param {Matrix4} result The object in which the result will be stored.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * // Create viewport transformation using an explicit viewport and depth range.
         * var m = Cesium.Matrix4.computeViewportTransformation({
         *     x : 0.0,
         *     y : 0.0,
         *     width : 1024.0,
         *     height : 768.0
         * }, 0.0, 1.0, new Cesium.Matrix4());
         */
        Matrix4.computeViewportTransformation = function (viewport, nearDepthRange, farDepthRange, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);
            var x = defaultValue(viewport.x, 0.0);
            var y = defaultValue(viewport.y, 0.0);
            var width = defaultValue(viewport.width, 0.0);
            var height = defaultValue(viewport.height, 0.0);
            nearDepthRange = defaultValue(nearDepthRange, 0.0);
            farDepthRange = defaultValue(farDepthRange, 1.0);

            var halfWidth = width * 0.5;
            var halfHeight = height * 0.5;
            var halfDepth = (farDepthRange - nearDepthRange) * 0.5;

            var column0Row0 = halfWidth;
            var column1Row1 = halfHeight;
            var column2Row2 = halfDepth;
            var column3Row0 = x + halfWidth;
            var column3Row1 = y + halfHeight;
            var column3Row2 = nearDepthRange + halfDepth;
            var column3Row3 = 1.0;

            result[0] = column0Row0;
            result[1] = 0.0;
            result[2] = 0.0;
            result[3] = 0.0;
            result[4] = 0.0;
            result[5] = column1Row1;
            result[6] = 0.0;
            result[7] = 0.0;
            result[8] = 0.0;
            result[9] = 0.0;
            result[10] = column2Row2;
            result[11] = 0.0;
            result[12] = column3Row0;
            result[13] = column3Row1;
            result[14] = column3Row2;
            result[15] = column3Row3;
            return result;
        };

        /**
         * Computes a Matrix4 instance that transforms from world space to view space.
         *
         * @param {Cartesian3} position The position of the camera.
         * @param {Cartesian3} direction The forward direction.
         * @param {Cartesian3} up The up direction.
         * @param {Cartesian3} right The right direction.
         * @param {Matrix4} result The object in which the result will be stored.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.computeView = function (position, direction, up, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(position)) {
                throw new DeveloperError('position is required');
            }
            if (!defined(direction)) {
                throw new DeveloperError('direction is required');
            }
            if (!defined(up)) {
                throw new DeveloperError('up is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = right.x;
            result[1] = up.x;
            result[2] = -direction.x;
            result[3] = 0.0;
            result[4] = right.y;
            result[5] = up.y;
            result[6] = -direction.y;
            result[7] = 0.0;
            result[8] = right.z;
            result[9] = up.z;
            result[10] = -direction.z;
            result[11] = 0.0;
            result[12] = -Cartesian3.dot(right, position);
            result[13] = -Cartesian3.dot(up, position);
            result[14] = Cartesian3.dot(direction, position);
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes an Array from the provided Matrix4 instance.
         * The array will be in column-major order.
         *
         * @param {Matrix4} matrix The matrix to use..
         * @param {Number[]} [result] The Array onto which to store the result.
         * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
         *
         * @example
         * //create an array from an instance of Matrix4
         * // m = [10.0, 14.0, 18.0, 22.0]
         * //     [11.0, 15.0, 19.0, 23.0]
         * //     [12.0, 16.0, 20.0, 24.0]
         * //     [13.0, 17.0, 21.0, 25.0]
         * var a = Cesium.Matrix4.toArray(m);
         *
         * // m remains the same
         * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
         */
        Matrix4.toArray = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8], matrix[9], matrix[10], matrix[11], matrix[12], matrix[13], matrix[14], matrix[15]];
            }
            result[0] = matrix[0];
            result[1] = matrix[1];
            result[2] = matrix[2];
            result[3] = matrix[3];
            result[4] = matrix[4];
            result[5] = matrix[5];
            result[6] = matrix[6];
            result[7] = matrix[7];
            result[8] = matrix[8];
            result[9] = matrix[9];
            result[10] = matrix[10];
            result[11] = matrix[11];
            result[12] = matrix[12];
            result[13] = matrix[13];
            result[14] = matrix[14];
            result[15] = matrix[15];
            return result;
        };

        /**
         * Computes the array index of the element at the provided row and column.
         *
         * @param {Number} row The zero-based index of the row.
         * @param {Number} column The zero-based index of the column.
         * @returns {Number} The index of the element at the provided row and column.
         *
         * @exception {DeveloperError} row must be 0, 1, 2, or 3.
         * @exception {DeveloperError} column must be 0, 1, 2, or 3.
         *
         * @example
         * var myMatrix = new Cesium.Matrix4();
         * var column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);
         * var column1Row0 = myMatrix[column1Row0Index];
         * myMatrix[column1Row0Index] = 10.0;
         */
        Matrix4.getElementIndex = function (column, row) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof row !== 'number' || row < 0 || row > 3) {
                throw new DeveloperError('row must be 0, 1, 2, or 3.');
            }
            if (typeof column !== 'number' || column < 0 || column > 3) {
                throw new DeveloperError('column must be 0, 1, 2, or 3.');
            }
            //>>includeEnd('debug');

            return column * 4 + row;
        };

        /**
         * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Number} index The zero-based index of the column to retrieve.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, 2, or 3.
         *
         * @example
         * //returns a Cartesian4 instance with values from the specified column
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * //Example 1: Creates an instance of Cartesian
         * var a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());
         *
         * @example
         * //Example 2: Sets values for Cartesian instance
         * var a = new Cesium.Cartesian4();
         * Cesium.Matrix4.getColumn(m, 2, a);
         *
         * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
         */
        Matrix4.getColumn = function (matrix, index, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }

            if (typeof index !== 'number' || index < 0 || index > 3) {
                throw new DeveloperError('index must be 0, 1, 2, or 3.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var startIndex = index * 4;
            var x = matrix[startIndex];
            var y = matrix[startIndex + 1];
            var z = matrix[startIndex + 2];
            var w = matrix[startIndex + 3];

            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        /**
         * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Number} index The zero-based index of the column to set.
         * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, 2, or 3.
         *
         * @example
         * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * var a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
         *
         * // m remains the same
         * // a = [10.0, 11.0, 99.0, 13.0]
         * //     [14.0, 15.0, 98.0, 17.0]
         * //     [18.0, 19.0, 97.0, 21.0]
         * //     [22.0, 23.0, 96.0, 25.0]
         */
        Matrix4.setColumn = function (matrix, index, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof index !== 'number' || index < 0 || index > 3) {
                throw new DeveloperError('index must be 0, 1, 2, or 3.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result = Matrix4.clone(matrix, result);
            var startIndex = index * 4;
            result[startIndex] = cartesian.x;
            result[startIndex + 1] = cartesian.y;
            result[startIndex + 2] = cartesian.z;
            result[startIndex + 3] = cartesian.w;
            return result;
        };

        /**
         * Computes a new matrix that replaces the translation in the rightmost column of the provided
         * matrix with the provided translation.  This assumes the matrix is an affine transformation
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.setTranslation = function (matrix, translation, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(translation)) {
                throw new DeveloperError('translation is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = matrix[0];
            result[1] = matrix[1];
            result[2] = matrix[2];
            result[3] = matrix[3];

            result[4] = matrix[4];
            result[5] = matrix[5];
            result[6] = matrix[6];
            result[7] = matrix[7];

            result[8] = matrix[8];
            result[9] = matrix[9];
            result[10] = matrix[10];
            result[11] = matrix[11];

            result[12] = translation.x;
            result[13] = translation.y;
            result[14] = translation.z;
            result[15] = matrix[15];

            return result;
        };

        /**
         * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Number} index The zero-based index of the row to retrieve.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, 2, or 3.
         *
         * @example
         * //returns a Cartesian4 instance with values from the specified column
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * //Example 1: Returns an instance of Cartesian
         * var a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());
         *
         * @example
         * //Example 2: Sets values for a Cartesian instance
         * var a = new Cesium.Cartesian4();
         * Cesium.Matrix4.getRow(m, 2, a);
         *
         * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
         */
        Matrix4.getRow = function (matrix, index, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }

            if (typeof index !== 'number' || index < 0 || index > 3) {
                throw new DeveloperError('index must be 0, 1, 2, or 3.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var x = matrix[index];
            var y = matrix[index + 4];
            var z = matrix[index + 8];
            var w = matrix[index + 12];

            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        /**
         * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Number} index The zero-based index of the row to set.
         * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @exception {DeveloperError} index must be 0, 1, 2, or 3.
         *
         * @example
         * //create a new Matrix4 instance with new row values from the Cartesian4 instance
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * var a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
         *
         * // m remains the same
         * // a = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [99.0, 98.0, 97.0, 96.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         */
        Matrix4.setRow = function (matrix, index, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof index !== 'number' || index < 0 || index > 3) {
                throw new DeveloperError('index must be 0, 1, 2, or 3.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result = Matrix4.clone(matrix, result);
            result[index] = cartesian.x;
            result[index + 4] = cartesian.y;
            result[index + 8] = cartesian.z;
            result[index + 12] = cartesian.w;
            return result;
        };

        var scratchColumn = new Cartesian3();

        /**
         * Extracts the non-uniform scale assuming the matrix is an affine transformation.
         *
         * @param {Matrix4} matrix The matrix.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter
         */
        Matrix4.getScale = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
            result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));
            result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));
            return result;
        };

        var scratchScale = new Cartesian3();

        /**
         * Computes the maximum scale assuming the matrix is an affine transformation.
         * The maximum scale is the maximum length of the column vectors in the upper-left
         * 3x3 matrix.
         *
         * @param {Matrix4} matrix The matrix.
         * @returns {Number} The maximum scale.
         */
        Matrix4.getMaximumScale = function (matrix) {
            Matrix4.getScale(matrix, scratchScale);
            return Cartesian3.maximumComponent(scratchScale);
        };

        /**
         * Computes the product of two matrices.
         *
         * @param {Matrix4} left The first matrix.
         * @param {Matrix4} right The second matrix.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.multiply = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var left0 = left[0];
            var left1 = left[1];
            var left2 = left[2];
            var left3 = left[3];
            var left4 = left[4];
            var left5 = left[5];
            var left6 = left[6];
            var left7 = left[7];
            var left8 = left[8];
            var left9 = left[9];
            var left10 = left[10];
            var left11 = left[11];
            var left12 = left[12];
            var left13 = left[13];
            var left14 = left[14];
            var left15 = left[15];

            var right0 = right[0];
            var right1 = right[1];
            var right2 = right[2];
            var right3 = right[3];
            var right4 = right[4];
            var right5 = right[5];
            var right6 = right[6];
            var right7 = right[7];
            var right8 = right[8];
            var right9 = right[9];
            var right10 = right[10];
            var right11 = right[11];
            var right12 = right[12];
            var right13 = right[13];
            var right14 = right[14];
            var right15 = right[15];

            var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
            var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
            var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
            var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;

            var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
            var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
            var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
            var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;

            var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
            var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
            var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
            var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;

            var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
            var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
            var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
            var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;

            result[0] = column0Row0;
            result[1] = column0Row1;
            result[2] = column0Row2;
            result[3] = column0Row3;
            result[4] = column1Row0;
            result[5] = column1Row1;
            result[6] = column1Row2;
            result[7] = column1Row3;
            result[8] = column2Row0;
            result[9] = column2Row1;
            result[10] = column2Row2;
            result[11] = column2Row3;
            result[12] = column3Row0;
            result[13] = column3Row1;
            result[14] = column3Row2;
            result[15] = column3Row3;
            return result;
        };

        /**
         * Computes the sum of two matrices.
         *
         * @param {Matrix4} left The first matrix.
         * @param {Matrix4} right The second matrix.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.add = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = left[0] + right[0];
            result[1] = left[1] + right[1];
            result[2] = left[2] + right[2];
            result[3] = left[3] + right[3];
            result[4] = left[4] + right[4];
            result[5] = left[5] + right[5];
            result[6] = left[6] + right[6];
            result[7] = left[7] + right[7];
            result[8] = left[8] + right[8];
            result[9] = left[9] + right[9];
            result[10] = left[10] + right[10];
            result[11] = left[11] + right[11];
            result[12] = left[12] + right[12];
            result[13] = left[13] + right[13];
            result[14] = left[14] + right[14];
            result[15] = left[15] + right[15];
            return result;
        };

        /**
         * Computes the difference of two matrices.
         *
         * @param {Matrix4} left The first matrix.
         * @param {Matrix4} right The second matrix.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.subtract = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = left[0] - right[0];
            result[1] = left[1] - right[1];
            result[2] = left[2] - right[2];
            result[3] = left[3] - right[3];
            result[4] = left[4] - right[4];
            result[5] = left[5] - right[5];
            result[6] = left[6] - right[6];
            result[7] = left[7] - right[7];
            result[8] = left[8] - right[8];
            result[9] = left[9] - right[9];
            result[10] = left[10] - right[10];
            result[11] = left[11] - right[11];
            result[12] = left[12] - right[12];
            result[13] = left[13] - right[13];
            result[14] = left[14] - right[14];
            result[15] = left[15] - right[15];
            return result;
        };

        /**
         * Computes the product of two matrices assuming the matrices are
         * affine transformation matrices, where the upper left 3x3 elements
         * are a rotation matrix, and the upper three elements in the fourth
         * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
         * The matrix is not verified to be in the proper form.
         * This method is faster than computing the product for general 4x4
         * matrices using {@link Matrix4.multiply}.
         *
         * @param {Matrix4} left The first matrix.
         * @param {Matrix4} right The second matrix.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * var m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
         * var m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));
         * var m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());
         */
        Matrix4.multiplyTransformation = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var left0 = left[0];
            var left1 = left[1];
            var left2 = left[2];
            var left4 = left[4];
            var left5 = left[5];
            var left6 = left[6];
            var left8 = left[8];
            var left9 = left[9];
            var left10 = left[10];
            var left12 = left[12];
            var left13 = left[13];
            var left14 = left[14];

            var right0 = right[0];
            var right1 = right[1];
            var right2 = right[2];
            var right4 = right[4];
            var right5 = right[5];
            var right6 = right[6];
            var right8 = right[8];
            var right9 = right[9];
            var right10 = right[10];
            var right12 = right[12];
            var right13 = right[13];
            var right14 = right[14];

            var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
            var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
            var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;

            var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
            var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
            var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;

            var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
            var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
            var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;

            var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
            var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
            var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;

            result[0] = column0Row0;
            result[1] = column0Row1;
            result[2] = column0Row2;
            result[3] = 0.0;
            result[4] = column1Row0;
            result[5] = column1Row1;
            result[6] = column1Row2;
            result[7] = 0.0;
            result[8] = column2Row0;
            result[9] = column2Row1;
            result[10] = column2Row2;
            result[11] = 0.0;
            result[12] = column3Row0;
            result[13] = column3Row1;
            result[14] = column3Row2;
            result[15] = 1.0;
            return result;
        };

        /**
         * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
         * by a 3x3 rotation matrix.  This is an optimization
         * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
         *
         * @param {Matrix4} matrix The matrix on the left-hand side.
         * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);
         * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);
         */
        Matrix4.multiplyByMatrix3 = function (matrix, rotation, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(rotation)) {
                throw new DeveloperError('rotation is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var left0 = matrix[0];
            var left1 = matrix[1];
            var left2 = matrix[2];
            var left4 = matrix[4];
            var left5 = matrix[5];
            var left6 = matrix[6];
            var left8 = matrix[8];
            var left9 = matrix[9];
            var left10 = matrix[10];

            var right0 = rotation[0];
            var right1 = rotation[1];
            var right2 = rotation[2];
            var right4 = rotation[3];
            var right5 = rotation[4];
            var right6 = rotation[5];
            var right8 = rotation[6];
            var right9 = rotation[7];
            var right10 = rotation[8];

            var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
            var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
            var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;

            var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
            var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
            var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;

            var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
            var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
            var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;

            result[0] = column0Row0;
            result[1] = column0Row1;
            result[2] = column0Row2;
            result[3] = 0.0;
            result[4] = column1Row0;
            result[5] = column1Row1;
            result[6] = column1Row2;
            result[7] = 0.0;
            result[8] = column2Row0;
            result[9] = column2Row1;
            result[10] = column2Row2;
            result[11] = 0.0;
            result[12] = matrix[12];
            result[13] = matrix[13];
            result[14] = matrix[14];
            result[15] = matrix[15];
            return result;
        };

        /**
         * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
         * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
         * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
         *
         * @param {Matrix4} matrix The matrix on the left-hand side.
         * @param {Cartesian3} translation The translation on the right-hand side.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);
         * Cesium.Matrix4.multiplyByTranslation(m, position, m);
         */
        Matrix4.multiplyByTranslation = function (matrix, translation, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(translation)) {
                throw new DeveloperError('translation is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var x = translation.x;
            var y = translation.y;
            var z = translation.z;

            var tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];
            var ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];
            var tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];

            result[0] = matrix[0];
            result[1] = matrix[1];
            result[2] = matrix[2];
            result[3] = matrix[3];
            result[4] = matrix[4];
            result[5] = matrix[5];
            result[6] = matrix[6];
            result[7] = matrix[7];
            result[8] = matrix[8];
            result[9] = matrix[9];
            result[10] = matrix[10];
            result[11] = matrix[11];
            result[12] = tx;
            result[13] = ty;
            result[14] = tz;
            result[15] = matrix[15];
            return result;
        };

        var uniformScaleScratch = new Cartesian3();

        /**
         * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
         * by an implicit uniform scale matrix.  This is an optimization
         * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
         * <code>m</code> must be an affine matrix.
         * This function performs fewer allocations and arithmetic operations.
         *
         * @param {Matrix4} matrix The affine matrix on the left-hand side.
         * @param {Number} scale The uniform scale on the right-hand side.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         *
         * @example
         * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);
         * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);
         * 
         * @see Matrix4.fromUniformScale
         * @see Matrix4.multiplyByScale
         */
        Matrix4.multiplyByUniformScale = function (matrix, scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (typeof scale !== 'number') {
                throw new DeveloperError('scale is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            uniformScaleScratch.x = scale;
            uniformScaleScratch.y = scale;
            uniformScaleScratch.z = scale;
            return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);
        };

        /**
         * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
         * by an implicit non-uniform scale matrix.  This is an optimization
         * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
         * <code>m</code> must be an affine matrix.
         * This function performs fewer allocations and arithmetic operations.
         *
         * @param {Matrix4} matrix The affine matrix on the left-hand side.
         * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         *
         * @example
         * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);
         * Cesium.Matrix4.multiplyByScale(m, scale, m);
         * 
         * @see Matrix4.fromScale
         * @see Matrix4.multiplyByUniformScale
         */
        Matrix4.multiplyByScale = function (matrix, scale, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(scale)) {
                throw new DeveloperError('scale is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var scaleX = scale.x;
            var scaleY = scale.y;
            var scaleZ = scale.z;

            // Faster than Cartesian3.equals
            if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {
                return Matrix4.clone(matrix, result);
            }

            result[0] = scaleX * matrix[0];
            result[1] = scaleX * matrix[1];
            result[2] = scaleX * matrix[2];
            result[3] = 0.0;
            result[4] = scaleY * matrix[4];
            result[5] = scaleY * matrix[5];
            result[6] = scaleY * matrix[6];
            result[7] = 0.0;
            result[8] = scaleZ * matrix[8];
            result[9] = scaleZ * matrix[9];
            result[10] = scaleZ * matrix[10];
            result[11] = 0.0;
            result[12] = matrix[12];
            result[13] = matrix[13];
            result[14] = matrix[14];
            result[15] = 1.0;
            return result;
        };

        /**
         * Computes the product of a matrix and a column vector.
         *
         * @param {Matrix4} matrix The matrix.
         * @param {Cartesian4} cartesian The vector.
         * @param {Cartesian4} result The object onto which to store the result.
         * @returns {Cartesian4} The modified result parameter.
         */
        Matrix4.multiplyByVector = function (matrix, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var vX = cartesian.x;
            var vY = cartesian.y;
            var vZ = cartesian.z;
            var vW = cartesian.w;

            var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
            var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
            var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
            var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;

            result.x = x;
            result.y = y;
            result.z = z;
            result.w = w;
            return result;
        };

        /**
         * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
         * with a {@link Cartesian4} with a <code>w</code> component of zero.
         *
         * @param {Matrix4} matrix The matrix.
         * @param {Cartesian3} cartesian The point.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         *
         * @example
         * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
         * var result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());
         * // A shortcut for
         * //   Cartesian3 p = ...
         * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);
         */
        Matrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var vX = cartesian.x;
            var vY = cartesian.y;
            var vZ = cartesian.z;

            var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
            var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
            var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
         * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
         *
         * @param {Matrix4} matrix The matrix.
         * @param {Cartesian3} cartesian The point.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         *
         * @example
         * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
         * var result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());
         */
        Matrix4.multiplyByPoint = function (matrix, cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }

            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var vX = cartesian.x;
            var vY = cartesian.y;
            var vZ = cartesian.z;

            var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
            var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
            var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Computes the product of a matrix and a scalar.
         *
         * @param {Matrix4} matrix The matrix.
         * @param {Number} scalar The number to multiply by.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * var a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());
         *
         * // m remains the same
         * // a = [-20.0, -22.0, -24.0, -26.0]
         * //     [-28.0, -30.0, -32.0, -34.0]
         * //     [-36.0, -38.0, -40.0, -42.0]
         * //     [-44.0, -46.0, -48.0, -50.0]
         */
        Matrix4.multiplyByScalar = function (matrix, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar must be a number');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = matrix[0] * scalar;
            result[1] = matrix[1] * scalar;
            result[2] = matrix[2] * scalar;
            result[3] = matrix[3] * scalar;
            result[4] = matrix[4] * scalar;
            result[5] = matrix[5] * scalar;
            result[6] = matrix[6] * scalar;
            result[7] = matrix[7] * scalar;
            result[8] = matrix[8] * scalar;
            result[9] = matrix[9] * scalar;
            result[10] = matrix[10] * scalar;
            result[11] = matrix[11] * scalar;
            result[12] = matrix[12] * scalar;
            result[13] = matrix[13] * scalar;
            result[14] = matrix[14] * scalar;
            result[15] = matrix[15] * scalar;
            return result;
        };

        /**
         * Computes a negated copy of the provided matrix.
         *
         * @param {Matrix4} matrix The matrix to negate.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * //create a new Matrix4 instance which is a negation of a Matrix4
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * var a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());
         *
         * // m remains the same
         * // a = [-10.0, -11.0, -12.0, -13.0]
         * //     [-14.0, -15.0, -16.0, -17.0]
         * //     [-18.0, -19.0, -20.0, -21.0]
         * //     [-22.0, -23.0, -24.0, -25.0]
         */
        Matrix4.negate = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = -matrix[0];
            result[1] = -matrix[1];
            result[2] = -matrix[2];
            result[3] = -matrix[3];
            result[4] = -matrix[4];
            result[5] = -matrix[5];
            result[6] = -matrix[6];
            result[7] = -matrix[7];
            result[8] = -matrix[8];
            result[9] = -matrix[9];
            result[10] = -matrix[10];
            result[11] = -matrix[11];
            result[12] = -matrix[12];
            result[13] = -matrix[13];
            result[14] = -matrix[14];
            result[15] = -matrix[15];
            return result;
        };

        /**
         * Computes the transpose of the provided matrix.
         *
         * @param {Matrix4} matrix The matrix to transpose.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @example
         * //returns transpose of a Matrix4
         * // m = [10.0, 11.0, 12.0, 13.0]
         * //     [14.0, 15.0, 16.0, 17.0]
         * //     [18.0, 19.0, 20.0, 21.0]
         * //     [22.0, 23.0, 24.0, 25.0]
         *
         * var a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());
         *
         * // m remains the same
         * // a = [10.0, 14.0, 18.0, 22.0]
         * //     [11.0, 15.0, 19.0, 23.0]
         * //     [12.0, 16.0, 20.0, 24.0]
         * //     [13.0, 17.0, 21.0, 25.0]
         */
        Matrix4.transpose = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var matrix1 = matrix[1];
            var matrix2 = matrix[2];
            var matrix3 = matrix[3];
            var matrix6 = matrix[6];
            var matrix7 = matrix[7];
            var matrix11 = matrix[11];

            result[0] = matrix[0];
            result[1] = matrix[4];
            result[2] = matrix[8];
            result[3] = matrix[12];
            result[4] = matrix1;
            result[5] = matrix[5];
            result[6] = matrix[9];
            result[7] = matrix[13];
            result[8] = matrix2;
            result[9] = matrix6;
            result[10] = matrix[10];
            result[11] = matrix[14];
            result[12] = matrix3;
            result[13] = matrix7;
            result[14] = matrix11;
            result[15] = matrix[15];
            return result;
        };

        /**
         * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
         *
         * @param {Matrix4} matrix The matrix with signed elements.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.abs = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = Math.abs(matrix[0]);
            result[1] = Math.abs(matrix[1]);
            result[2] = Math.abs(matrix[2]);
            result[3] = Math.abs(matrix[3]);
            result[4] = Math.abs(matrix[4]);
            result[5] = Math.abs(matrix[5]);
            result[6] = Math.abs(matrix[6]);
            result[7] = Math.abs(matrix[7]);
            result[8] = Math.abs(matrix[8]);
            result[9] = Math.abs(matrix[9]);
            result[10] = Math.abs(matrix[10]);
            result[11] = Math.abs(matrix[11]);
            result[12] = Math.abs(matrix[12]);
            result[13] = Math.abs(matrix[13]);
            result[14] = Math.abs(matrix[14]);
            result[15] = Math.abs(matrix[15]);

            return result;
        };

        /**
         * Compares the provided matrices componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Matrix4} [left] The first matrix.
         * @param {Matrix4} [right] The second matrix.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         *
         * @example
         * //compares two Matrix4 instances
         *
         * // a = [10.0, 14.0, 18.0, 22.0]
         * //     [11.0, 15.0, 19.0, 23.0]
         * //     [12.0, 16.0, 20.0, 24.0]
         * //     [13.0, 17.0, 21.0, 25.0]
         *
         * // b = [10.0, 14.0, 18.0, 22.0]
         * //     [11.0, 15.0, 19.0, 23.0]
         * //     [12.0, 16.0, 20.0, 24.0]
         * //     [13.0, 17.0, 21.0, 25.0]
         *
         * if(Cesium.Matrix4.equals(a,b)) {
         *      console.log("Both matrices are equal");
         * } else {
         *      console.log("They are not equal");
         * }
         *
         * //Prints "Both matrices are equal" on the console
         */
        Matrix4.equals = function (left, right) {
            // Given that most matrices will be transformation matrices, the elements
            // are tested in order such that the test is likely to fail as early
            // as possible.  I _think_ this is just as friendly to the L1 cache
            // as testing in index order.  It is certainty faster in practice.
            return left === right || defined(left) && defined(right) &&
            // Translation
            left[12] === right[12] && left[13] === right[13] && left[14] === right[14] &&

            // Rotation/scale
            left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[8] === right[8] && left[9] === right[9] && left[10] === right[10] &&

            // Bottom row
            left[3] === right[3] && left[7] === right[7] && left[11] === right[11] && left[15] === right[15];
        };

        /**
         * Compares the provided matrices componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Matrix4} [left] The first matrix.
         * @param {Matrix4} [right] The second matrix.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         *
         * @example
         * //compares two Matrix4 instances
         *
         * // a = [10.5, 14.5, 18.5, 22.5]
         * //     [11.5, 15.5, 19.5, 23.5]
         * //     [12.5, 16.5, 20.5, 24.5]
         * //     [13.5, 17.5, 21.5, 25.5]
         *
         * // b = [10.0, 14.0, 18.0, 22.0]
         * //     [11.0, 15.0, 19.0, 23.0]
         * //     [12.0, 16.0, 20.0, 24.0]
         * //     [13.0, 17.0, 21.0, 25.0]
         *
         * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){
         *      console.log("Difference between both the matrices is less than 0.1");
         * } else {
         *      console.log("Difference between both the matrices is not less than 0.1");
         * }
         *
         * //Prints "Difference between both the matrices is not less than 0.1" on the console
         */
        Matrix4.equalsEpsilon = function (left, right, epsilon) {
            //>>includeStart('debug', pragmas.debug);
            if (typeof epsilon !== 'number') {
                throw new DeveloperError('epsilon must be a number');
            }
            //>>includeEnd('debug');

            return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon && Math.abs(left[9] - right[9]) <= epsilon && Math.abs(left[10] - right[10]) <= epsilon && Math.abs(left[11] - right[11]) <= epsilon && Math.abs(left[12] - right[12]) <= epsilon && Math.abs(left[13] - right[13]) <= epsilon && Math.abs(left[14] - right[14]) <= epsilon && Math.abs(left[15] - right[15]) <= epsilon;
        };

        /**
         * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Matrix4.getTranslation = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = matrix[12];
            result.y = matrix[13];
            result.z = matrix[14];
            return result;
        };

        /**
         * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.
         *
         * @param {Matrix4} matrix The matrix to use.
         * @param {Matrix3} result The object onto which to store the result.
         * @returns {Matrix3} The modified result parameter.
         *
         * @example
         * // returns a Matrix3 instance from a Matrix4 instance
         *
         * // m = [10.0, 14.0, 18.0, 22.0]
         * //     [11.0, 15.0, 19.0, 23.0]
         * //     [12.0, 16.0, 20.0, 24.0]
         * //     [13.0, 17.0, 21.0, 25.0]
         *
         * var b = new Cesium.Matrix3();
         * Cesium.Matrix4.getRotation(m,b);
         *
         * // b = [10.0, 14.0, 18.0]
         * //     [11.0, 15.0, 19.0]
         * //     [12.0, 16.0, 20.0]
         */
        Matrix4.getRotation = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result[0] = matrix[0];
            result[1] = matrix[1];
            result[2] = matrix[2];
            result[3] = matrix[4];
            result[4] = matrix[5];
            result[5] = matrix[6];
            result[6] = matrix[8];
            result[7] = matrix[9];
            result[8] = matrix[10];
            return result;
        };

        var scratchInverseRotation = new Matrix3();
        var scratchMatrix3Zero = new Matrix3();
        var scratchBottomRow = new Cartesian4();
        var scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);

        /**
         * Computes the inverse of the provided matrix using Cramers Rule.
         * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
         * If the matrix is an affine transformation matrix, it is more efficient
         * to invert it with {@link Matrix4.inverseTransformation}.
         *
         * @param {Matrix4} matrix The matrix to invert.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         *
         * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
         */
        Matrix4.inverse = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            // Special case for a zero scale matrix that can occur, for example,
            // when a model's node has a [0, 0, 0] scale.
            if (Matrix3.equalsEpsilon(Matrix4.getRotation(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) && Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {

                result[0] = 0.0;
                result[1] = 0.0;
                result[2] = 0.0;
                result[3] = 0.0;
                result[4] = 0.0;
                result[5] = 0.0;
                result[6] = 0.0;
                result[7] = 0.0;
                result[8] = 0.0;
                result[9] = 0.0;
                result[10] = 0.0;
                result[11] = 0.0;
                result[12] = -matrix[12];
                result[13] = -matrix[13];
                result[14] = -matrix[14];
                result[15] = 1.0;
                return result;
            }

            //
            // Ported from:
            //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
            //
            var src0 = matrix[0];
            var src1 = matrix[4];
            var src2 = matrix[8];
            var src3 = matrix[12];
            var src4 = matrix[1];
            var src5 = matrix[5];
            var src6 = matrix[9];
            var src7 = matrix[13];
            var src8 = matrix[2];
            var src9 = matrix[6];
            var src10 = matrix[10];
            var src11 = matrix[14];
            var src12 = matrix[3];
            var src13 = matrix[7];
            var src14 = matrix[11];
            var src15 = matrix[15];

            // calculate pairs for first 8 elements (cofactors)
            var tmp0 = src10 * src15;
            var tmp1 = src11 * src14;
            var tmp2 = src9 * src15;
            var tmp3 = src11 * src13;
            var tmp4 = src9 * src14;
            var tmp5 = src10 * src13;
            var tmp6 = src8 * src15;
            var tmp7 = src11 * src12;
            var tmp8 = src8 * src14;
            var tmp9 = src10 * src12;
            var tmp10 = src8 * src13;
            var tmp11 = src9 * src12;

            // calculate first 8 elements (cofactors)
            var dst0 = tmp0 * src5 + tmp3 * src6 + tmp4 * src7 - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
            var dst1 = tmp1 * src4 + tmp6 * src6 + tmp9 * src7 - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
            var dst2 = tmp2 * src4 + tmp7 * src5 + tmp10 * src7 - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
            var dst3 = tmp5 * src4 + tmp8 * src5 + tmp11 * src6 - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
            var dst4 = tmp1 * src1 + tmp2 * src2 + tmp5 * src3 - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
            var dst5 = tmp0 * src0 + tmp7 * src2 + tmp8 * src3 - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
            var dst6 = tmp3 * src0 + tmp6 * src1 + tmp11 * src3 - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
            var dst7 = tmp4 * src0 + tmp9 * src1 + tmp10 * src2 - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);

            // calculate pairs for second 8 elements (cofactors)
            tmp0 = src2 * src7;
            tmp1 = src3 * src6;
            tmp2 = src1 * src7;
            tmp3 = src3 * src5;
            tmp4 = src1 * src6;
            tmp5 = src2 * src5;
            tmp6 = src0 * src7;
            tmp7 = src3 * src4;
            tmp8 = src0 * src6;
            tmp9 = src2 * src4;
            tmp10 = src0 * src5;
            tmp11 = src1 * src4;

            // calculate second 8 elements (cofactors)
            var dst8 = tmp0 * src13 + tmp3 * src14 + tmp4 * src15 - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
            var dst9 = tmp1 * src12 + tmp6 * src14 + tmp9 * src15 - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
            var dst10 = tmp2 * src12 + tmp7 * src13 + tmp10 * src15 - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
            var dst11 = tmp5 * src12 + tmp8 * src13 + tmp11 * src14 - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
            var dst12 = tmp2 * src10 + tmp5 * src11 + tmp1 * src9 - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
            var dst13 = tmp8 * src11 + tmp0 * src8 + tmp7 * src10 - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
            var dst14 = tmp6 * src9 + tmp11 * src11 + tmp3 * src8 - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
            var dst15 = tmp10 * src10 + tmp4 * src8 + tmp9 * src9 - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);

            // calculate determinant
            var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;

            if (Math.abs(det) < CesiumMath.EPSILON20) {
                throw new RuntimeError('matrix is not invertible because its determinate is zero.');
            }

            // calculate matrix inverse
            det = 1.0 / det;

            result[0] = dst0 * det;
            result[1] = dst1 * det;
            result[2] = dst2 * det;
            result[3] = dst3 * det;
            result[4] = dst4 * det;
            result[5] = dst5 * det;
            result[6] = dst6 * det;
            result[7] = dst7 * det;
            result[8] = dst8 * det;
            result[9] = dst9 * det;
            result[10] = dst10 * det;
            result[11] = dst11 * det;
            result[12] = dst12 * det;
            result[13] = dst13 * det;
            result[14] = dst14 * det;
            result[15] = dst15 * det;
            return result;
        };

        /**
         * Computes the inverse of the provided matrix assuming it is
         * an affine transformation matrix, where the upper left 3x3 elements
         * are a rotation matrix, and the upper three elements in the fourth
         * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
         * The matrix is not verified to be in the proper form.
         * This method is faster than computing the inverse for a general 4x4
         * matrix using {@link Matrix4.inverse}.
         *
         * @param {Matrix4} matrix The matrix to invert.
         * @param {Matrix4} result The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter.
         */
        Matrix4.inverseTransformation = function (matrix, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(matrix)) {
                throw new DeveloperError('matrix is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            //This function is an optimized version of the below 4 lines.
            //var rT = Matrix3.transpose(Matrix4.getRotation(matrix));
            //var rTN = Matrix3.negate(rT);
            //var rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));
            //return Matrix4.fromRotationTranslation(rT, rTT, result);

            var matrix0 = matrix[0];
            var matrix1 = matrix[1];
            var matrix2 = matrix[2];
            var matrix4 = matrix[4];
            var matrix5 = matrix[5];
            var matrix6 = matrix[6];
            var matrix8 = matrix[8];
            var matrix9 = matrix[9];
            var matrix10 = matrix[10];

            var vX = matrix[12];
            var vY = matrix[13];
            var vZ = matrix[14];

            var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
            var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
            var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;

            result[0] = matrix0;
            result[1] = matrix4;
            result[2] = matrix8;
            result[3] = 0.0;
            result[4] = matrix1;
            result[5] = matrix5;
            result[6] = matrix9;
            result[7] = 0.0;
            result[8] = matrix2;
            result[9] = matrix6;
            result[10] = matrix10;
            result[11] = 0.0;
            result[12] = x;
            result[13] = y;
            result[14] = z;
            result[15] = 1.0;
            return result;
        };

        /**
         * An immutable Matrix4 instance initialized to the identity matrix.
         *
         * @type {Matrix4}
         * @constant
         */
        Matrix4.IDENTITY = freezeObject(new Matrix4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0));

        /**
         * An immutable Matrix4 instance initialized to the zero matrix.
         *
         * @type {Matrix4}
         * @constant
         */
        Matrix4.ZERO = freezeObject(new Matrix4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

        /**
         * The index into Matrix4 for column 0, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN0ROW0 = 0;

        /**
         * The index into Matrix4 for column 0, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN0ROW1 = 1;

        /**
         * The index into Matrix4 for column 0, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN0ROW2 = 2;

        /**
         * The index into Matrix4 for column 0, row 3.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN0ROW3 = 3;

        /**
         * The index into Matrix4 for column 1, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN1ROW0 = 4;

        /**
         * The index into Matrix4 for column 1, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN1ROW1 = 5;

        /**
         * The index into Matrix4 for column 1, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN1ROW2 = 6;

        /**
         * The index into Matrix4 for column 1, row 3.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN1ROW3 = 7;

        /**
         * The index into Matrix4 for column 2, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN2ROW0 = 8;

        /**
         * The index into Matrix4 for column 2, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN2ROW1 = 9;

        /**
         * The index into Matrix4 for column 2, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN2ROW2 = 10;

        /**
         * The index into Matrix4 for column 2, row 3.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN2ROW3 = 11;

        /**
         * The index into Matrix4 for column 3, row 0.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN3ROW0 = 12;

        /**
         * The index into Matrix4 for column 3, row 1.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN3ROW1 = 13;

        /**
         * The index into Matrix4 for column 3, row 2.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN3ROW2 = 14;

        /**
         * The index into Matrix4 for column 3, row 3.
         *
         * @type {Number}
         * @constant
         */
        Matrix4.COLUMN3ROW3 = 15;

        defineProperties(Matrix4.prototype, {
            /**
             * Gets the number of items in the collection.
             * @memberof Matrix4.prototype
             *
             * @type {Number}
             */
            length: {
                get: function () {
                    return Matrix4.packedLength;
                }
            }
        });

        /**
         * Duplicates the provided Matrix4 instance.
         *
         * @param {Matrix4} [result] The object onto which to store the result.
         * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
         */
        Matrix4.prototype.clone = function (result) {
            return Matrix4.clone(this, result);
        };

        /**
         * Compares this matrix to the provided matrix componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Matrix4} [right] The right hand side matrix.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        Matrix4.prototype.equals = function (right) {
            return Matrix4.equals(this, right);
        };

        /**
         * @private
         */
        Matrix4.equalsArray = function (matrix, array, offset) {
            return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8] && matrix[9] === array[offset + 9] && matrix[10] === array[offset + 10] && matrix[11] === array[offset + 11] && matrix[12] === array[offset + 12] && matrix[13] === array[offset + 13] && matrix[14] === array[offset + 14] && matrix[15] === array[offset + 15];
        };

        /**
         * Compares this matrix to the provided matrix componentwise and returns
         * <code>true</code> if they are within the provided epsilon,
         * <code>false</code> otherwise.
         *
         * @param {Matrix4} [right] The right hand side matrix.
         * @param {Number} epsilon The epsilon to use for equality testing.
         * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
         */
        Matrix4.prototype.equalsEpsilon = function (right, epsilon) {
            return Matrix4.equalsEpsilon(this, right, epsilon);
        };

        /**
         * Computes a string representing this Matrix with each row being
         * on a separate line and in the format '(column0, column1, column2, column3)'.
         *
         * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
         */
        Matrix4.prototype.toString = function () {
            return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] + ')\n' + '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] + ')\n' + '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] + ')\n' + '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] + ')';
        };

        return Matrix4;
    }).call(this, $__require('35'), $__require('4c'), $__require('2c'), $__require('23'), $__require('24'), $__require('25'), $__require('28'), $__require('30'), $__require('3b'), $__require('41'));
});
/*
  I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
  so it's better encapsulated. Now you can have multiple random number generators
  and they won't stomp all over eachother's state.

  If you want to use this as a substitute for Math.random(), use the random()
  method like so:

  var m = new MersenneTwister();
  var randomNumber = m.random();

  You can also call the other genrand_{foo}() methods on the instance.

  If you want to use a specific seed in order to get a repeatable random
  sequence, pass an integer into the constructor:

  var m = new MersenneTwister(123);

  and that will always produce the same random sequence.

  Sean McCullough (banksean@gmail.com)
*/

/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)
   or init_by_array(init_key, key_length).
*/
/**
@license
mersenne-twister.js - https://gist.github.com/banksean/300494

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/
$__System.registerDynamic("76", [], false, function ($__require, $__exports, $__module) {
  return (function () {
    var MersenneTwister = function (seed) {
      if (seed == undefined) {
        seed = new Date().getTime();
      }
      /* Period parameters */
      this.N = 624;
      this.M = 397;
      this.MATRIX_A = 0x9908b0df; /* constant vector a */
      this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
      this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

      this.mt = new Array(this.N); /* the array for the state vector */
      this.mti = this.N + 1; /* mti==N+1 means mt[N] is not initialized */

      this.init_genrand(seed);
    };

    /* initializes mt[N] with a seed */
    MersenneTwister.prototype.init_genrand = function (s) {
      this.mt[0] = s >>> 0;
      for (this.mti = 1; this.mti < this.N; this.mti++) {
        var s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (((s & 0xffff0000) >>> 16) * 1812433253 << 16) + (s & 0x0000ffff) * 1812433253 + this.mti;
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        this.mt[this.mti] >>>= 0;
        /* for >32 bit machines */
      }
    };

    /* initialize by an array with array-length */
    /* init_key is the array for initializing keys */
    /* key_length is its length */
    /* slight change for C++, 2004/2/26 */
    //MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
    //  var i, j, k;
    //  this.init_genrand(19650218);
    //  i=1; j=0;
    //  k = (this.N>key_length ? this.N : key_length);
    //  for (; k; k--) {
    //    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
    //    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
    //      + init_key[j] + j; /* non linear */
    //    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
    //    i++; j++;
    //    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
    //    if (j>=key_length) j=0;
    //  }
    //  for (k=this.N-1; k; k--) {
    //    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
    //    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
    //      - i; /* non linear */
    //    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
    //    i++;
    //    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
    //  }
    //
    //  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
    //}

    /* generates a random number on [0,0xffffffff]-interval */
    MersenneTwister.prototype.genrand_int32 = function () {
      var y;
      var mag01 = new Array(0x0, this.MATRIX_A);
      /* mag01[x] = x * MATRIX_A  for x=0,1 */

      if (this.mti >= this.N) {
        /* generate N words at one time */
        var kk;

        if (this.mti == this.N + 1) /* if init_genrand() has not been called, */
          this.init_genrand(5489); /* a default initial seed is used */

        for (kk = 0; kk < this.N - this.M; kk++) {
          y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 0x1];
        }
        for (; kk < this.N - 1; kk++) {
          y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
          this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 0x1];
        }
        y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
        this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 0x1];

        this.mti = 0;
      }

      y = this.mt[this.mti++];

      /* Tempering */
      y ^= y >>> 11;
      y ^= y << 7 & 0x9d2c5680;
      y ^= y << 15 & 0xefc60000;
      y ^= y >>> 18;

      return y >>> 0;
    };

    /* generates a random number on [0,0x7fffffff]-interval */
    //MersenneTwister.prototype.genrand_int31 = function() {
    //  return (this.genrand_int32()>>>1);
    //}

    /* generates a random number on [0,1]-real-interval */
    //MersenneTwister.prototype.genrand_real1 = function() {
    //  return this.genrand_int32()*(1.0/4294967295.0);
    //  /* divided by 2^32-1 */
    //}

    /* generates a random number on [0,1)-real-interval */
    MersenneTwister.prototype.random = function () {
      return this.genrand_int32() * (1.0 / 4294967296.0);
      /* divided by 2^32 */
    };

    /* generates a random number on (0,1)-real-interval */
    //MersenneTwister.prototype.genrand_real3 = function() {
    //  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0);
    //  /* divided by 2^32 */
    //}

    /* generates a random number on [0,1) with 53-bit resolution*/
    //MersenneTwister.prototype.genrand_res53 = function() {
    //  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;
    //  return(a*67108864.0+b)*(1.0/9007199254740992.0);
    //}

    /* These real versions are due to Isaku Wada, 2002/01/09 added */

    return MersenneTwister;
  }).call(this);
});
/*global define*/
$__System.registerDynamic('2c', ['28'], false, function ($__require, $__exports, $__module) {
    return (function (freezeObject) {
        'use strict';

        /**
         * Returns the first parameter if not undefined, otherwise the second parameter.
         * Useful for setting a default value for a parameter.
         *
         * @exports defaultValue
         *
         * @param {*} a
         * @param {*} b
         * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.
         *
         * @example
         * param = Cesium.defaultValue(param, 'default');
         */

        function defaultValue(a, b) {
            if (a !== undefined) {
                return a;
            }
            return b;
        }

        /**
         * A frozen empty object that can be used as the default value for options passed as
         * an object literal.
         */
        defaultValue.EMPTY_OBJECT = freezeObject({});

        return defaultValue;
    }).call(this, $__require('28'));
});
/*global define*/
$__System.registerDynamic('30', ['76', '2c', '23', '25'], false, function ($__require, $__exports, $__module) {
  return (function (MersenneTwister, defaultValue, defined, DeveloperError) {
    'use strict';

    /**
     * Math functions.
     *
     * @exports CesiumMath
     */

    var CesiumMath = {};

    /**
     * 0.1
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON1 = 0.1;

    /**
     * 0.01
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON2 = 0.01;

    /**
     * 0.001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON3 = 0.001;

    /**
     * 0.0001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON4 = 0.0001;

    /**
     * 0.00001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON5 = 0.00001;

    /**
     * 0.000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON6 = 0.000001;

    /**
     * 0.0000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON7 = 0.0000001;

    /**
     * 0.00000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON8 = 0.00000001;

    /**
     * 0.000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON9 = 0.000000001;

    /**
     * 0.0000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON10 = 0.0000000001;

    /**
     * 0.00000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON11 = 0.00000000001;

    /**
     * 0.000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON12 = 0.000000000001;

    /**
     * 0.0000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON13 = 0.0000000000001;

    /**
     * 0.00000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON14 = 0.00000000000001;

    /**
     * 0.000000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON15 = 0.000000000000001;

    /**
     * 0.0000000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON16 = 0.0000000000000001;

    /**
     * 0.00000000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON17 = 0.00000000000000001;

    /**
     * 0.000000000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON18 = 0.000000000000000001;

    /**
     * 0.0000000000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON19 = 0.0000000000000000001;

    /**
     * 0.00000000000000000001
     * @type {Number}
     * @constant
     */
    CesiumMath.EPSILON20 = 0.00000000000000000001;

    /**
     * 3.986004418e14
     * @type {Number}
     * @constant
     */
    CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

    /**
     * Radius of the sun in meters: 6.955e8
     * @type {Number}
     * @constant
     */
    CesiumMath.SOLAR_RADIUS = 6.955e8;

    /**
     * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
     * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
     * Celestial Mechanics 82: 83-110, 2002.
     * @type {Number}
     * @constant
     */
    CesiumMath.LUNAR_RADIUS = 1737400.0;

    /**
     * 64 * 1024
     * @type {Number}
     * @constant
     */
    CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;

    /**
     * Returns the sign of the value; 1 if the value is positive, -1 if the value is
     * negative, or 0 if the value is 0.
     *
     * @param {Number} value The value to return the sign of.
     * @returns {Number} The sign of value.
     */
    CesiumMath.sign = function (value) {
      if (value > 0) {
        return 1;
      }
      if (value < 0) {
        return -1;
      }

      return 0;
    };

    /**
     * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
     * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of
     * 0.0 when the input value is 0.0.
     * @param {Number} value The value to return the sign of.
     * @returns {Number} The sign of value.
     */
    CesiumMath.signNotZero = function (value) {
      return value < 0.0 ? -1.0 : 1.0;
    };

    /**
     * Converts a scalar value in the range [-1.0, 1.0] to a 8-bit 2's complement number.
     * @param {Number} value The scalar value in the range [-1.0, 1.0]
     * @returns {Number} The 8-bit 2's complement number, where 0 maps to -1.0 and 255 maps to 1.0.
     *
     * @see CesiumMath.fromSNorm
     */
    CesiumMath.toSNorm = function (value) {
      return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * 255.0);
    };

    /**
     * Converts a SNORM value in the range [0, 255] to a scalar in the range [-1.0, 1.0].
     * @param {Number} value SNORM value in the range [0, 255]
     * @returns {Number} Scalar in the range [-1.0, 1.0].
     *
     * @see CesiumMath.toSNorm
     */
    CesiumMath.fromSNorm = function (value) {
      return CesiumMath.clamp(value, 0.0, 255.0) / 255.0 * 2.0 - 1.0;
    };

    /**
     * Returns the hyperbolic sine of a number.
     * The hyperbolic sine of <em>value</em> is defined to be
     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is an infinity
     *     with the same sign as the argument.</li>
     *
     *     <li>If the argument is zero, then the result is a zero with the
     *     same sign as the argument.</li>
     *   </ul>
     *</p>
     *
     * @param {Number} value The number whose hyperbolic sine is to be returned.
     * @returns {Number} The hyperbolic sine of <code>value</code>.
     */
    CesiumMath.sinh = function (value) {
      var part1 = Math.pow(Math.E, value);
      var part2 = Math.pow(Math.E, -1.0 * value);

      return (part1 - part2) * 0.5;
    };

    /**
     * Returns the hyperbolic cosine of a number.
     * The hyperbolic cosine of <strong>value</strong> is defined to be
     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is positive infinity.</li>
     *
     *     <li>If the argument is zero, then the result is 1.0.</li>
     *   </ul>
     *</p>
     *
     * @param {Number} value The number whose hyperbolic cosine is to be returned.
     * @returns {Number} The hyperbolic cosine of <code>value</code>.
     */
    CesiumMath.cosh = function (value) {
      var part1 = Math.pow(Math.E, value);
      var part2 = Math.pow(Math.E, -1.0 * value);

      return (part1 + part2) * 0.5;
    };

    /**
     * Computes the linear interpolation of two values.
     *
     * @param {Number} p The start value to interpolate.
     * @param {Number} q The end value to interpolate.
     * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
     * @returns {Number} The linearly interpolated value.
     *
     * @example
     * var n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
     */
    CesiumMath.lerp = function (p, q, time) {
      return (1.0 - time) * p + time * q;
    };

    /**
     * pi
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.PI = Math.PI;

    /**
     * 1/pi
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

    /**
     * pi/2
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.PI_OVER_TWO = Math.PI * 0.5;

    /**
     * pi/3
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

    /**
     * pi/4
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

    /**
     * pi/6
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

    /**
     * 3pi/2
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.THREE_PI_OVER_TWO = 3.0 * Math.PI * 0.5;

    /**
     * 2pi
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.TWO_PI = 2.0 * Math.PI;

    /**
     * 1/2pi
     *
     * @type {Number}
     * @constant
     */
    CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

    /**
     * The number of radians in a degree.
     *
     * @type {Number}
     * @constant
     * @default Math.PI / 180.0
     */
    CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

    /**
     * The number of degrees in a radian.
     *
     * @type {Number}
     * @constant
     * @default 180.0 / Math.PI
     */
    CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

    /**
     * The number of radians in an arc second.
     *
     * @type {Number}
     * @constant
     * @default {@link CesiumMath.RADIANS_PER_DEGREE} / 3600.0
     */
    CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;

    /**
     * Converts degrees to radians.
     * @param {Number} degrees The angle to convert in degrees.
     * @returns {Number} The corresponding angle in radians.
     */
    CesiumMath.toRadians = function (degrees) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(degrees)) {
        throw new DeveloperError('degrees is required.');
      }
      //>>includeEnd('debug');
      return degrees * CesiumMath.RADIANS_PER_DEGREE;
    };

    /**
     * Converts radians to degrees.
     * @param {Number} radians The angle to convert in radians.
     * @returns {Number} The corresponding angle in degrees.
     */
    CesiumMath.toDegrees = function (radians) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(radians)) {
        throw new DeveloperError('radians is required.');
      }
      //>>includeEnd('debug');
      return radians * CesiumMath.DEGREES_PER_RADIAN;
    };

    /**
     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @example
     * // Convert 270 degrees to -90 degrees longitude
     * var longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));
     */
    CesiumMath.convertLongitudeRange = function (angle) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
      }
      //>>includeEnd('debug');
      var twoPi = CesiumMath.TWO_PI;

      var simplified = angle - Math.floor(angle / twoPi) * twoPi;

      if (simplified < -Math.PI) {
        return simplified + twoPi;
      }
      if (simplified >= Math.PI) {
        return simplified - twoPi;
      }

      return simplified;
    };

    /**
     * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
     *
     * @param {Number} angle in radians
     * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].
     */
    CesiumMath.negativePiToPi = function (x) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(x)) {
        throw new DeveloperError('x is required.');
      }
      //>>includeEnd('debug');
      return CesiumMath.zeroToTwoPi(x + CesiumMath.PI) - CesiumMath.PI;
    };

    /**
     * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
     *
     * @param {Number} angle in radians
     * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].
     */
    CesiumMath.zeroToTwoPi = function (x) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(x)) {
        throw new DeveloperError('x is required.');
      }
      //>>includeEnd('debug');
      var mod = CesiumMath.mod(x, CesiumMath.TWO_PI);
      if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(x) > CesiumMath.EPSILON14) {
        return CesiumMath.TWO_PI;
      }
      return mod;
    };

    /**
     * The modulo operation that also works for negative dividends.
     *
     * @param {Number} m The dividend.
     * @param {Number} n The divisor.
     * @returns {Number} The remainder.
     */
    CesiumMath.mod = function (m, n) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(m)) {
        throw new DeveloperError('m is required.');
      }
      if (!defined(n)) {
        throw new DeveloperError('n is required.');
      }
      //>>includeEnd('debug');
      return (m % n + n) % n;
    };

    /**
     * Determines if two values are equal using an absolute or relative tolerance test. This is useful
     * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
     * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
     * Use this test if you are unsure of the magnitudes of left and right.
     *
     * @param {Number} left The first value to compare.
     * @param {Number} right The other value to compare.
     * @param {Number} relativeEpsilon The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
     * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
     * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
     *
     * @example
     * var a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true
     * var b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false
     * var c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true
     * var d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false
     */
    CesiumMath.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(left)) {
        throw new DeveloperError('left is required.');
      }
      if (!defined(right)) {
        throw new DeveloperError('right is required.');
      }
      if (!defined(relativeEpsilon)) {
        throw new DeveloperError('relativeEpsilon is required.');
      }
      //>>includeEnd('debug');
      absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);
      var absDiff = Math.abs(left - right);
      return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
    };

    var factorials = [1];

    /**
     * Computes the factorial of the provided number.
     *
     * @param {Number} n The number whose factorial is to be computed.
     * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.
     *
     * @exception {DeveloperError} A number greater than or equal to 0 is required.
     *
     *
     * @example
     * //Compute 7!, which is equal to 5040
     * var computedFactorial = Cesium.Math.factorial(7);
     * 
     * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}
     */
    CesiumMath.factorial = function (n) {
      //>>includeStart('debug', pragmas.debug);
      if (typeof n !== 'number' || n < 0) {
        throw new DeveloperError('A number greater than or equal to 0 is required.');
      }
      //>>includeEnd('debug');

      var length = factorials.length;
      if (n >= length) {
        var sum = factorials[length - 1];
        for (var i = length; i <= n; i++) {
          factorials.push(sum * i);
        }
      }
      return factorials[n];
    };

    /**
     * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
     *
     * @param {Number} [n] The number to be incremented.
     * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.
     * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.
     * @returns {Number} The incremented number.
     *
     * @exception {DeveloperError} Maximum value must be greater than minimum value.
     *
     * @example
     * var n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6
     * var n = Cesium.Math.incrementWrap(10, 10, 0); // returns 0
     */
    CesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {
      minimumValue = defaultValue(minimumValue, 0.0);

      //>>includeStart('debug', pragmas.debug);
      if (!defined(n)) {
        throw new DeveloperError('n is required.');
      }
      if (maximumValue <= minimumValue) {
        throw new DeveloperError('maximumValue must be greater than minimumValue.');
      }
      //>>includeEnd('debug');

      ++n;
      if (n > maximumValue) {
        n = minimumValue;
      }
      return n;
    };

    /**
     * Determines if a positive integer is a power of two.
     *
     * @param {Number} n The positive integer to test.
     * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
     *
     * @exception {DeveloperError} A number greater than or equal to 0 is required.
     *
     * @example
     * var t = Cesium.Math.isPowerOfTwo(16); // true
     * var f = Cesium.Math.isPowerOfTwo(20); // false
     */
    CesiumMath.isPowerOfTwo = function (n) {
      //>>includeStart('debug', pragmas.debug);
      if (typeof n !== 'number' || n < 0) {
        throw new DeveloperError('A number greater than or equal to 0 is required.');
      }
      //>>includeEnd('debug');

      return n !== 0 && (n & n - 1) === 0;
    };

    /**
     * Computes the next power-of-two integer greater than or equal to the provided positive integer.
     *
     * @param {Number} n The positive integer to test.
     * @returns {Number} The next power-of-two integer.
     *
     * @exception {DeveloperError} A number greater than or equal to 0 is required.
     *
     * @example
     * var n = Cesium.Math.nextPowerOfTwo(29); // 32
     * var m = Cesium.Math.nextPowerOfTwo(32); // 32
     */
    CesiumMath.nextPowerOfTwo = function (n) {
      //>>includeStart('debug', pragmas.debug);
      if (typeof n !== 'number' || n < 0) {
        throw new DeveloperError('A number greater than or equal to 0 is required.');
      }
      //>>includeEnd('debug');

      // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
      --n;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      ++n;

      return n;
    };

    /**
     * Constraint a value to lie between two values.
     *
     * @param {Number} value The value to constrain.
     * @param {Number} min The minimum value.
     * @param {Number} max The maximum value.
     * @returns {Number} The value clamped so that min <= value <= max.
     */
    CesiumMath.clamp = function (value, min, max) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(value)) {
        throw new DeveloperError('value is required');
      }
      if (!defined(min)) {
        throw new DeveloperError('min is required.');
      }
      if (!defined(max)) {
        throw new DeveloperError('max is required.');
      }
      //>>includeEnd('debug');
      return value < min ? min : value > max ? max : value;
    };

    var randomNumberGenerator = new MersenneTwister();

    /**
     * Sets the seed used by the random number generator
     * in {@link CesiumMath#nextRandomNumber}.
     *
     * @param {Number} seed An integer used as the seed.
     */
    CesiumMath.setRandomNumberSeed = function (seed) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(seed)) {
        throw new DeveloperError('seed is required.');
      }
      //>>includeEnd('debug');

      randomNumberGenerator = new MersenneTwister(seed);
    };

    /**
     * Generates a random number in the range of [0.0, 1.0)
     * using a Mersenne twister.
     *
     * @returns {Number} A random number in the range of [0.0, 1.0).
     *
     * @see CesiumMath.setRandomNumberSeed
     * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}
     */
    CesiumMath.nextRandomNumber = function () {
      return randomNumberGenerator.random();
    };

    /**
     * Computes <code>Math.acos(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]
     * so that the function will never return NaN.
     *
     * @param {Number} value The value for which to compute acos.
     * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
     *          whichever is closer, if the value is outside the range.
     */
    CesiumMath.acosClamped = function (value) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(value)) {
        throw new DeveloperError('value is required.');
      }
      //>>includeEnd('debug');
      return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));
    };

    /**
     * Computes <code>Math.asin(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]
     * so that the function will never return NaN.
     *
     * @param {Number} value The value for which to compute asin.
     * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
     *          whichever is closer, if the value is outside the range.
     */
    CesiumMath.asinClamped = function (value) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(value)) {
        throw new DeveloperError('value is required.');
      }
      //>>includeEnd('debug');
      return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));
    };

    /**
     * Finds the chord length between two points given the circle's radius and the angle between the points.
     *
     * @param {Number} angle The angle between the two points.
     * @param {Number} radius The radius of the circle.
     * @returns {Number} The chord length.
     */
    CesiumMath.chordLength = function (angle, radius) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
      }
      if (!defined(radius)) {
        throw new DeveloperError('radius is required.');
      }
      //>>includeEnd('debug');
      return 2.0 * radius * Math.sin(angle * 0.5);
    };

    /**
     * Finds the logarithm of a number to a base.
     *
     * @param {Number} number The number.
     * @param {Number} base The base.
     * @returns {Number} The result.
     */
    CesiumMath.logBase = function (number, base) {
      //>>includeStart('debug', pragmas.debug);
      if (!defined(number)) {
        throw new DeveloperError('number is required.');
      }
      if (!defined(base)) {
        throw new DeveloperError('base is required.');
      }
      //>>includeEnd('debug');
      return Math.log(number) / Math.log(base);
    };

    /**
     * @private
     */
    CesiumMath.fog = function (distanceToCamera, density) {
      var scalar = distanceToCamera * density;
      return 1.0 - Math.exp(-(scalar * scalar));
    };

    return CesiumMath;
  }).call(this, $__require('76'), $__require('2c'), $__require('23'), $__require('25'));
});
/*global define*/
$__System.registerDynamic('35', ['2c', '23', '25', '28', '30'], false, function ($__require, $__exports, $__module) {
    return (function (defaultValue, defined, DeveloperError, freezeObject, CesiumMath) {
        'use strict';

        /**
         * A 3D Cartesian point.
         * @alias Cartesian3
         * @constructor
         *
         * @param {Number} [x=0.0] The X component.
         * @param {Number} [y=0.0] The Y component.
         * @param {Number} [z=0.0] The Z component.
         *
         * @see Cartesian2
         * @see Cartesian4
         * @see Packable
         */

        function Cartesian3(x, y, z) {
            /**
             * The X component.
             * @type {Number}
             * @default 0.0
             */
            this.x = defaultValue(x, 0.0);

            /**
             * The Y component.
             * @type {Number}
             * @default 0.0
             */
            this.y = defaultValue(y, 0.0);

            /**
             * The Z component.
             * @type {Number}
             * @default 0.0
             */
            this.z = defaultValue(z, 0.0);
        }

        /**
         * Converts the provided Spherical into Cartesian3 coordinates.
         *
         * @param {Spherical} spherical The Spherical to be converted to Cartesian3.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
         */
        Cartesian3.fromSpherical = function (spherical, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(spherical)) {
                throw new DeveloperError('spherical is required');
            }
            //>>includeEnd('debug');

            if (!defined(result)) {
                result = new Cartesian3();
            }

            var clock = spherical.clock;
            var cone = spherical.cone;
            var magnitude = defaultValue(spherical.magnitude, 1.0);
            var radial = magnitude * Math.sin(cone);
            result.x = radial * Math.cos(clock);
            result.y = radial * Math.sin(clock);
            result.z = magnitude * Math.cos(cone);
            return result;
        };

        /**
         * Creates a Cartesian3 instance from x, y and z coordinates.
         *
         * @param {Number} x The x coordinate.
         * @param {Number} y The y coordinate.
         * @param {Number} z The z coordinate.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
         */
        Cartesian3.fromElements = function (x, y, z, result) {
            if (!defined(result)) {
                return new Cartesian3(x, y, z);
            }

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Duplicates a Cartesian3 instance.
         *
         * @param {Cartesian3} cartesian The Cartesian to duplicate.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)
         */
        Cartesian3.clone = function (cartesian, result) {
            if (!defined(cartesian)) {
                return undefined;
            }
            if (!defined(result)) {
                return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
            }

            result.x = cartesian.x;
            result.y = cartesian.y;
            result.z = cartesian.z;
            return result;
        };

        /**
         * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
         * x, y, and z properties of the Cartesian4 and drops w.
         * @function
         *
         * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
         */
        Cartesian3.fromCartesian4 = Cartesian3.clone;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        Cartesian3.packedLength = 3;

        /**
         * Stores the provided instance into the provided array.
         *
         * @param {Cartesian3} value The value to pack.
         * @param {Number[]} array The array to pack into.
         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
         */
        Cartesian3.pack = function (value, array, startingIndex) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(value)) {
                throw new DeveloperError('value is required');
            }

            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            array[startingIndex++] = value.x;
            array[startingIndex++] = value.y;
            array[startingIndex] = value.z;
        };

        /**
         * Retrieves an instance from a packed array.
         *
         * @param {Number[]} array The packed array.
         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
         * @param {Cartesian3} [result] The object into which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
         */
        Cartesian3.unpack = function (array, startingIndex, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            startingIndex = defaultValue(startingIndex, 0);

            if (!defined(result)) {
                result = new Cartesian3();
            }
            result.x = array[startingIndex++];
            result.y = array[startingIndex++];
            result.z = array[startingIndex];
            return result;
        };

        /**
         * Flattens an array of Cartesian3s into and array of components.
         *
         * @param {Cartesian3[]} array The array of cartesians to pack.
         * @param {Number[]} result The array onto which to store the result.
         * @returns {Number[]} The packed array.
         */
        Cartesian3.packArray = function (array, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            var length = array.length;
            if (!defined(result)) {
                result = new Array(length * 3);
            } else {
                result.length = length * 3;
            }

            for (var i = 0; i < length; ++i) {
                Cartesian3.pack(array[i], result, i * 3);
            }
            return result;
        };

        /**
         * Unpacks an array of cartesian components into and array of Cartesian3s.
         *
         * @param {Number[]} array The array of components to unpack.
         * @param {Cartesian3[]} result The array onto which to store the result.
         * @returns {Cartesian3[]} The unpacked array.
         */
        Cartesian3.unpackArray = function (array, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(array)) {
                throw new DeveloperError('array is required');
            }
            //>>includeEnd('debug');

            var length = array.length;
            if (!defined(result)) {
                result = new Array(length / 3);
            } else {
                result.length = length / 3;
            }

            for (var i = 0; i < length; i += 3) {
                var index = i / 3;
                result[index] = Cartesian3.unpack(array, i, result[index]);
            }
            return result;
        };

        /**
         * Creates a Cartesian3 from three consecutive elements in an array.
         * @function
         *
         * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.
         * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
         *
         * @example
         * // Create a Cartesian3 with (1.0, 2.0, 3.0)
         * var v = [1.0, 2.0, 3.0];
         * var p = Cesium.Cartesian3.fromArray(v);
         *
         * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
         * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
         * var p2 = Cesium.Cartesian3.fromArray(v2, 2);
         */
        Cartesian3.fromArray = Cartesian3.unpack;

        /**
         * Computes the value of the maximum component for the supplied Cartesian.
         *
         * @param {Cartesian3} cartesian The cartesian to use.
         * @returns {Number} The value of the maximum component.
         */
        Cartesian3.maximumComponent = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return Math.max(cartesian.x, cartesian.y, cartesian.z);
        };

        /**
         * Computes the value of the minimum component for the supplied Cartesian.
         *
         * @param {Cartesian3} cartesian The cartesian to use.
         * @returns {Number} The value of the minimum component.
         */
        Cartesian3.minimumComponent = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return Math.min(cartesian.x, cartesian.y, cartesian.z);
        };

        /**
         * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
         *
         * @param {Cartesian3} first A cartesian to compare.
         * @param {Cartesian3} second A cartesian to compare.
         * @param {Cartesian3} result The object into which to store the result.
         * @returns {Cartesian3} A cartesian with the minimum components.
         */
        Cartesian3.minimumByComponent = function (first, second, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required.');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            result.x = Math.min(first.x, second.x);
            result.y = Math.min(first.y, second.y);
            result.z = Math.min(first.z, second.z);

            return result;
        };

        /**
         * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
         *
         * @param {Cartesian3} first A cartesian to compare.
         * @param {Cartesian3} second A cartesian to compare.
         * @param {Cartesian3} result The object into which to store the result.
         * @returns {Cartesian3} A cartesian with the maximum components.
         */
        Cartesian3.maximumByComponent = function (first, second, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(first)) {
                throw new DeveloperError('first is required.');
            }
            if (!defined(second)) {
                throw new DeveloperError('second is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            result.x = Math.max(first.x, second.x);
            result.y = Math.max(first.y, second.y);
            result.z = Math.max(first.z, second.z);
            return result;
        };

        /**
         * Computes the provided Cartesian's squared magnitude.
         *
         * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.
         * @returns {Number} The squared magnitude.
         */
        Cartesian3.magnitudeSquared = function (cartesian) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            //>>includeEnd('debug');

            return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
        };

        /**
         * Computes the Cartesian's magnitude (length).
         *
         * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.
         * @returns {Number} The magnitude.
         */
        Cartesian3.magnitude = function (cartesian) {
            return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
        };

        var distanceScratch = new Cartesian3();

        /**
         * Computes the distance between two points.
         *
         * @param {Cartesian3} left The first point to compute the distance from.
         * @param {Cartesian3} right The second point to compute the distance to.
         * @returns {Number} The distance between two points.
         *
         * @example
         * // Returns 1.0
         * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));
         */
        Cartesian3.distance = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left) || !defined(right)) {
                throw new DeveloperError('left and right are required.');
            }
            //>>includeEnd('debug');

            Cartesian3.subtract(left, right, distanceScratch);
            return Cartesian3.magnitude(distanceScratch);
        };

        /**
         * Computes the squared distance between two points.  Comparing squared distances
         * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
         *
         * @param {Cartesian3} left The first point to compute the distance from.
         * @param {Cartesian3} right The second point to compute the distance to.
         * @returns {Number} The distance between two points.
         *
         * @example
         * // Returns 4.0, not 2.0
         * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));
         */
        Cartesian3.distanceSquared = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left) || !defined(right)) {
                throw new DeveloperError('left and right are required.');
            }
            //>>includeEnd('debug');

            Cartesian3.subtract(left, right, distanceScratch);
            return Cartesian3.magnitudeSquared(distanceScratch);
        };

        /**
         * Computes the normalized form of the supplied Cartesian.
         *
         * @param {Cartesian3} cartesian The Cartesian to be normalized.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.normalize = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var magnitude = Cartesian3.magnitude(cartesian);

            result.x = cartesian.x / magnitude;
            result.y = cartesian.y / magnitude;
            result.z = cartesian.z / magnitude;
            return result;
        };

        /**
         * Computes the dot (scalar) product of two Cartesians.
         *
         * @param {Cartesian3} left The first Cartesian.
         * @param {Cartesian3} right The second Cartesian.
         * @returns {Number} The dot product.
         */
        Cartesian3.dot = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            //>>includeEnd('debug');

            return left.x * right.x + left.y * right.y + left.z * right.z;
        };

        /**
         * Computes the componentwise product of two Cartesians.
         *
         * @param {Cartesian3} left The first Cartesian.
         * @param {Cartesian3} right The second Cartesian.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.multiplyComponents = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x * right.x;
            result.y = left.y * right.y;
            result.z = left.z * right.z;
            return result;
        };

        /**
         * Computes the componentwise sum of two Cartesians.
         *
         * @param {Cartesian3} left The first Cartesian.
         * @param {Cartesian3} right The second Cartesian.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.add = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x + right.x;
            result.y = left.y + right.y;
            result.z = left.z + right.z;
            return result;
        };

        /**
         * Computes the componentwise difference of two Cartesians.
         *
         * @param {Cartesian3} left The first Cartesian.
         * @param {Cartesian3} right The second Cartesian.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.subtract = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = left.x - right.x;
            result.y = left.y - right.y;
            result.z = left.z - right.z;
            return result;
        };

        /**
         * Multiplies the provided Cartesian componentwise by the provided scalar.
         *
         * @param {Cartesian3} cartesian The Cartesian to be scaled.
         * @param {Number} scalar The scalar to multiply with.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.multiplyByScalar = function (cartesian, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = cartesian.x * scalar;
            result.y = cartesian.y * scalar;
            result.z = cartesian.z * scalar;
            return result;
        };

        /**
         * Divides the provided Cartesian componentwise by the provided scalar.
         *
         * @param {Cartesian3} cartesian The Cartesian to be divided.
         * @param {Number} scalar The scalar to divide by.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.divideByScalar = function (cartesian, scalar, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (typeof scalar !== 'number') {
                throw new DeveloperError('scalar is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = cartesian.x / scalar;
            result.y = cartesian.y / scalar;
            result.z = cartesian.z / scalar;
            return result;
        };

        /**
         * Negates the provided Cartesian.
         *
         * @param {Cartesian3} cartesian The Cartesian to be negated.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.negate = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = -cartesian.x;
            result.y = -cartesian.y;
            result.z = -cartesian.z;
            return result;
        };

        /**
         * Computes the absolute value of the provided Cartesian.
         *
         * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.abs = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            result.x = Math.abs(cartesian.x);
            result.y = Math.abs(cartesian.y);
            result.z = Math.abs(cartesian.z);
            return result;
        };

        var lerpScratch = new Cartesian3();
        /**
         * Computes the linear interpolation or extrapolation at t using the provided cartesians.
         *
         * @param {Cartesian3} start The value corresponding to t at 0.0.
         * @param {Cartesian3} end The value corresponding to t at 1.0.
         * @param {Number} t The point along t at which to interpolate.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter.
         */
        Cartesian3.lerp = function (start, end, t, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(start)) {
                throw new DeveloperError('start is required.');
            }
            if (!defined(end)) {
                throw new DeveloperError('end is required.');
            }
            if (typeof t !== 'number') {
                throw new DeveloperError('t is required and must be a number.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            Cartesian3.multiplyByScalar(end, t, lerpScratch);
            result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
            return Cartesian3.add(lerpScratch, result, result);
        };

        var angleBetweenScratch = new Cartesian3();
        var angleBetweenScratch2 = new Cartesian3();
        /**
         * Returns the angle, in radians, between the provided Cartesians.
         *
         * @param {Cartesian3} left The first Cartesian.
         * @param {Cartesian3} right The second Cartesian.
         * @returns {Number} The angle between the Cartesians.
         */
        Cartesian3.angleBetween = function (left, right) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            //>>includeEnd('debug');

            Cartesian3.normalize(left, angleBetweenScratch);
            Cartesian3.normalize(right, angleBetweenScratch2);
            var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
            var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));
            return Math.atan2(sine, cosine);
        };

        var mostOrthogonalAxisScratch = new Cartesian3();
        /**
         * Returns the axis that is most orthogonal to the provided Cartesian.
         *
         * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The most orthogonal axis.
         */
        Cartesian3.mostOrthogonalAxis = function (cartesian, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(cartesian)) {
                throw new DeveloperError('cartesian is required.');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required.');
            }
            //>>includeEnd('debug');

            var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
            Cartesian3.abs(f, f);

            if (f.x <= f.y) {
                if (f.x <= f.z) {
                    result = Cartesian3.clone(Cartesian3.UNIT_X, result);
                } else {
                    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
                }
            } else {
                if (f.y <= f.z) {
                    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
                } else {
                    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
                }
            }

            return result;
        };

        /**
         * Compares the provided Cartesians componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartesian3} [left] The first Cartesian.
         * @param {Cartesian3} [right] The second Cartesian.
         * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
         */
        Cartesian3.equals = function (left, right) {
            return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z;
        };

        /**
         * @private
         */
        Cartesian3.equalsArray = function (cartesian, array, offset) {
            return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];
        };

        /**
         * Compares the provided Cartesians componentwise and returns
         * <code>true</code> if they pass an absolute or relative tolerance test,
         * <code>false</code> otherwise.
         *
         * @param {Cartesian3} [left] The first Cartesian.
         * @param {Cartesian3} [right] The second Cartesian.
         * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
         * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
         * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartesian3.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
            return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon);
        };

        /**
         * Computes the cross (outer) product of two Cartesians.
         *
         * @param {Cartesian3} left The first Cartesian.
         * @param {Cartesian3} right The second Cartesian.
         * @param {Cartesian3} result The object onto which to store the result.
         * @returns {Cartesian3} The cross product.
         */
        Cartesian3.cross = function (left, right, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(left)) {
                throw new DeveloperError('left is required');
            }
            if (!defined(right)) {
                throw new DeveloperError('right is required');
            }
            if (!defined(result)) {
                throw new DeveloperError('result is required');
            }
            //>>includeEnd('debug');

            var leftX = left.x;
            var leftY = left.y;
            var leftZ = left.z;
            var rightX = right.x;
            var rightY = right.y;
            var rightZ = right.z;

            var x = leftY * rightZ - leftZ * rightY;
            var y = leftZ * rightX - leftX * rightZ;
            var z = leftX * rightY - leftY * rightX;

            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };

        /**
         * Returns a Cartesian3 position from longitude and latitude values given in degrees.
         *
         * @param {Number} longitude The longitude, in degrees
         * @param {Number} latitude The latitude, in degrees
         * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The position
         *
         * @example
         * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);
         */
        Cartesian3.fromDegrees = function (longitude, latitude, height, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(longitude)) {
                throw new DeveloperError('longitude is required');
            }
            if (!defined(latitude)) {
                throw new DeveloperError('latitude is required');
            }
            //>>includeEnd('debug');

            var lon = CesiumMath.toRadians(longitude);
            var lat = CesiumMath.toRadians(latitude);
            return Cartesian3.fromRadians(lon, lat, height, ellipsoid, result);
        };

        var scratchN = new Cartesian3();
        var scratchK = new Cartesian3();
        var wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);

        /**
         * Returns a Cartesian3 position from longitude and latitude values given in radians.
         *
         * @param {Number} longitude The longitude, in radians
         * @param {Number} latitude The latitude, in radians
         * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The position
         *
         * @example
         * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);
         */
        Cartesian3.fromRadians = function (longitude, latitude, height, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(longitude)) {
                throw new DeveloperError('longitude is required');
            }
            if (!defined(latitude)) {
                throw new DeveloperError('latitude is required');
            }
            //>>includeEnd('debug');

            height = defaultValue(height, 0.0);
            var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;

            var cosLatitude = Math.cos(latitude);
            scratchN.x = cosLatitude * Math.cos(longitude);
            scratchN.y = cosLatitude * Math.sin(longitude);
            scratchN.z = Math.sin(latitude);
            scratchN = Cartesian3.normalize(scratchN, scratchN);

            Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
            var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
            scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
            scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);

            if (!defined(result)) {
                result = new Cartesian3();
            }
            return Cartesian3.add(scratchK, scratchN, result);
        };

        /**
         * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
         *
         * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.
         * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
         * @returns {Cartesian3[]} The array of positions.
         *
         * @example
         * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
         */
        Cartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(coordinates)) {
                throw new DeveloperError('positions is required.');
            }
            //>>includeEnd('debug');

            var pos = new Array(coordinates.length);
            for (var i = 0; i < coordinates.length; i++) {
                pos[i] = CesiumMath.toRadians(coordinates[i]);
            }

            return Cartesian3.fromRadiansArray(pos, ellipsoid, result);
        };

        /**
         * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
         *
         * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.
         * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
         * @returns {Cartesian3[]} The array of positions.
         *
         * @example
         * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
         */
        Cartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(coordinates)) {
                throw new DeveloperError('positions is required.');
            }
            if (coordinates.length < 2) {
                throw new DeveloperError('positions length cannot be less than 2.');
            }
            if (coordinates.length % 2 !== 0) {
                throw new DeveloperError('positions length must be a multiple of 2.');
            }
            //>>includeEnd('debug');

            var length = coordinates.length;
            if (!defined(result)) {
                result = new Array(length / 2);
            } else {
                result.length = length / 2;
            }

            for (var i = 0; i < length; i += 2) {
                var lon = coordinates[i];
                var lat = coordinates[i + 1];
                result[i / 2] = Cartesian3.fromRadians(lon, lat, 0, ellipsoid, result[i / 2]);
            }

            return result;
        };

        /**
         * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
         *
         * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height,, longitude, latitude, height...].
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
         * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
         * @returns {Cartesian3[]} The array of positions.
         *
         * @example
         * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
         */
        Cartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(coordinates)) {
                throw new DeveloperError('positions is required.');
            }
            if (coordinates.length < 3) {
                throw new DeveloperError('positions length cannot be less than 3.');
            }
            if (coordinates.length % 3 !== 0) {
                throw new DeveloperError('positions length must be a multiple of 3.');
            }
            //>>includeEnd('debug');

            var pos = new Array(coordinates.length);
            for (var i = 0; i < coordinates.length; i += 3) {
                pos[i] = CesiumMath.toRadians(coordinates[i]);
                pos[i + 1] = CesiumMath.toRadians(coordinates[i + 1]);
                pos[i + 2] = coordinates[i + 2];
            }

            return Cartesian3.fromRadiansArrayHeights(pos, ellipsoid, result);
        };

        /**
         * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
         *
         * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height,, longitude, latitude, height...].
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
         * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
         * @returns {Cartesian3[]} The array of positions.
         *
         * @example
         * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
         */
        Cartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(coordinates)) {
                throw new DeveloperError('positions is required.');
            }
            if (coordinates.length < 3) {
                throw new DeveloperError('positions length cannot be less than 3.');
            }
            if (coordinates.length % 3 !== 0) {
                throw new DeveloperError('positions length must be a multiple of 3.');
            }
            //>>includeEnd('debug');

            var length = coordinates.length;
            if (!defined(result)) {
                result = new Array(length / 3);
            } else {
                result.length = length / 3;
            }

            for (var i = 0; i < length; i += 3) {
                var lon = coordinates[i];
                var lat = coordinates[i + 1];
                var alt = coordinates[i + 2];
                result[i / 3] = Cartesian3.fromRadians(lon, lat, alt, ellipsoid, result[i / 3]);
            }

            return result;
        };

        /**
         * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
         *
         * @type {Cartesian3}
         * @constant
         */
        Cartesian3.ZERO = freezeObject(new Cartesian3(0.0, 0.0, 0.0));

        /**
         * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
         *
         * @type {Cartesian3}
         * @constant
         */
        Cartesian3.UNIT_X = freezeObject(new Cartesian3(1.0, 0.0, 0.0));

        /**
         * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
         *
         * @type {Cartesian3}
         * @constant
         */
        Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0.0, 1.0, 0.0));

        /**
         * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
         *
         * @type {Cartesian3}
         * @constant
         */
        Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0.0, 0.0, 1.0));

        /**
         * Duplicates this Cartesian3 instance.
         *
         * @param {Cartesian3} [result] The object onto which to store the result.
         * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
         */
        Cartesian3.prototype.clone = function (result) {
            return Cartesian3.clone(this, result);
        };

        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
         * <code>true</code> if they are equal, <code>false</code> otherwise.
         *
         * @param {Cartesian3} [right] The right hand side Cartesian.
         * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
         */
        Cartesian3.prototype.equals = function (right) {
            return Cartesian3.equals(this, right);
        };

        /**
         * Compares this Cartesian against the provided Cartesian componentwise and returns
         * <code>true</code> if they pass an absolute or relative tolerance test,
         * <code>false</code> otherwise.
         *
         * @param {Cartesian3} [right] The right hand side Cartesian.
         * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
         * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
         * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
         */
        Cartesian3.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {
            return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);
        };

        /**
         * Creates a string representing this Cartesian in the format '(x, y, z)'.
         *
         * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.
         */
        Cartesian3.prototype.toString = function () {
            return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
        };

        return Cartesian3;
    }).call(this, $__require('2c'), $__require('23'), $__require('25'), $__require('28'), $__require('30'));
});
/*global define*/
$__System.registerDynamic('25', ['23'], false, function ($__require, $__exports, $__module) {
    return (function (defined) {
        'use strict';

        /**
         * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
         * argument out of range, etc.  This exception should only be thrown during development;
         * it usually indicates a bug in the calling code.  This exception should never be
         * caught; instead the calling code should strive not to generate it.
         * <br /><br />
         * On the other hand, a {@link RuntimeError} indicates an exception that may
         * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
         * to catch.
         *
         * @alias DeveloperError
         * @constructor
         * @extends Error
         *
         * @param {String} [message] The error message for this exception.
         *
         * @see RuntimeError
         */

        function DeveloperError(message) {
            /**
             * 'DeveloperError' indicating that this exception was thrown due to a developer error.
             * @type {String}
             * @readonly
             */
            this.name = 'DeveloperError';

            /**
             * The explanation for why this exception was thrown.
             * @type {String}
             * @readonly
             */
            this.message = message;

            //Browsers such as IE don't have a stack property until you actually throw the error.
            var stack;
            try {
                throw new Error();
            } catch (e) {
                stack = e.stack;
            }

            /**
             * The stack trace of this exception, if available.
             * @type {String}
             * @readonly
             */
            this.stack = stack;
        }

        if (defined(Object.create)) {
            DeveloperError.prototype = Object.create(Error.prototype);
            DeveloperError.prototype.constructor = DeveloperError;
        }

        DeveloperError.prototype.toString = function () {
            var str = this.name + ': ' + this.message;

            if (defined(this.stack)) {
                str += '\n' + this.stack.toString();
            }

            return str;
        };

        /**
         * @private
         */
        DeveloperError.throwInstantiationError = function () {
            throw new DeveloperError('This function defines an interface and should not be called directly.');
        };

        return DeveloperError;
    }).call(this, $__require('23'));
});
/*global define*/
$__System.registerDynamic('23', [], false, function ($__require, $__exports, $__module) {
    return (function () {
        'use strict';

        /**
         * @exports defined
         *
         * @param {Object} value The object.
         * @returns {Boolean} Returns true if the object is defined, returns false otherwise.
         *
         * @example
         * if (Cesium.defined(positions)) {
         *      doSomething();
         * } else {
         *      doSomethingElse();
         * }
         */

        function defined(value) {
            return value !== undefined && value !== null;
        }

        return defined;
    }).call(this);
});
/*global define*/
$__System.registerDynamic('28', ['23'], false, function ($__require, $__exports, $__module) {
    return (function (defined) {
        'use strict';

        /**
         * Freezes an object, using Object.freeze if available, otherwise returns
         * the object unchanged.  This function should be used in setup code to prevent
         * errors from completely halting JavaScript execution in legacy browsers.
         *
         * @private
         *
         * @exports freezeObject
         */

        var freezeObject = Object.freeze;
        if (!defined(freezeObject)) {
            freezeObject = function (o) {
                return o;
            };
        }

        return freezeObject;
    }).call(this, $__require('23'));
});
/*global define*/
$__System.registerDynamic('4d', ['35', '23', '25', '28'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, defined, DeveloperError, freezeObject) {
        'use strict';

        /**
         * A plane in Hessian Normal Form defined by
         * <pre>
         * ax + by + cz + d = 0
         * </pre>
         * where (a, b, c) is the plane's <code>normal</code>, d is the signed
         * <code>distance</code> to the plane, and (x, y, z) is any point on
         * the plane.
         *
         * @alias Plane
         * @constructor
         *
         * @param {Cartesian3} normal The plane's normal (normalized).
         * @param {Number} distance The shortest distance from the origin to the plane.  The sign of
         * <code>distance</code> determines which side of the plane the origin
         * is on.  If <code>distance</code> is positive, the origin is in the half-space
         * in the direction of the normal; if negative, the origin is in the half-space
         * opposite to the normal; if zero, the plane passes through the origin.
         *
         * @example
         * // The plane x=0
         * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);
         */

        function Plane(normal, distance) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(normal)) {
                throw new DeveloperError('normal is required.');
            }
            if (!defined(distance)) {
                throw new DeveloperError('distance is required.');
            }
            //>>includeEnd('debug');

            /**
             * The plane's normal.
             *
             * @type {Cartesian3}
             */
            this.normal = Cartesian3.clone(normal);

            /**
             * The shortest distance from the origin to the plane.  The sign of
             * <code>distance</code> determines which side of the plane the origin
             * is on.  If <code>distance</code> is positive, the origin is in the half-space
             * in the direction of the normal; if negative, the origin is in the half-space
             * opposite to the normal; if zero, the plane passes through the origin.
             *
             * @type {Number}
             */
            this.distance = distance;
        }

        /**
         * Creates a plane from a normal and a point on the plane.
         *
         * @param {Cartesian3} point The point on the plane.
         * @param {Cartesian3} normal The plane's normal (normalized).
         * @param {Plane} [result] The object onto which to store the result.
         * @returns {Plane} A new plane instance or the modified result parameter.
         *
         * @example
         * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
         * var normal = ellipsoid.geodeticSurfaceNormal(point);
         * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);
         */
        Plane.fromPointNormal = function (point, normal, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(point)) {
                throw new DeveloperError('point is required.');
            }
            if (!defined(normal)) {
                throw new DeveloperError('normal is required.');
            }
            //>>includeEnd('debug');

            var distance = -Cartesian3.dot(normal, point);

            if (!defined(result)) {
                return new Plane(normal, distance);
            }

            Cartesian3.clone(normal, result.normal);
            result.distance = distance;
            return result;
        };

        var scratchNormal = new Cartesian3();
        /**
         * Creates a plane from the general equation
         *
         * @param {Cartesian4} coefficients The plane's normal (normalized).
         * @param {Plane} [result] The object onto which to store the result.
         * @returns {Plane} A new plane instance or the modified result parameter.
         */
        Plane.fromCartesian4 = function (coefficients, result) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(coefficients)) {
                throw new DeveloperError('coefficients is required.');
            }
            //>>includeEnd('debug');

            var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);
            var distance = coefficients.w;

            if (!defined(result)) {
                return new Plane(normal, distance);
            } else {
                Cartesian3.clone(normal, result.normal);
                result.distance = distance;
                return result;
            }
        };

        /**
         * Computes the signed shortest distance of a point to a plane.
         * The sign of the distance determines which side of the plane the point
         * is on.  If the distance is positive, the point is in the half-space
         * in the direction of the normal; if negative, the point is in the half-space
         * opposite to the normal; if zero, the plane passes through the point.
         *
         * @param {Plane} plane The plane.
         * @param {Cartesian3} point The point.
         * @returns {Number} The signed shortest distance of the point to the plane.
         */
        Plane.getPointDistance = function (plane, point) {
            //>>includeStart('debug', pragmas.debug);
            if (!defined(plane)) {
                throw new DeveloperError('plane is required.');
            }
            if (!defined(point)) {
                throw new DeveloperError('point is required.');
            }
            //>>includeEnd('debug');

            return Cartesian3.dot(plane.normal, point) + plane.distance;
        };

        /**
         * A constant initialized to the XY plane passing through the origin, with normal in positive Z.
         *
         * @type {Plane}
         * @constant
         */
        Plane.ORIGIN_XY_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Z, 0.0));

        /**
         * A constant initialized to the YZ plane passing through the origin, with normal in positive X.
         *
         * @type {Plane}
         * @constant
         */
        Plane.ORIGIN_YZ_PLANE = freezeObject(new Plane(Cartesian3.UNIT_X, 0.0));

        /**
         * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.
         *
         * @type {Plane}
         * @constant
         */
        Plane.ORIGIN_ZX_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Y, 0.0));

        return Plane;
    }).call(this, $__require('35'), $__require('23'), $__require('25'), $__require('28'));
});
/*global define*/
$__System.registerDynamic('77', ['35', '44', '2c', '23', '25', '45', '6f', '74', '75', '30', '3c', '4d'], false, function ($__require, $__exports, $__module) {
    return (function (Cartesian3, Cartographic, defaultValue, defined, DeveloperError, Ellipsoid, EllipsoidGeodesic, IntersectionTests, isArray, CesiumMath, Matrix4, Plane) {
        'use strict';

        /**
         * @private
         */

        var PolylinePipeline = {};

        PolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {
            var distance = Cartesian3.distance(p0, p1);
            return Math.ceil(distance / minDistance);
        };

        var cartoScratch = new Cartographic();
        PolylinePipeline.extractHeights = function (positions, ellipsoid) {
            var length = positions.length;
            var heights = new Array(length);
            for (var i = 0; i < length; i++) {
                var p = positions[i];
                heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;
            }
            return heights;
        };

        var wrapLongitudeInversMatrix = new Matrix4();
        var wrapLongitudeOrigin = new Cartesian3();
        var wrapLongitudeXZNormal = new Cartesian3();
        var wrapLongitudeXZPlane = new Plane(Cartesian3.ZERO, 0.0);
        var wrapLongitudeYZNormal = new Cartesian3();
        var wrapLongitudeYZPlane = new Plane(Cartesian3.ZERO, 0.0);
        var wrapLongitudeIntersection = new Cartesian3();
        var wrapLongitudeOffset = new Cartesian3();

        var subdivideHeightsScratchArray = [];

        function subdivideHeights(numPoints, h0, h1) {
            var heights = subdivideHeightsScratchArray;
            heights.length = numPoints;

            var i;
            if (h0 === h1) {
                for (i = 0; i < numPoints; i++) {
                    heights[i] = h0;
                }
                return heights;
            }

            var dHeight = h1 - h0;
            var heightPerVertex = dHeight / numPoints;

            for (i = 0; i < numPoints; i++) {
                var h = h0 + i * heightPerVertex;
                heights[i] = h;
            }

            return heights;
        }

        var carto1 = new Cartographic();
        var carto2 = new Cartographic();
        var cartesian = new Cartesian3();
        var scaleFirst = new Cartesian3();
        var scaleLast = new Cartesian3();
        var ellipsoidGeodesic = new EllipsoidGeodesic();

        //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.
        //Result includes p1, but not include p2.  This function is called for a sequence of line segments,
        //and this prevents duplication of end point.
        function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {
            var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);
            var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);
            var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);
            var start = ellipsoid.cartesianToCartographic(first, carto1);
            var end = ellipsoid.cartesianToCartographic(last, carto2);
            var heights = subdivideHeights(numPoints, h0, h1);

            ellipsoidGeodesic.setEndPoints(start, end);
            var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;

            var index = offset;
            start.height = h0;
            var cart = ellipsoid.cartographicToCartesian(start, cartesian);
            Cartesian3.pack(cart, array, index);
            index += 3;

            for (var i = 1; i < numPoints; i++) {
                var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);
                carto.height = heights[i];
                cart = ellipsoid.cartographicToCartesian(carto, cartesian);
                Cartesian3.pack(cart, array, index);
                index += 3;
            }

            return index;
        }

        /**
         * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.
         *
         * @param {Cartesian3[]} positions The polyline's Cartesian positions.
         * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine
         * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and
         * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
         * The matrix is not verified to be in the proper form.
         * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a
         * <code>segments</code> property.
         *
         *
         * @example
         * var polylines = new Cesium.PolylineCollection();
         * var polyline = polylines.add(...);
         * var positions = polyline.positions;
         * var modelMatrix = polylines.modelMatrix;
         * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);
         *
         * @see PolygonPipeline.wrapLongitude
         * @see Polyline
         * @see PolylineCollection
         */
        PolylinePipeline.wrapLongitude = function (positions, modelMatrix) {
            var cartesians = [];
            var segments = [];

            if (defined(positions) && positions.length > 0) {
                modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);
                var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);

                var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);
                var xzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal);
                var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);
                var yzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal);
                var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);

                var count = 1;
                cartesians.push(Cartesian3.clone(positions[0]));
                var prev = cartesians[0];

                var length = positions.length;
                for (var i = 1; i < length; ++i) {
                    var cur = positions[i];

                    // intersects the IDL if either endpoint is on the negative side of the yz-plane
                    if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {
                        // and intersects the xz-plane
                        var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);
                        if (defined(intersection)) {
                            // move point on the xz-plane slightly away from the plane
                            var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);
                            if (Plane.getPointDistance(xzPlane, prev) < 0.0) {
                                Cartesian3.negate(offset, offset);
                            }

                            cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
                            segments.push(count + 1);

                            Cartesian3.negate(offset, offset);
                            cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
                            count = 1;
                        }
                    }

                    cartesians.push(Cartesian3.clone(positions[i]));
                    count++;

                    prev = cur;
                }

                segments.push(count);
            }

            return {
                positions: cartesians,
                lengths: segments
            };
        };

        /**
         * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.
         * @param {Cartesian3[]} positions The array of type {Cartesian3} representing positions.
         * @param {Number|Number[]} [height=0.0] A number or array of numbers representing the heights of each position.
         * @param {Number} [granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.
         * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.
         *
         * @example
         * var positions = Cesium.Cartesian3.fromDegreesArray([
         *   -105.0, 40.0,
         *   -100.0, 38.0,
         *   -105.0, 35.0,
         *   -100.0, 32.0
         * ]);
         * var surfacePositions = Cesium.PolylinePipeline.generateArc({
         *   positons: positions
         * });
         */
        PolylinePipeline.generateArc = function (options) {
            if (!defined(options)) {
                options = {};
            }
            var positions = options.positions;
            //>>includeStart('debug', pragmas.debug);
            if (!defined(positions)) {
                throw new DeveloperError('options.positions is required.');
            }
            //>>includeEnd('debug');

            var length = positions.length;
            var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
            var height = defaultValue(options.height, 0);

            if (length < 1) {
                return [];
            } else if (length === 1) {
                var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);
                if (height !== 0) {
                    var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);
                    Cartesian3.multiplyByScalar(n, height, n);
                    Cartesian3.add(p, n, p);
                }

                return [p.x, p.y, p.z];
            }

            var minDistance = options.minDistance;
            if (!defined(minDistance)) {
                var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
                minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
            }

            var numPoints = 0;
            var i;

            for (i = 0; i < length - 1; i++) {
                numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);
            }

            var arrayLength = (numPoints + 1) * 3;
            var newPositions = new Array(arrayLength);
            var offset = 0;
            var hasHeightArray = isArray(height);

            for (i = 0; i < length - 1; i++) {
                var p0 = positions[i];
                var p1 = positions[i + 1];

                var h0 = hasHeightArray ? height[i] : height;
                var h1 = hasHeightArray ? height[i + 1] : height;

                offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);
            }

            subdivideHeightsScratchArray.length = 0;

            var lastPoint = positions[length - 1];
            var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);
            carto.height = hasHeightArray ? height[length - 1] : height;
            var cart = ellipsoid.cartographicToCartesian(carto, cartesian);
            Cartesian3.pack(cart, newPositions, arrayLength - 3);

            return newPositions;
        };

        /**
         * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.
         * @param {Cartesian3[]} positions The array of type {Cartesian3} representing positions.
         * @param {Number|Number[]} [height=0.0] A number or array of numbers representing the heights of each position.
         * @param {Number} [granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
         * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.
         * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.
         *
         * @example
         * var positions = Cesium.Cartesian3.fromDegreesArray([
         *   -105.0, 40.0,
         *   -100.0, 38.0,
         *   -105.0, 35.0,
         *   -100.0, 32.0
         * ]);
         * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({
         *   positons: positions
         * });
         */
        PolylinePipeline.generateCartesianArc = function (options) {
            var numberArray = PolylinePipeline.generateArc(options);
            var size = numberArray.length / 3;
            var newPositions = new Array(size);
            for (var i = 0; i < size; i++) {
                newPositions[i] = Cartesian3.unpack(numberArray, i * 3);
            }
            return newPositions;
        };

        return PolylinePipeline;
    }).call(this, $__require('35'), $__require('44'), $__require('2c'), $__require('23'), $__require('25'), $__require('45'), $__require('6f'), $__require('74'), $__require('75'), $__require('30'), $__require('3c'), $__require('4d'));
});
// Add functionality for keeping a moving window of samples per SampledProperty,
// so that the data doesn't accumulate indefinitely
$__System.register("78", ["13"], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var cesium_imports_1;
    var after;
    function removeBeforeDate(property, time) {
        var times = property._times;
        var index = ~cesium_imports_1.binarySearch(times, time, cesium_imports_1.JulianDate.compare);
        if (index > 0) {
            times.splice(0, index);
            property._values.splice(0, index * property._innerType.packedLength);
            property._updateTableLength = true;
            property._definitionChanged.raiseEvent(property);
        }
    }
    function removeOldSamples(property, maxNumSamples) {
        if (maxNumSamples === undefined) return;
        var removeCount = property._times.length - maxNumSamples;
        if (removeCount > 0) {
            property._times.splice(0, removeCount);
            property._values.splice(0, removeCount * property._innerType.packedLength);
            property._updateTableLength = true;
        }
    }
    return {
        setters: [function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }],
        execute: function () {
            after = function (fn, after) {
                return function () {
                    var result = fn.apply(this, arguments);
                    after.call(this, result);
                    return result;
                };
            };
            cesium_imports_1.SampledProperty.prototype.removeSamplesBeforeDate = function (time) {
                removeBeforeDate(this, time);
            };
            cesium_imports_1.SampledPositionProperty.prototype.removeSamplesBeforeDate = function (time) {
                removeBeforeDate(this._property, time);
            };
            cesium_imports_1.SampledProperty.prototype.addSample = after(cesium_imports_1.SampledProperty.prototype.addSample, function () {
                removeOldSamples(this, this.maxNumSamples);
            });
            cesium_imports_1.SampledProperty.prototype.addSamples = after(cesium_imports_1.SampledProperty.prototype.addSamples, function () {
                removeOldSamples(this, this.maxNumSamples);
            });
            cesium_imports_1.SampledProperty.prototype.addSamplesPackedArray = after(cesium_imports_1.SampledProperty.prototype.addSamplesPackedArray, function () {
                removeOldSamples(this, this.maxNumSamples);
            });
            cesium_imports_1.SampledPositionProperty.prototype.addSample = after(cesium_imports_1.SampledPositionProperty.prototype.addSample, function () {
                removeOldSamples(this._property, this.maxNumSamples);
            });
            cesium_imports_1.SampledPositionProperty.prototype.addSamples = after(cesium_imports_1.SampledPositionProperty.prototype.addSamples, function () {
                removeOldSamples(this._property, this.maxNumSamples);
            });
            cesium_imports_1.SampledPositionProperty.prototype.addSamplesPackedArray = after(cesium_imports_1.SampledPositionProperty.prototype.addSamplesPackedArray, function () {
                removeOldSamples(this._property, this.maxNumSamples);
            });
        }
    };
});
$__System.register('13', ['55', '22', '4e', '35', '4c', '2a', '2b', '2e', '34', '38', '2f', '2c', '23', '25', '45', '31', '32', '26', '53', '43', '46', '2d', '30', '3b', '3c', '47', '48', '49', '37', '3f', '3d', '4f', '36', '50', '51', '52', '3e', '6d', '77', '78'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    return {
        setters: [function (binarySearch_1_1) {
            exports_1({
                "binarySearch": binarySearch_1_1["default"]
            });
        }, function (CallbackProperty_1_1) {
            exports_1({
                "CallbackProperty": CallbackProperty_1_1["default"]
            });
        }, function (Cartesian2_1_1) {
            exports_1({
                "Cartesian2": Cartesian2_1_1["default"]
            });
        }, function (Cartesian3_1_1) {
            exports_1({
                "Cartesian3": Cartesian3_1_1["default"]
            });
        }, function (Cartesian4_1_1) {
            exports_1({
                "Cartesian4": Cartesian4_1_1["default"]
            });
        }, function (Clock_1_1) {
            exports_1({
                "Clock": Clock_1_1["default"]
            });
        }, function (ClockStep_1_1) {
            exports_1({
                "ClockStep": ClockStep_1_1["default"]
            });
        }, function (CompositeEntityCollection_1_1) {
            exports_1({
                "CompositeEntityCollection": CompositeEntityCollection_1_1["default"]
            });
        }, function (ConstantPositionProperty_1_1) {
            exports_1({
                "ConstantPositionProperty": ConstantPositionProperty_1_1["default"]
            });
        }, function (ConstantProperty_1_1) {
            exports_1({
                "ConstantProperty": ConstantProperty_1_1["default"]
            });
        }, function (createGuid_1_1) {
            exports_1({
                "createGuid": createGuid_1_1["default"]
            });
        }, function (defaultValue_1_1) {
            exports_1({
                "defaultValue": defaultValue_1_1["default"]
            });
        }, function (defined_1_1) {
            exports_1({
                "defined": defined_1_1["default"]
            });
        }, function (DeveloperError_1_1) {
            exports_1({
                "DeveloperError": DeveloperError_1_1["default"]
            });
        }, function (Ellipsoid_1_1) {
            exports_1({
                "Ellipsoid": Ellipsoid_1_1["default"]
            });
        }, function (Entity_1_1) {
            exports_1({
                "Entity": Entity_1_1["default"]
            });
        }, function (EntityCollection_1_1) {
            exports_1({
                "EntityCollection": EntityCollection_1_1["default"]
            });
        }, function (Event_1_1) {
            exports_1({
                "Event": Event_1_1["default"]
            });
        }, function (ExtrapolationType_1_1) {
            exports_1({
                "ExtrapolationType": ExtrapolationType_1_1["default"]
            });
        }, function (GeographicProjection_1_1) {
            exports_1({
                "GeographicProjection": GeographicProjection_1_1["default"]
            });
        }, function (HermitePolynomialApproximation_1_1) {
            exports_1({
                "HermitePolynomialApproximation": HermitePolynomialApproximation_1_1["default"]
            });
        }, function (JulianDate_1_1) {
            exports_1({
                "JulianDate": JulianDate_1_1["default"]
            });
        }, function (Math_1_1) {
            exports_1({
                "CesiumMath": Math_1_1["default"]
            });
        }, function (Matrix3_1_1) {
            exports_1({
                "Matrix3": Matrix3_1_1["default"]
            });
        }, function (Matrix4_1_1) {
            exports_1({
                "Matrix4": Matrix4_1_1["default"]
            });
        }, function (OrientationProperty_1_1) {
            exports_1({
                "OrientationProperty": OrientationProperty_1_1["default"]
            });
        }, function (PerspectiveFrustum_1_1) {
            exports_1({
                "PerspectiveFrustum": PerspectiveFrustum_1_1["default"]
            });
        }, function (PerspectiveOffCenterFrustum_1_1) {
            exports_1({
                "PerspectiveOffCenterFrustum": PerspectiveOffCenterFrustum_1_1["default"]
            });
        }, function (PositionProperty_1_1) {
            exports_1({
                "PositionProperty": PositionProperty_1_1["default"]
            });
        }, function (Property_1_1) {
            exports_1({
                "Property": Property_1_1["default"]
            });
        }, function (Quaternion_1_1) {
            exports_1({
                "Quaternion": Quaternion_1_1["default"]
            });
        }, function (ReferenceEntity_1_1) {
            exports_1({
                "ReferenceEntity": ReferenceEntity_1_1["default"]
            });
        }, function (ReferenceFrame_1_1) {
            exports_1({
                "ReferenceFrame": ReferenceFrame_1_1["default"]
            });
        }, function (ReferenceProperty_1_1) {
            exports_1({
                "ReferenceProperty": ReferenceProperty_1_1["default"]
            });
        }, function (SampledPositionProperty_1_1) {
            exports_1({
                "SampledPositionProperty": SampledPositionProperty_1_1["default"]
            });
        }, function (SampledProperty_1_1) {
            exports_1({
                "SampledProperty": SampledProperty_1_1["default"]
            });
        }, function (Transforms_1_1) {
            exports_1({
                "Transforms": Transforms_1_1["default"]
            });
        }, function (Simon1994PlanetaryPositions_1_1) {
            exports_1({
                "Simon1994PlanetaryPositions": Simon1994PlanetaryPositions_1_1["default"]
            });
        }, function (PolylinePipeline_1_1) {
            exports_1({
                "PolylinePipeline": PolylinePipeline_1_1["default"]
            });
        }, function (_1) {}],
        execute: function () {}
    };
});
$__System.register('1b', ['26', '13'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var Event_1, cesium_imports_1;
    var Event, CommandQueue, getEntityPosition, getEntityOrientation, urlParser, MessageChannelLike, SynchronousMessageChannel, MessageChannelFactory, scratchPerspectiveOffCenterFrustum, scratchCartesian, scratchOrientation;
    /**
     * Get array of ancestor reference frames of a Cesium Entity.
     * @param frame A Cesium Entity to get ancestor reference frames.
     * @param frames An array of reference frames of the Cesium Entity.
     */
    function getAncestorReferenceFrames(frame) {
        var frames = [];
        var f = frame;
        while (cesium_imports_1.defined(f)) {
            frames.unshift(f);
            var position = f.position;
            f = position && position.referenceFrame;
        }
        return frames;
    }
    exports_1("getAncestorReferenceFrames", getAncestorReferenceFrames);
    /**
     * Get root reference frame of the Cesium Entity.
     * @param frames An array of reference frames of the Cesium Entity.
     * @return the first frame from ancestor reference frames array.
     */
    function getRootReferenceFrame(frame) {
        return getAncestorReferenceFrames(frame)[0];
    }
    exports_1("getRootReferenceFrame", getRootReferenceFrame);
    /**
     * Gets the value of the Position property at the provided time and in the provided reference frame.
     * @param entity The entity to get position.
     * @param time The time for which to retrieve the value.
     * @param referenceFrame The desired referenceFrame of the result.
     * @param result The object to store the value into.
     * @return The modified result parameter.
     */
    function getEntityPositionInReferenceFrame(entity, time, referenceFrame, result) {
        return entity.position && entity.position.getValueInReferenceFrame(time, referenceFrame, result);
    }
    exports_1("getEntityPositionInReferenceFrame", getEntityPositionInReferenceFrame);
    /**
     * Get the value of the Orientation property at the provided time and in the provided reference frame.
     * @param entity The entity to get position.
     * @param time The time for which to retrieve the value.
     * @param referenceFrame The desired referenceFrame of the result.
     * @param result The object to store the value into.
     * @return The modified result parameter.
     */
    function getEntityOrientationInReferenceFrame(entity, time, referenceFrame, result) {
        var entityFrame = entity.position && entity.position.referenceFrame;
        if (!cesium_imports_1.defined(entityFrame)) return undefined;
        var orientation = entity.orientation && entity.orientation.getValue(time, result);
        if (!cesium_imports_1.defined(orientation)) return undefined;
        return cesium_imports_1.OrientationProperty.convertToReferenceFrame(time, orientation, entityFrame, referenceFrame, result);
    }
    exports_1("getEntityOrientationInReferenceFrame", getEntityOrientationInReferenceFrame);
    // const scratchCartesianPositionFIXED = new Cartesian3
    // const scratchMatrix4 = new Matrix4
    // const scratchMatrix3 = new Matrix3
    //  {
    //         // if no orientation is available, calculate an orientation based on position
    //         const entityPositionFIXED = getEntityPositionInReferenceFrame(entity, time, ReferenceFrame.FIXED, scratchCartesianPositionFIXED)
    //         if (!entityPositionFIXED) return Quaternion.clone(Quaternion.IDENTITY, result)
    //         if (Cartesian3.ZERO.equals(entityPositionFIXED)) throw new Error('invalid cartographic position')
    //         const transform = Transforms.eastNorthUpToFixedFrame(entityPositionFIXED, Ellipsoid.WGS84, scratchMatrix4);
    //         const rotation = Matrix4.getRotation(transform, scratchMatrix3);
    //         const fixedOrientation = Quaternion.fromRotationMatrix(rotation, result);
    //         return OrientationProperty.convertToReferenceFrame(time, fixedOrientation, ReferenceFrame.FIXED, referenceFrame, result)
    //     }
    /**
     * Create a SerializedEntityPose from a source entity.
     * @param entity The entity which the serialized pose represents.
     * @param time The time which to retrieve the pose.
     * @param referenceFrame The reference frame to use for generating the pose.
     *  By default, uses the root reference frame of the entity.
     * @return An EntityPose object with orientation, position and referenceFrame.
     */
    function getSerializedEntityPose(entity, time, referenceFrame) {
        var frame = referenceFrame ? referenceFrame : getRootReferenceFrame(entity);
        var p = getEntityPositionInReferenceFrame(entity, time, frame, {});
        if (!p) return undefined;
        var o = getEntityOrientationInReferenceFrame(entity, time, frame, {});
        if (!o) return undefined;
        return {
            p: cesium_imports_1.Cartesian3.ZERO.equalsEpsilon(p, cesium_imports_1.CesiumMath.EPSILON16) ? 0 : p,
            o: cesium_imports_1.Quaternion.IDENTITY.equalsEpsilon(o, cesium_imports_1.CesiumMath.EPSILON16) ? 0 : o,
            r: typeof frame === 'number' ? frame : frame.id
        };
    }
    exports_1("getSerializedEntityPose", getSerializedEntityPose);
    /**
     * If urlParser does not have a value, throw error message "resolveURL requires DOM api".
     * If inURL is undefined, throw error message "expected inURL".
     * Otherwise, assign value of inURL to urlParser.href.
     * @param inURL A URL needed to be resolved.
     * @returns A URL ready to be parsed.
     */
    function resolveURL(inURL) {
        if (!urlParser) throw new Error("resolveURL requires DOM api");
        if (inURL === undefined) throw new Error('Expected inURL');
        urlParser.href = '';
        urlParser.href = inURL;
        return urlParser.href;
    }
    exports_1("resolveURL", resolveURL);
    /**
     * Parse URL to an object describing details of the URL with href, protocol,
     * hostname, port, pathname, search, hash, host.
     * @param inURL A URL needed to be parsed.
     * @return An object showing parsed URL with href, protocol,
     * hostname, port, pathname, search, hash, host.
     */
    function parseURL(inURL) {
        if (!urlParser) throw new Error("parseURL requires DOM api");
        if (inURL === undefined) throw new Error('Expected inURL');
        urlParser.href = '';
        urlParser.href = inURL;
        return {
            href: urlParser.href,
            protocol: urlParser.protocol,
            hostname: urlParser.hostname,
            port: urlParser.port,
            pathname: urlParser.pathname,
            search: urlParser.search,
            hash: urlParser.hash,
            host: urlParser.host
        };
    }
    exports_1("parseURL", parseURL);
    function decomposePerspectiveOffCenterProjectionMatrix(mat, result) {
        var m11 = mat[cesium_imports_1.Matrix4.COLUMN0ROW0];
        // const m12 = mat[Matrix4.COLUMN0ROW1];
        var m22 = mat[cesium_imports_1.Matrix4.COLUMN1ROW1];
        var m31 = mat[cesium_imports_1.Matrix4.COLUMN2ROW0];
        var m32 = mat[cesium_imports_1.Matrix4.COLUMN2ROW1];
        var m33 = mat[cesium_imports_1.Matrix4.COLUMN2ROW2];
        var m43 = mat[cesium_imports_1.Matrix4.COLUMN3ROW2];
        var near = result.near = m43 / (m33 - 1);
        result.far = m43 / (m33 + 1);
        result.bottom = near * (m32 - 1) / m22;
        result.top = near * (m32 + 1) / m22;
        result.left = near * (m31 - 1) / m11;
        result.right = near * (m31 + 1) / m11;
        return result;
    }
    exports_1("decomposePerspectiveOffCenterProjectionMatrix", decomposePerspectiveOffCenterProjectionMatrix);
    function decomposePerspectiveProjectionMatrix(mat, result) {
        var f = decomposePerspectiveOffCenterProjectionMatrix(mat, scratchPerspectiveOffCenterFrustum);
        var xOffset = (f.left + f.right) / 2;
        var yOffset = (f.top + f.bottom) / 2;
        var near = f.near;
        var far = f.far;
        // const left = f.left - xOffset;
        var right = f.right - xOffset;
        var top = f.top - yOffset;
        // const bottom = f.bottom - yOffset;
        var aspectRatio = right / top;
        var fovy = 2 * Math.atan(top / near);
        var fov;
        if (aspectRatio < 1) {
            fov = fovy;
        } else {
            fov = Math.atan(Math.tan(fovy * 0.5) * aspectRatio) * 2.0;
        }
        result.near = near;
        result.far = far;
        result.fov = fov;
        result.aspectRatio = aspectRatio;
        result.xOffset = xOffset;
        result.yOffset = yOffset;
        return result;
    }
    exports_1("decomposePerspectiveProjectionMatrix", decomposePerspectiveProjectionMatrix);
    /**
     * Convert an Entity's position and orientation properties to a new reference frame.
     * The properties must be constant properties.
     * @param entity The entity to convert.
     * @param time The time which to retrieve the pose up the reference chain.
     * @param referenceFrame The reference frame to convert the position and oriention to.
     * @return a boolean indicating success or failure.  Will be false if either property is
     * not constant, or if either property cannot be converted to the new frame.
     */
    function convertEntityReferenceFrame(entity, time, frame) {
        if (!entity.position || !(entity.position instanceof cesium_imports_1.ConstantPositionProperty) || !entity.orientation || !(entity.orientation instanceof cesium_imports_1.ConstantProperty)) {
            return false;
        }
        if (!getEntityPositionInReferenceFrame(entity, time, frame, scratchCartesian)) {
            return false;
        }
        if (!getEntityOrientationInReferenceFrame(entity, time, frame, scratchOrientation)) {
            return false;
        }
        entity.position.setValue(scratchCartesian, frame);
        entity.orientation.setValue(scratchOrientation);
        return true;
    }
    exports_1("convertEntityReferenceFrame", convertEntityReferenceFrame);
    return {
        setters: [function (Event_1_1) {
            Event_1 = Event_1_1;
        }, function (cesium_imports_1_1) {
            cesium_imports_1 = cesium_imports_1_1;
        }],
        execute: function () {
            /**
             * Provides the ability raise and subscribe to an event.
             */
            Event = function () {
                function Event() {
                    this._event = new Event_1.default();
                }
                Object.defineProperty(Event.prototype, "numberOfListeners", {
                    /**
                     * Get the number of listeners currently subscribed to the event.
                     * @return Number of listeners currently subscribed to the event.
                     */
                    get: function () {
                        return this._event.numberOfListeners;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                  * Add an event listener.
                  * @param The function to be executed when the event is raised.
                  * @return A convenience function which removes this event listener when called
                  */
                Event.prototype.addEventListener = function (listener) {
                    return this._event.addEventListener(listener);
                };
                /**
                 * Remove an event listener.
                 * @param The function to be unregistered.
                 * @return True if the listener was removed;
                 * false if the listener and scope are not registered with the event.
                 */
                Event.prototype.removeEventListener = function (listener) {
                    return this._event.removeEventListener(listener);
                };
                /**
                 * Raises the event by calling each registered listener with all supplied arguments.
                 * @param This method takes any number of parameters and passes them through to the listener functions.
                 */
                Event.prototype.raiseEvent = function (data) {
                    this._event.raiseEvent(data);
                };
                return Event;
            }();
            exports_1("Event", Event);
            /**
            * TODO.
            */
            CommandQueue = function () {
                /**
                 * If errorEvent has 1 listener, outputs the error message to the web console.
                 */
                function CommandQueue() {
                    var _this = this;
                    this._queue = [];
                    this._paused = true;
                    /**
                     * An error event.
                     */
                    this.errorEvent = new Event();
                    this.errorEvent.addEventListener(function (error) {
                        if (_this.errorEvent.numberOfListeners === 1) console.error(error);
                    });
                }
                /**
                 * Push a command to the command queue.
                 * @param command Any command ready to be pushed into the command queue.
                 */
                CommandQueue.prototype.push = function (command, execute) {
                    var _this = this;
                    var result = new Promise(function (resolve, reject) {
                        _this._queue.push({
                            command: command,
                            reject: reject,
                            execute: function () {
                                // console.log('CommandQueue: Executing command ' + command.toString());
                                var result = Promise.resolve().then(command);
                                // result.then(() => { console.log('CommandQueue: DONE ' + command.toString()) });
                                resolve(result);
                                return result;
                            }
                        });
                    });
                    if (execute) this.execute();
                    return result;
                };
                /**
                 * Execute the command queue
                 */
                CommandQueue.prototype.execute = function () {
                    var _this = this;
                    this._paused = false;
                    Promise.resolve().then(function () {
                        if (_this._queue.length > 0 && !_this._currentCommandPending) {
                            _this._executeNextCommand();
                        }
                    });
                };
                /**
                 * Puase the command queue (currently executing commands will still complete)
                 */
                CommandQueue.prototype.pause = function () {
                    this._paused = true;
                };
                /**
                 * Clear commandQueue.
                 */
                CommandQueue.prototype.clear = function () {
                    this._queue.forEach(function (item) {
                        item.reject("Unable to execute.");
                    });
                    this._queue = [];
                };
                CommandQueue.prototype._executeNextCommand = function () {
                    var _this = this;
                    this._currentCommand = undefined;
                    this._currentCommandPending = undefined;
                    if (this._paused) return;
                    var item = this._queue.shift();
                    if (!item) return;
                    this._currentCommand = item.command;
                    this._currentCommandPending = item.execute().then(this._executeNextCommand.bind(this)).catch(function (e) {
                        _this.errorEvent.raiseEvent(e);
                        _this._executeNextCommand();
                    });
                };
                return CommandQueue;
            }();
            exports_1("CommandQueue", CommandQueue);
            /**
             * Alias of getEntityPositionInReferenceFrame
             */
            exports_1("getEntityPosition", getEntityPosition = getEntityPositionInReferenceFrame);
            /**
             * Alias of getEntityOrientationInReferenceFrame
             */
            exports_1("getEntityOrientation", getEntityOrientation = getEntityOrientationInReferenceFrame);
            urlParser = typeof document !== 'undefined' ? document.createElement("a") : undefined;
            /**
             * A MessageChannel pollyfill.
             */
            MessageChannelLike = function () {
                /**
                 * Create a MessageChannelLike instance.
                 */
                function MessageChannelLike() {
                    var messageChannel = this;
                    var _portsOpen = true;
                    var _port1ready;
                    var _port2ready;
                    var _port1onmessage;
                    _port1ready = new Promise(function (resolve) {
                        messageChannel.port1 = {
                            set onmessage(func) {
                                _port1onmessage = func;
                                resolve();
                            },
                            get onmessage() {
                                return _port1onmessage;
                            },
                            postMessage: function (data) {
                                if (_portsOpen) {
                                    _port2ready.then(function () {
                                        if (messageChannel.port2.onmessage) messageChannel.port2.onmessage({ data: data });
                                    });
                                }
                            },
                            close: function () {
                                _portsOpen = false;
                            }
                        };
                    });
                    var _port2onmessage;
                    _port2ready = new Promise(function (resolve) {
                        messageChannel.port2 = {
                            set onmessage(func) {
                                _port2onmessage = func;
                                resolve();
                            },
                            get onmessage() {
                                return _port2onmessage;
                            },
                            postMessage: function (data) {
                                if (_portsOpen) {
                                    _port1ready.then(function () {
                                        if (messageChannel.port1.onmessage) messageChannel.port1.onmessage({ data: data });
                                    });
                                }
                            },
                            close: function () {
                                _portsOpen = false;
                            }
                        };
                    });
                }
                return MessageChannelLike;
            }();
            exports_1("MessageChannelLike", MessageChannelLike);
            /**
             * A synchronous MessageChannel.
             */
            SynchronousMessageChannel = function () {
                /**
                 * Create a MessageChannelLike instance.
                 */
                function SynchronousMessageChannel() {
                    var messageChannel = this;
                    var pendingMessages1 = [];
                    var onmessage1 = function (message) {
                        pendingMessages1.push(message);
                    };
                    messageChannel.port1 = {
                        get onmessage() {
                            return onmessage1;
                        },
                        set onmessage(func) {
                            onmessage1 = func;
                            pendingMessages1.forEach(function (data) {
                                return func(data);
                            });
                            pendingMessages1 = [];
                        },
                        postMessage: function (data) {
                            if (messageChannel.port2.onmessage) messageChannel.port2.onmessage({ data: data });
                        },
                        close: function () {
                            messageChannel.port1.onmessage = undefined;
                            messageChannel.port2.onmessage = undefined;
                        }
                    };
                    var pendingMessages2 = [];
                    var onmessage2 = function (message) {
                        pendingMessages2.push(message);
                    };
                    messageChannel.port2 = {
                        get onmessage() {
                            return onmessage2;
                        },
                        set onmessage(func) {
                            onmessage2 = func;
                            pendingMessages2.forEach(function (data) {
                                return func(data);
                            });
                            pendingMessages2 = [];
                        },
                        postMessage: function (data) {
                            if (messageChannel.port1.onmessage) messageChannel.port1.onmessage({ data: data });
                        },
                        close: function () {
                            messageChannel.port1.onmessage = undefined;
                            messageChannel.port2.onmessage = undefined;
                        }
                    };
                }
                return SynchronousMessageChannel;
            }();
            exports_1("SynchronousMessageChannel", SynchronousMessageChannel);
            /**
             * A factory which creates MessageChannel or MessageChannelLike instances, depending on
             * wheter or not MessageChannel is avaialble in the execution context.
             */
            MessageChannelFactory = function () {
                function MessageChannelFactory() {}
                /**
                 * Create a MessageChannel (or MessageChannelLike) instance.
                 */
                MessageChannelFactory.prototype.create = function () {
                    if (typeof MessageChannel !== 'undefined') return new MessageChannel();else return new MessageChannelLike();
                };
                /**
                 * Create a SynchronousMessageChannel instance.
                 */
                MessageChannelFactory.prototype.createSynchronous = function () {
                    return new SynchronousMessageChannel();
                };
                return MessageChannelFactory;
            }();
            exports_1("MessageChannelFactory", MessageChannelFactory);
            scratchPerspectiveOffCenterFrustum = new cesium_imports_1.PerspectiveOffCenterFrustum();
            scratchCartesian = new cesium_imports_1.Cartesian3();
            scratchOrientation = new cesium_imports_1.Quaternion();
        }
    };
});
$__System.register('a', ['b', '15', '13', '10', '19', '18', '14', '12', '1d', '1a', '16', '20', '1c', '17', '1e', '21', '1b'], function (exports_1, context_1) {
    "use strict";

    var __moduleName = context_1 && context_1.id;
    var DI, Cesium, URI, session_1, common_1, context_2, device_1, focus_1, reality_1, timer_1, view_1, vuforia_1, empty_1, live_video_1, hosted_1;
    var ArgonSystem;
    /**
     * Create an ArgonSystem instance.
     * If we are running within a [[REALITY_MANAGER]],
     * this function will create an ArgonSystem which has the [[REALITY_AUGMENTOR]] role.
     * If we are not running within a [[REALITY_MANAGER]],
     * this function will create an ArgonSystem which has the [[REALITY_MANAGER]] role.
     * @param initParameters InitParameters
     */
    function init(_a) {
        var _b = _a === void 0 ? {} : _a,
            configuration = _b.configuration,
            _c = _b.container,
            container = _c === void 0 ? new DI.Container() : _c;
        var role;
        if (typeof HTMLElement === 'undefined') {
            role = common_1.Role.REALITY_MANAGER;
        } else if (navigator.userAgent.indexOf('Argon') > 0 || window.top !== window) {
            role = common_1.Role.APPLICATION; // TODO: switch to below after next argon-app release
        } else {
            role = common_1.Role.REALITY_MANAGER;
        }
        var config = Object.assign(configuration || {}, {
            role: role
        });
        container.registerInstance('containerElement', null);
        return new ArgonSystem(config, container);
    }
    exports_1("init", init);
    /**
     * Initialize an [[ArgonSystem]] with the [[REALITY_VIEW]] role
     */
    function initReality(_a) {
        var _b = _a === void 0 ? {} : _a,
            configuration = _b.configuration,
            _c = _b.container,
            container = _c === void 0 ? new DI.Container() : _c;
        var config = Object.assign(configuration || {}, {
            role: common_1.Role.REALITY_VIEW,
            'reality.supportsControlPort': true
        });
        container.registerInstance('containerElement', null);
        return new ArgonSystem(config, container);
    }
    exports_1("initReality", initReality);
    /**
     * Not yet implemented.
     * @private
     */
    function initLocal(_a) {
        var containerElement = _a.containerElement,
            configuration = _a.configuration,
            _b = _a.container,
            container = _b === void 0 ? new DI.Container() : _b;
        var config = Object.assign(configuration || {}, {
            role: common_1.Role.REALITY_MANAGER
        });
        container.registerInstance('containerElement', containerElement);
        return new ArgonSystem(config, container);
    }
    exports_1("initLocal", initLocal);
    var exportedNames_1 = {
        'ArgonSystem': true,
        'init': true,
        'initReality': true,
        'initLocal': true,
        'DI': true,
        'Cesium': true,
        'URI': true,
        'EmptyRealityLoader': true,
        'LiveVideoRealityLoader': true,
        'HostedRealityLoader': true
    };
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_1(exports);
    }
    return {
        setters: [function (_1) {}, function (DI_1) {
            DI = DI_1;
        }, function (Cesium_1) {
            Cesium = Cesium_1;
        }, function (URI_1) {
            URI = URI_1;
        }, function (session_1_1) {
            session_1 = session_1_1;
            exportStar_1(session_1_1);
        }, function (common_1_1) {
            common_1 = common_1_1;
            exportStar_1(common_1_1);
        }, function (context_2_1) {
            context_2 = context_2_1;
            exportStar_1(context_2_1);
        }, function (device_1_1) {
            device_1 = device_1_1;
            exportStar_1(device_1_1);
        }, function (focus_1_1) {
            focus_1 = focus_1_1;
            exportStar_1(focus_1_1);
        }, function (reality_1_1) {
            reality_1 = reality_1_1;
            exportStar_1(reality_1_1);
        }, function (timer_1_1) {
            timer_1 = timer_1_1;
            exportStar_1(timer_1_1);
        }, function (view_1_1) {
            view_1 = view_1_1;
            exportStar_1(view_1_1);
        }, function (vuforia_1_1) {
            vuforia_1 = vuforia_1_1;
            exportStar_1(vuforia_1_1);
        }, function (empty_1_1) {
            empty_1 = empty_1_1;
        }, function (live_video_1_1) {
            live_video_1 = live_video_1_1;
        }, function (hosted_1_1) {
            hosted_1 = hosted_1_1;
        }, function (utils_1_1) {
            exportStar_1(utils_1_1);
        }],
        execute: function () {
            exports_1("DI", DI);
            exports_1("Cesium", Cesium);
            exports_1("URI", URI);
            exports_1("EmptyRealityLoader", empty_1.EmptyRealityLoader);
            exports_1("LiveVideoRealityLoader", live_video_1.LiveVideoRealityLoader);
            exports_1("HostedRealityLoader", hosted_1.HostedRealityLoader);
            /**
             * A composition root which instantiates the object graph based on a provided configuration.
             * You generally want to create a new ArgonSystem via the provided [[init]] or [[initReality]] functions:
             * ```ts
             * var app = Argon.init(); // app is an instance of ArgonSystem
             * ```
             */
            ArgonSystem = function () {
                function ArgonSystem(config, container) {
                    if (container === void 0) {
                        container = new DI.Container();
                    }
                    this.container = container;
                    if (!ArgonSystem.instance) ArgonSystem.instance = this;
                    container.registerInstance('config', config);
                    container.registerInstance(ArgonSystem, this);
                    if (!container.hasResolver('containerElement')) container.registerInstance('containerElement', null);
                    if (config.role === common_1.Role.REALITY_MANAGER) {
                        container.registerSingleton(session_1.ConnectService, session_1.LoopbackConnectService);
                    } else if (session_1.WKWebViewConnectService.isAvailable()) {
                        container.registerSingleton(session_1.ConnectService, session_1.WKWebViewConnectService);
                    } else if (session_1.DOMConnectService.isAvailable()) {
                        container.registerSingleton(session_1.ConnectService, session_1.DOMConnectService);
                    } else if (session_1.DebugConnectService.isAvailable()) {
                        container.registerSingleton(session_1.ConnectService, session_1.DebugConnectService);
                    }
                    if (config.role === common_1.Role.REALITY_MANAGER) {
                        this.reality.registerLoader(container.get(empty_1.EmptyRealityLoader));
                        this.reality.registerLoader(container.get(live_video_1.LiveVideoRealityLoader));
                        if (typeof document !== 'undefined') {
                            this.reality.registerLoader(container.get(hosted_1.HostedRealityLoader));
                            // enable pinch-zoom
                            container.get(view_1.PinchZoomService);
                        }
                        this.reality.setDefault(common_1.RealityView.EMPTY);
                    }
                    // ensure the entire object graph is instantiated before connecting to the manager. 
                    for (var _i = 0, _a = Object.keys(ArgonSystem.prototype); _i < _a.length; _i++) {
                        var key = _a[_i];
                        this[key];
                    }
                    this.session.connect();
                }
                Object.defineProperty(ArgonSystem.prototype, "context", {
                    get: function () {
                        return this.container.get(context_2.ContextService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "device", {
                    get: function () {
                        return this.container.get(device_1.DeviceService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "focus", {
                    get: function () {
                        return this.container.get(focus_1.FocusService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "reality", {
                    get: function () {
                        return this.container.get(reality_1.RealityService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "session", {
                    get: function () {
                        return this.container.get(session_1.SessionService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "timer", {
                    get: function () {
                        return this.container.get(timer_1.TimerService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "view", {
                    get: function () {
                        return this.container.get(view_1.ViewService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "vuforia", {
                    get: function () {
                        return this.container.get(vuforia_1.VuforiaService);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "updateEvent", {
                    // events
                    get: function () {
                        return this.context.updateEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "renderEvent", {
                    get: function () {
                        return this.context.renderEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "focusEvent", {
                    get: function () {
                        return this.focus.focusEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArgonSystem.prototype, "blurEvent", {
                    get: function () {
                        return this.focus.blurEvent;
                    },
                    enumerable: true,
                    configurable: true
                });
                return ArgonSystem;
            }();
            exports_1("ArgonSystem", ArgonSystem);
        }
    };
});
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    Argon = factory();
});